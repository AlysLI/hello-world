!!!!    4    0    1 1603677418   0000                                         
!Testplan for 73-18275-04  Wed Jan  3 08:29:54 2018
dim Pass_Serials$(5000)[15]
!73-18275-04
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                                                           !
!                     C I S C O   S Y S T E M S  ,  I N C .                 !
!                                                                           !
!                             |                   |                         !
!                           .|||.               .|||.                       !
!                           |||||               |||||                       !
!                         .|||||||.           .|||||||.                     !
!                         |||||||||           |||||||||                     !
!                       .|||||||||||.       .|||||||||||.                   !
!                 ....:|||||||||||||||:...:|||||||||||||||:....             !
!                                                                           !
!                                                                           !
!                   1 7 0   W e s t   T a s m a n   D r i v e               !
!                 S a n  J o s e  ,  C A .  9 5 1 3 4 - 1 7 0 6             !
!                                                                           !
!                                                            Ver. 08/29/05  !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                                                           !
!                 File Name         : testplan                              !
!                 Assembly Name     : <assy_name>                           !
!                 Board Name        : SHANNON48U-CR                         !
!                 Assembly P/N      : 800-xxxxx-xx Rev xx                   !
!                 Fab               : 28-13253-04  Rev A0                   !
!                 Bom               : 73-18275-04  Rev B0                   !
!                 Schematic         : 92-101871-04 Rev A0                   !
!                 PCA Map           : 61-101916-01 Rev A0                   !
!                 Test Engineer     : Jack Wu                               !
!                 Last Update       : 12/24/2017                            !
!                                                                           !
!---------------------------------------------------------------------------!
!                                                                           !
!                 ICT board S/N     :                                       !
!                 CIP #             :                                       !
!                 Fixture Asset Tag :                                       !
!                 Installation Date : mm/dd/yy                              !
!                 CM                :                                       !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!         F I X T U R E    C U S T O M    R E Q U I R E M E N T S           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!Items                      | Installed | Wiring Instructions | Comments    !
!                           | (Y/N)     | File Name           |             !
!---------------------------+-----------+---------------------+-------------!
!Present Switch             |   Y       |PRESENCE_SWITCH_WIRING             !
!---------------------------+-----------+---------------------+-------------!
!LED Testing                |           |                     |             !
!   SmartFinn               |   N       |                     |             !
!   Ledcheck                |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Other LED Testing          |   N       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Clock Divider Board*       |           |                     |             !
!   PECL Clock Divider      |   Y       |clock_divider.xlsx   |             !
!   700MHz CLK Divider      |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Termination Resistor       |   N       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Pull-up/down Resistor*     |   N       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Long Probe for Dual Stage* |   Y       |long_probe.txt       |             !
!---------------------------+-----------+---------------------+-------------!
!Probe Removed*             |   N       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Special Probe Style        |           |                     |             !
!   Focal Probe*            |   N       |                     |             !
!   X Probe*                |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Special Probe Type*        |   N       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Heat Sink                  |   Y       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Fan                        |   Y       |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Miscellaneous              |   N       |                     |             !
!                           |           |                     |             !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!Reference should be with 1). Node name 2). Probe number 3). PP number


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                   R E L E A S E   C H E C K L I S T                       !
!---------------------------------------------------------------------------!
! No. | Actions                                               | Yes or N/A  !
!-----+-------------------------------------------------------+-------------!
! 01  | Provided all header information in testplan.          |             !
!-----+-------------------------------------------------------+-------------!
! 02  | All option flags set up correctly as defined for      |             !
!     | production in testplan.                               |             !
!-----+-------------------------------------------------------+-------------!
! 03  | Programmed IDROM according to PCAMAP.                 |             !
!-----+-------------------------------------------------------+-------------!
! 04  | Verified IDROM programming with function test,        |             !
!     | including 8-bit vs 16-bit.                            |             !
!     | Name of Function Test engineer who helped verify.     |             !
!-----+-------------------------------------------------------+-------------!
! 05  | If no PCAMAP is used, the IDROM digital test should   |             !
!     | execute the ERASE command to write back all address   |             !
!     | locations with a default value to avoid boot up issue |             !
!     | at function test and diag.                            |             !
!-----+-------------------------------------------------------+-------------!
! 06  | Test options, KGB and BOM match with assembly number. |             !
!-----+-------------------------------------------------------+-------------!
! 07  | Updated testplan with devices not tested in section   |             !
!     | "parts not tested".                                   |             !
!-----+-------------------------------------------------------+-------------!
! 08  | Moved board directory to "released" directory.        |             !
!-----+-------------------------------------------------------+-------------!
! 09  | Moved new or custom test libraries to central         |             !
!     | library.                                              |             !
!-----+-------------------------------------------------------+-------------!
! 10  | Assembly options verification.                        |             !
!-----+-------------------------------------------------------+-------------!
! 11  | Plugged all receptacles with probes removed.          |             !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                  E C O ' S                                !
!---------------------------------------------------------------------------!
!                                                                           !
! Date      ECO #      Status  By  What Changes                             !
! --------  ---------  ------  --  ---------------------------------------- !
! 12/15/19  D551606   Clyde Huang  Skip testjet imbu2 pins 7,8,12,13,22,45  !
!
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                  N O T E S                                !
!---------------------------------------------------------------------------!
!                                                                           !
! Date      Status  By  Notes                                               !
! --------  ------  --  --------------------------------------------------- !
! 07/11/18  v1 to v2  Clyde Huang  Update 48pcs capacitors under RJ45       !
!                                                                           !
! mm/dd/yy  ???     ??                                                      !
!                                                                           !
!                                                                           !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!          T E S T M A I N     R E V I S I O N     H I S T O R Y            !
!---------------------------------------------------------------------------!
!                                                                           !
! Date      Verified  By  Notes                                             !
! --------  --------  --  ------------------------------------------------- !
! 05/29/07   Yes      DL  Disabled vacuum recycling when running in         !
!                         evaluation mode, a new requirement.               !
!                                                                           !
!                         Updated serial number validation per new document !
!                         number 70106-0000 revision G0. Characters 'I' and !
!                         'O' are now valid to use in location (LLL) and    !
!                         sequential serial ID (SSSS). Location (LLL) is    !
!                         now of base 36, alpha/numeric.                    !
!                                                                           !
! 10/05/06   Yes      DL  Updated with new Cisco logo.                      !
!                                                                           !
!                         Added stop when evalog failed to run.             !
!                                                                           !
! 09/05/06   Yes      DL  Undo "object checking off." This is only done     !
!                         prior to program release.                         !
!                                                                           !
!                         Delete subroutine Tup. Use function looptest      !
!                         instead.                                          !
!                                                                           !
!                         Move TestJet call to after Analog_Tests and       !
!                         remove the "unpowered" after TestJet.             !
!                                                                           !
! 08/09/06   Yes      DL  Turned off object checking as part of Test Time   !
!                         Reduction (TTR).                                  !
!                                                                           !
! 08/29/05   Yes      DL  Changed final report destination from             !
!                         "/dev/rpr"&th$ to btgetenv$("RPR"&th$) for PC     !
!                         compatibility.                                    !
!                                                                           !
! 01/20/05   Yes      DL  Added call to program evalog.                     !
!                                                                           !
! 08/26/04   Yes      DL  Changed default setting for Evaluation_runs to    !
!                         20 per new requirements.                          !
!                                                                           !
! 08/17/04   Yes      DL  Changed codes for Evaluation run data logging.    !
!                                                                           !
! 08/16/04   Yes      DL  Added new checklist item for receptacle plugins.  !
!                                                                           !
!                         Added custom subroutine Check_BD_Present to check !
!                         for board presence prior to testing.              !
!                                                                           !
! 07/08/04   Yes      DL  Added feature to support serial number            !
!                         validation.                                       !
!                                                                           !
! 05/19/04   Yes      DL  Updated sub Regulators and sub CPLDs with         !
!                         parameters for 5.21 and later compatibility.      !
!                                                                           !
! 03/01/04   Yes      DL  Copied Agilent 3070 standard testmain rev 05.30p  !
!                         and migrated custom features from pre 05.30       !
!                         testmain.                                         !
!                                                                           !
!                         Added options to support ICT Aware process        !
!                         (CISCO_ICT_AWARE).                                !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!##############################################################################
!   AGILENT 3070 STANDARD TESTMAIN       Revision: "3070 05.30p 0603(full)"
!   STANDARD VERSION
!##############################################################################
!   This "main" program sequences execution of testplan subroutines and
!   assumes that the current working directory is already set to the
!   appropriate board directory.
!   This testmain has included the code to support the following optional
!   features:
!        Data Logging for PushButton QSTATS, QSTATS-II and ART
!        Chek-Point (pin tests)
!        Boundary Scan:  Interconnect Plus & ScanWorks
!        Agilent Intelligent Yield Enhancement Test (IYET)
!   Once the testplan is working, you may selectively enable
!   any combination of the features by changing the 'flag' variables
!   in the subroutine "Set_Custom_Options".  Use the following command:
!         find  "!   Other"&" parameters"  ! takes you to option settings
!
!   Turn learn on and run the testplan on a known good board.  After the
!   learning run is successfully completed, the testplan is ready for
!   customization, debug and production testing.
!   Analog limits are logged by standard testmain if and only if the
!   learn flag is on.  Limits must be logged once each time they change
!   in order for PushButton Q-STATS or Q-STATS II to produce histograms.
!
!   If flash is to be programmed on this board, the testplan needs to have the
!   locations marked !flash! modified or reviewed.  Please review the flash
!   manual for full explanation. Key elements include:
!
!   full disabling of buses and upstream control lines is required for safety
!   use ID check for digital test subroutine to ensure proper part placement
!   Cycle power if required to three-state upstream devices

!                             SYSTEM VERIFY     !TARS
!                          ====================

System$ = "invalid"

SystemOption:
    enter "uname -n |" ; System$

               if System$ = "SHAHP08" then
                  Macaddress$ = "000BAB08CBE6_"
                  goto Machine_OK
               end if

               if System$ = "SHAHP10" then
                  Macaddress$ = "000BAB08C28C_"
                  goto Machine_OK
               end if

               if System$ = "SHAHP13" then
                  Macaddress$ = "000BAB0AF6A2_"
                  goto Machine_OK
               end if

               if System$ = "SHAHP16" then
                  Macaddress$ = "001A4BC4F5AB_"
                  goto Machine_OK
               end if

               if System$ = "SHAHP18" then
                    Macaddress$ = "001321C6F47A_"
                    goto Machine_OK
               end if

               if System$ = "SHAHP19" then
                    Macaddress$ = "001E0B65E255_"
                    goto Machine_OK
               end if

               if System$ = "SHAHP21" then
                    Macaddress$ = "000BAB0AD843_"
                    goto Machine_OK
               end if

               if System$ = "SHAHP25" then
                  Macaddress$ = "002481118BA4_"
                  goto Machine_OK
               end if

               if System$ = "SHAHP31" then
                  Macaddress$ = "00101859A1B5_"
                  goto Machine_OK
               end if


  if System$ = "invalid" then goto  SystemOption
                                     !
!*************************************************************************!
   print using "@" | print

!rint tab(12);chr$(27)&"&v1S   ------------------------------------------- "
!rint tab(12);chr$(27)&"&v1S        CANNOT RUN THIS CODE ON " &System$ &"  "
!rint tab(12);chr$(27)&"&v1S   ------------------------------------------- "


!top    ! exit program if invalid system detected.

Machine_OK:
print tab(12);chr$(27)&"&v2S   -------------------------------------------"
print tab(12);chr$(27)&"&v2S        OK TO RUN THIS CODE ON " &System$ &""
print tab(12);chr$(27)&"&v2S   -------------------------------------------"
wait 2  ! display message to operator validating correct machine

!===========================================================================
!if Frun=0 then
!  execute "C:/Agilent3070/boards/VA/SVABU/PDF/25-TE40-CIS73-12009-001-A.pdf";window
!end if

! Miscellaneous string variable size declarations:

    ! VARIABLE DEFINITIONS AND INITS FOR TARS
    !
     dim Customer$[18]   ! customer name
     Customer$ = "CISCO"
     dim BStyle$[16]     ! board style
     BStyle$   = ""      ! to be set in menu selection
     dim Site$[2]        ! site variable:
    !                     1- South     St. Petersburg, FL
    !                     2- Boxbuild  St. Petersburg, FL
    !                     3- North     Auburn Hills, MI
    !                     4- West      San Jose, CA
    !                     5- Scotland  Europe
    !                     6- Penang    Malaysia
! For EEPROM (at24c04)
!*************************************************************!
! Modify Serial number begin and end address accordingly.
!*************************************************************!
! Write/Read production test global variables
dim EpromData(0:511)     ! 512 address locations.
dim EpromData_4k(0:4095) ! 512 loc * 8 bit data.
! Read_eeprom content global variables
dim Read_Data_u103(15)

!IR3570
dim IR(24)
dim IR_REG$(3)
dim IR_POINTER(15)
dim IR_IMBU1(24)
dim IR_IMBU1_POINTER(15)
dim IR_FMCU1(24)
dim IR_FMCU1_POINTER(15)


! EEprom variables
! for U105 quack ic programming
!dim HDR1(0:127),HDR2(0:127),HDR3(0:127)
!dim EE_D1(0:1023),EE_D2(0:1023),EE_D3(0:1023)
!dim XSUM1(0:15),XSUM2(0:15),XSUM3(0:15)
!dim EE_R1(0:1023),EE_R2(0:1023),EE_R3(0:1023)

dim HDR1(0:127),EE_D1(0:1023),EE_R1(0:1023),XSUM1(0:15)
dim HDR2(0:127),EE_D2(0:1023),EE_R2(0:1023),XSUM2(0:15)
dim HDR3(0:127),EE_D3(0:1023),EE_R3(0:1023),XSUM3(0:15)
dim HDR4(0:127),EE_D4(0:1023),EE_R4(0:1023),XSUM4(0:15)
dim HDR5(0:127),EE_D5(0:1023),EE_R5(0:1023),XSUM5(0:15)
dim HDR6(0:127),EE_D6(0:1023),EE_R6(0:1023),XSUM6(0:15)
dim HDR7(0:127),EE_D7(0:1023),EE_R7(0:1023),XSUM7(0:15)
dim HDR8(0:127),EE_D8(0:1023),EE_R8(0:1023),XSUM8(0:15)

dim Read_Data(0:4095)

     Site$     = "19"         !SOUTH
     dim Line$[2]        ! build location/line #
     dim Deviation$(0:256)
     dim Deviation2$(0:256)
     Strip_Printer = 0! 1 is printer 0 is window
     Frun = 0 !added to control menu scanning
     dim Fail_CRD$(0:2048)
     dim PTech2$(0:100)

dim InvOn$[5], InvOff$[4]
dim Testmain_Revision$[70]
dim Batch$[12], Oper$[25], Testplan$[14], Testrev$[4]
dim Board$[14], Board_Rev$[14], Known_Good$[1]
dim Proc_Step$[5], Log_Path$[80]
! The following is used in the power-supply setup routine for parallel
! power supplies.  It holds masks for comparison.
dim Psgroup(1:16)
option bit 32     ! Prevents range error when comparing Psgroup with MSB set
! IYET
dim IYET_Failing_Tests$(0:2047)[40]
dim IYET_Retest_Failing_Devices$(0:8191)[40]
dim IYET_Top_Retests$(0:8191,2)[40]
dim All_Serial$(5000)[15]

!!EEprom variable
dim Xmit_Val_W1(4096)
dim Xmit_Val_W2(4096)
dim Mem_Table(4096)


!       INITIALIZE BREAK AND ERROR TRAPPING

on break recover Break_Trap
on error recover Error_Trap

!       INITIALIZE VARIABLES

call Initializations
execute "'C:\Agilent_ICT\sop.bat'"  !@ add by Luke
!+030104S
!call Operator_debug
!+030104E

!       SET UP FAILURE ACKNOWLEDGMENT
acknowledge all failures

!       MAIN LOOP FOR REPEATEDLY TESTING A BOARD
!          (executed only once if "learning")

!+030104S
if nrun = 1 then
   Ptimes = 0  ! Number of passes
   Ftimes = 0  ! Number of fails
   Atimes = 0  ! Accumulative test times
end if

!-if Evaluation then Eval_loop = 0 !012005
if Evaluation then
     Eval_loop = 0
     execute "evalog -t testplan", Err; append, nowait !012005
     if Err then  !100506
        print
        print "ERROR: Failed to run program evalog."
        print "Aborted..."
        print
        stop
     end if
end if
!+030104E

report is "C:\Program Files\paperless_repair\73-18275-05",window;append
!@report is Report_Printer$, window;append

Wait_For_Start:
!#################### beacon block1#####################
unlink "mylog.txt" ,Err
Start_time_beacon= msec
enter "date +""%Y-%m-%d %H:%M:%S""|"; Starttime$
!##################### beacon block1 end ################

if Evaluation then
   if Aware_fail_report then
     execute "AwareFailMap -m "&Aware_bom_map$, Err; append, nowait
     if Err then
        print
        print "ERROR: Failed to run AwareFailMap."
        print
        stop
     end if
   end if

   Eval_loop = Eval_loop + 1  ! Increment loop count

   if Eval_loop = 1 then
      assign @RPT to Eval_Rpt$; write, append
      output @RPT; "{@EVAL|"; datetime$; "|"; Board$; "|"; Board_Rev$;"|"; System$; "|"; val$(Evaluation_runs); "}"
      assign @RPT to *
   end if

   if Eval_loop > Evaluation_runs then
      if Aware_fail_report then
     report is "C:\Program Files\paperless_repair\73-18275-05",window;append
       !@report is Report_Printer$; append
      else
      report is "C:\Program Files\paperless_repair\73-18275-05",window;append
      !@ report is Report_Printer$; append, echo
      end if

      print | print
      print "Time       : ";time$
      print "Board Name : ";Board$
      print "Board Rev  : ";Board_Rev$
      print "Tester Name: ";System$
      print "Number of runs   =  ";Ptimes+Ftimes
      print "Number of passes =  ";Ptimes
      print "Number of fails  =  ";Ftimes
      print | print | print | print | print | print | print | print

      assign @RPT to Eval_Rpt$; write, append
      output @RPT; "{@EVAL_END|"; datetime$; "|"; Board$; "|"; Board_Rev$;"|"; System$; "|"; val$(Ptimes); "|"; val$(Ftimes); "}"
      assign @RPT to *

      if Ftimes > 0 then  ! log failures only if failed at least once
         append Report_Printer$ to Eval_Rpt$, Err
         if Err <> 0 then print errm$
      end if

      print "Check results in "; Report_Printer$  !Eval_Rpt$
      print
      clear nrun
      stop       ! End of evaluation runs
   end if
end if
!081704

call Get_Version

Pass_Fail_Reported = False
Logging_Started = False
Tests_On_This_Board = 0

!-030104S
!print | print Place_Board_Prompt$
!wait for start
!-030104E

!+030104S
if Evaluation then
   if (Ptimes+Ftimes)=0 then
      print using "@"
      print | print
     ESTART:
      beep | beep
      question ">>>Click 'yes' to start evaluation.....",Eval_start
      if not Eval_start then
         beep | beep
         goto ESTART
      end if
   end if
!052907 - No longer needed; Vacuum recycling not required.
!  if (Ptimes+Ftimes) then
!    wait 2   ! Wait between runs allowing vacuum recycling
!  end if
else
! print | print Place_Board_Prompt$
! wait for start
end if

Start_time = msec
!+030104E

if Serializing then
  print using "@"


! Serial$ = fn Get_Serial_Num$(Serial_Prompt$)  !070804

 Count_number = 1
 Exist_pass = 0
 CHECK_SN:
 if Exist_pass = 1 then
    print chr$(27)&"&v1s"&"**************************"
    print chr$(27)&"&v1s"&"****** It is a tested Board ****"
    print chr$(27)&"&v1s"&"**************************"
    Exist_pass = 0
 end if
  loop
     Serial$ = fn Get_Serial_Num$(Serial_Prompt$)
     Serial$ = upc$(Serial$)
     Serial1$ = upc$(Serial$)
     exit if fn Validate_SN(Serial$)
     print
     print "ERROR: Invalid Serial Number!!!!!"
     if len(Serial$) = 11 or len(Serial$) = 20 then
        print "Must be LLLYYWWSSSS, where:"
!       print "   LLL is Location, base 34, alpha/numeric, no I and O"
        print "   LLL is Location, base 36, alpha/numeric"  !052907
        print "   YYWW is Year and Workweek, base 10, numeric"
!       print "   SSSS is Serial Id, base 34, alpha/numeric, no I and O"
        print "   SSSS is Serial Id, base 36, alpha/numeric"  !052907
     else
        if len(Serial$) = 8 then
           print "Must be alpha/numeric ONLY"
        end if
     end if
     print
  end loop
    for I = 0 to Nnum-1
   if Pass_Serials$(I)=Serial$ then
      Exist_pass = 1
      goto CHECK_SN
   end if
next I
  Known_Good$ = "n"
  if Serial$ = Known_Good_Board$ then Known_Good$ = "y"

print | print Place_Board_Prompt$
wait for start
unlink "C:\Program Files\Cisco\meter\Autotest_mdas_log",Err
!+030104S
!Begin_closegate:
!   question InvOn$&"Press YES after closed TOP GATE"&InvOff$, Y
!   if Y then goto End_closegate
!   goto Begin_closegate
!End_closegate:
!+030104E

  if Using_AwareTest = True then
    ! remove special characters
    Serial_New$ = fn Remove_Special_Characters$(Serial$)
    Path$ = Serial_Number_Directory$ & Serial_New$ & Serial_Suffix$
    enter Path$,, Err

    !! Added the following code to check for all uppercase or all lowercase
    !! serial numbers.
    if Err then
       Path$ = Serial_Number_Directory$ & upc$(Serial_New$) & Serial_Suffix$
       enter Path$,, Err
       if Err then
          Path$ = Serial_Number_Directory$ & lwc$(Serial_New$) & Serial_Suffix$
          enter Path$,, Err
       end if
    end if

    if Err then
      ! serial number file was not found -- board was not tested on AXI
      if AXI_Tested_Override = False then
        print Not_AXI_Tested$
        goto Wait_For_Start
      else
        ! Add custom code here if serial number is missing and
        ! you do not want to completely skip the PC board test
      end if
    end if
  end if
end if
if Using_Multiple_Versions and Version_Prompting = Per_Board then
  call Get_Version_Label
  if nrun = 1 or Version_Inits_Needed then
    call Do_Version_Inits
  end if
end if

!       RE-TEST AFTER PIN-TEST FAILURE

ChekPoint_Retry:

print using "@,/"

!081704
if Evaluation then
   report "RUN "; val$(Eval_loop)
end if
!081704

if Serializing then print But$; Serial$
Tests_On_This_Board = Tests_On_This_Board + 1
if Tests_On_This_Board > 1 then print Rep_Test$

!       START LOGGING FOR THIS BOARD

!report is Report_Printer$, window;append

!-030104S
!report is Report_Printer$
!-030104E

!+030104S
if Evaluation then
   if Aware_fail_report then
    report is "C:\Program Files\paperless_repair\73-18275-05",window;append
    !@report is Report_Printer$; append
   else
    report is "C:\Program Files\paperless_repair\73-18275-05",window;append
    !@report is Report_Printer$; echo, append
   end if
end if

if Print_to_file then
   if Evaluation then
      if Aware_fail_report then
         report is "C:\Program Files\paperless_repair\73-18275-05",window;append
         !@report is Report_Printer$; append
      else
       report is "C:\Program Files\paperless_repair\73-18275-05",window;append
       !@  report is Report_Printer$; echo, append
      end if
   else
      if Aware_fail_report then
       report is "C:\Program Files\paperless_repair\73-18275-05",window;append
       !@report is Report_Printer$
      else
      report is "C:\Program Files\paperless_repair\73-18275-05",window;append
      !@ report is Report_Printer$; echo
      end if
   end if
else
!  report is Report_Printer$
end if
!+030104E

if Logging then call Start_Logging
Logging_Started = True   ! Also used as reporting flag

!       ACTIVATE VACUUM IN PREPARATION FOR TEST

Start = msec

!*******************************************
call Check_BD_Present  !081604
!*******************************************

if Tests_On_This_Board = 1 then faon 1.5
!faoff 1.3|faon 1.0
! Warning: Reducing the value for 'faon' from the default value of 1.5
! can potentially cause testhead damage.


!       CHECK FIXTURE CONTACT, THEN
!       LEARN OR TEST (OR RE-TEST) BOARD

!+030104S
if Print_board_msg then
   print using "@"
   call Print_board_testing_msg
end if
!+030104E

unpowered

if (not learning) and Chek_Point_Mode = Pretest then
!-030104S
! if not fn Chek_Point_OK then goto Cleanup
!-030104E
!+030104S
  if not fn Chek_Point_OK then
    if Continue_after_pins_failed = True then
      beep
      beep
      print
      question ">>> Continue testing (yes/no)?",Cont_ans
      if Cont_ans then
        print "Yes"
        goto Start_test_sections
      else
        goto Cleanup
      end if
    else
        goto Cleanup
    end if
  end if
!+030104E
end if

!+030104S
Start_test_sections:
!+030104E

call Test_Sections

!       IF ANY BOARD FAILED TEST, TRY TO FIX IT BY RUNNING PIN TEST

Cleanup:

!081704
if Evaluation then
   assign @RPT to Eval_Rpt$; write, append
   output @RPT; "{@RUN "; val$(Eval_loop); "|"; datetime$; "|"; fnTest_Status$(boardfailed); "}{@RUN_END}"
   assign @RPT to *
end if
!081704

if boardfailed and Status <> Failed_In_Preshorts then
  if Tests_On_This_Board = 1 and Chek_Point_Mode = Failures then
    unpowered
    if fn Chek_Point_OK then goto ChekPoint_Retry
  end if
end if

!       REMOVE BOARD FROM TESTHEAD AND GENERATE PASS/FAIL MESSAGE
!       THEN TERMINATE LOGGING (IF ENABLED) AND REPORTING

!-030104S
!faoff  !Moved pass if...end if below to avoid lifting up fixture gate
        !in the middle of the program.
!faoff
 faon !|wait 2
 auxdisconnect all   !|wait 2
faoff
!TAU|if not (Run_Testjet_Analysis or Run_Analog_Analysis) then faoff



!-030104E

!+030104S
!unpowered  !Added for print failures option to avoid unattended power-on UUT.
!+030104E

Stop1 = msec

!!********************* Section for record FPY **************************!!
if Operator$ <> "debug" then
  A = dround((Stop1-Start)*1m,4)
  FPY$ = "FPY/FPY_" & System$ & "_" & datetime$[1;6] & "_" & Board$ & ".txt"
  assign @FP to FPY$ ; write, append
  if boardfailed then
    output @FP ; datetime$, Serial$[1;11]; ":FAILED "; A
    create dir "FPY/" & datetime$[1;6], Error
    if (Error <> 100312) and (Error <> 0) then
      print "Cannot create directory for FPY failure log"
      print errmlong$(Error)
    else
    if Using_Buffered_Reporting then
      Path$ = "FPY/" & datetime$[1;6] & "/"
      File$ = System$ & "_" & datetime$ & "_" & Serial$[1;11] & ".txt"
      report out Path$ & File$
    end if
    end if
  else
    output @FP ; datetime$, Serial$[1;11]; ":PASSED "; A; User_Name$
  end if
  assign @FP to *
end if

print
print chr$(27);"&v7S Total Test Time BEFORE Re-Scan=";dround((Stop1-Start)*1m,4);"sec."


Pass_Fail_Reported = True
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!~~~~~Modified for adding FCS~~~~~~
!printer is "Z:\"&System$&datetime$&".txt"
!  print  Fixture_id$;" "&Serial$; Count_number
! printer is *

!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
   !~~~~~Modified for adding FCS~~~~~~                     !!YI
  printer is "d:\fixtureupload\"&System$&datetime$&".txt"
  print  Fixture_id$;" "&Serial$; Count_number
  printer is *
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!



create dir"C:\Program Files\Cisco\meter\back" ,Err

if Logging then
  log board end Status
  log out "C:\Program Files\Cisco\meter\Autotest_mdas_log"
  log out "D:\fulllog\"&Serial$&datetime$&".txt";append
  log clear
end if
call Get_becon_log !##############add for beacon############
 if not boardfailed or fnSendMsg then
  Pass_Serials$(Nnum)=Serial$
  Nnum=Nnum+1
  execute "'C:\Program Files\Cisco\meter\bin\metersoft.pl'"  !metersoft
!@  else
!@  question ">>>>>> Do you want send Fail Record out?<<<<<",R
!@  if R then
!@  execute "'C:\Program Files\Cisco\meter\bin\metersoft.pl'"
!@  end if
 end if
log clear
 execute "rm -r 'C:\Program Files\Cisco\meter\back'"

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          !----------- paperless repair and daily report ---------

  report is "C:\Program Files\paperless_repair\73-18275-05",window;append
 if boardfailed and Serializing then report Serial_Nr$ & Serial$
  if boardfailed then
    report using Eject_Ticket
    report "*"
   if Using_Buffered_Reporting then report out
     else
    report clear
        report chr$(27)&"&v2S *************************"
        report tab(3);chr$(27)&"&v2S PASS  73-18275-05  PASS"
        report tab(3);chr$(27)&"&v2S";time$
        report tab(3);chr$(27)&"&v2S";Serial1$
        report tab(3);chr$(27)&"&v4S Tester Name:";System$
        report tab(3);chr$(27)&"&v4S Operator Id:";Oper$[1;8]
        report tab(3);chr$(27)&"&v4S Fixture_id:";Fixture_id$
        report chr$(27)&"&v2S *************************"
        report
    report
    report "*"
    if Using_Buffered_Reporting then report out
  end if
  if learning then Status = Failed_In_Learn
  assign @Data to "E:\"&Serial1$;write,append
  append "E:\"&Serial1$ to "C:\Program Files\paperless_repair\73-18275-05"
  copy "C:\Program Files\paperless_repair\73-18275-05" over "E:\"&Serial1$
  assign @Data to *
  unlink "C:\Program Files\paperless_repair\73-18275-05"

!~~~~~~~~~~~~~~~~~~~~~~~~~Metersoft End~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Eject_Ticket: image 13/
!unlink "C:\Program Files\Cisco\meter\Autotest_mdas_log",Err !Move to start clyde 2020/6/23

if boardfailed then
!+030104S
  Ftimes = Ftimes + 1  !Increment fail count
!+030104E
  report "     **  ";Fail_Msg$;"  **"  !081704
  copy Fail_File$ over "/dev/tty"
  if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
  end if
  if learning then Status = Failed_In_Learn
  if Serializing then
    report ""
    report " **************FAILED ICT**************"
    report "   Assembly Num : ";Assembly$
    report "   Serial Number: ";Serial$[1;11]
    report "   Time: ";time$
    report "  Tester Name:";System$
   report "  Operator Id:";Oper$[1;8]
   report "  Fixture_id:";Fixture_id$
    report " --------------------------------------"
    report ""
  end if
! report using Eject_Ticket
  if not Evaluation then report using Eject_Ticket  !081704
  if Using_Buffered_Reporting then report out
!+030104S
  if not Evaluation then
     if Aware_fail_report then
! CISCO_ICT_AWARE - From Here
        execute "AwareFailMap -m "&Aware_bom_map$, Err; append, nowait
! CISCO_ICT_AWARE - To Here
        if Err then
           print
           print "ERROR: Failed to run AwareFailMap."
           print
           stop
        end if
     end if
     if Print_to_file then
        if Question_to_print then
           beep
           beep
           print
           question ">>> Print failures (yes/no)?",Err_print
!#!        if Err_print then copy "debug/report" over "/dev/rpr"&th$
!082905 - For PC Compatibility.
           if Err_print then copy "debug/report" over btgetenv$("RPR"&th$)
        else
!#!        copy "debug/report" over "/dev/rpr"&th$
!082905 - For PC Compatibility.
           copy "debug/report" over btgetenv$("RPR"&th$)
        end if
     end if
  end if
!+030104E
else
!+030104S
  Ptimes = Ptimes + 1  !Increment pass count
!+030104E
  report "     **  ";Pass_Msg$;"  **"  !081704
  copy Pass_File$ over "/dev/tty"
!+030104S
  if Print_pass_ticket then
     !report is Report_Printer$
       report ""
       report " --------------------------------------"
       report " **************PASSED ICT**************"
       report "   Assembly NUM : ";Assembly$
       report "   Serial Number: ";Serial$[1;11]
       report "   Time: ";time$
       report "   Operator:";Oper$
       report " --------------------------------------"
       report ""
     report using Eject_Ticket
!#!  copy "debug/report" over "/dev/rpr"&th$
!082905 - For PC Compatibility.
!    copy "debug/report" over btgetenv$("RPR"&th$)
     if Aware_fail_report then
       report is "C:\Program Files\paperless_repair\73-18275-05",window;append
       !@eport is Report_Printer$
     else
    report is "C:\Program Files\paperless_repair\73-18275-05",window;append
    !@  report is Report_Printer$; echo
     end if
  end if
!+030104E
  if Using_AwareTest = True then
    enter Path$,, Err  ! check to see if serial number file exists
                       ! Err = 100009 (File Not Found)
    if not Err then    ! Do not create new serial number files
      enter "date +%Y%m%d%H%M |"; Passed_Datetime$
      assign @SNF,Err to Path$; write, append
      if Err then      ! problems writing to serial number file
        print SNF_Error_Msg$  |   print "    ";errm$
        beep
        ! print | print Stop_Msg$
        ! stop
      else
        output @SNF; "passed3070 = " & Passed_Datetime$
        assign @SNF to *
      end if
    end if
  end if
end if

Stop = msec
print
print chr$(27);"&v7STest Time AFTER Re-Scan =";dround((Stop-Start)*1m,4);"sec."

if Oper$ = "debug" then
  print tab(5);chr$(27)&"&v7S ***************************"
  print tab(5);chr$(27)&"&v7S * WARNING WARNING WARNING *"
  print tab(5);chr$(27)&"&v7S *  THIS BOARD WAS TESTED  *"
  print tab(5);chr$(27)&"&v7S *      IN DEBUG MODE.     *"
  print tab(5);chr$(27)&"&v7S *  PASS/FAIL INFORMATION  *"
  print tab(5);chr$(27)&"&v7S *   WILL NOT BE IN TARS   *"
  print tab(5);chr$(27)&"&v7S ***************************"
end if

!+030104S
!052907 - Only faoff when not in evaluation...
!faoff  !Moved here from the most outer if...end if above.
!+030104E

!-030104S
!report is *
!-030104E
!+030104S
if not Evaluation then
   faoff  !052907
!  report is *
end if
!+030104E

if Logging then
  log board end Status
!-030104S
! log out Log_Path$ & datetime$ & System$ & th$
!-030104E
! CISCO_ICT_AWARE - From Here
  if Aware_fail_report then
     log out "/tmp/fail_log"
     execute "AwareFailMap -m "&Aware_bom_map$&"-r /tmp/fail_log", Err; append, nowait
     copy "/tmp/fail_log" over Log_Path$ & datetime$ & System$ & th$
  else

   end if
! CISCO_ICT_AWARE - To Here
  log clear
end if
report clear
clear failures
Logging_Started = False

!       END PROGRAM IF LEARNING. OTHERWISE RETURN TO MAIN LOOP

if learning then
   learn off
   print | print Learning_Off_Msg$ | print Stop_Msg$
   beep
   stop
end if

!+030104S
!Test_time = (msec - Start_time)/1000
!print "Test time was ";Test_time;" seconds."
!Atimes = Atimes+Test_time  !Add to accummulative test time
!RPT1: image 8a, 2a, 4d, 6x, 18a, 2a, 6d.2d
!print using RPT1;"Runs","= ",Ptimes+Ftimes,"Total Test Time","= ",Atimes/60," min"
!print using RPT1;"Passes","= ",Ptimes,"Average Test Time","= ",Atimes/(Ptimes+Ftimes)," sec"
!print using RPT1;"Fails","= ",Ftimes,"Pass Yield","= ",(Ptimes/(Ptimes+Ftimes))*100," %"
!+030104E

call Show_FPY

goto Wait_For_Start

!       END OF MAIN LOOP
!       INTERRUPT HANDLING
! This is the normal entry for Break/Stop detection

Break_Trap:
call Register_ID_GUI

off break
off error
print "     ";Break_Msg$
unpowered,Err
if Err then print errmlong$
if Logging and Logging_Started then
  log board end Break_Code
!-030104S
! log out Log_Path$ & datetime$ & System$ & th$
!-030104E
! CISCO_ICT_AWARE - From Here
  if Aware_fail_report then
     log out "/tmp/fail_log"
     execute "AwareFailMap -m "&Aware_bom_map$&"-r /tmp/fail_log", Err; append, nowait
     copy "/tmp/fail_log" over Log_Path$ & datetime$ & System$ & th$
  else
     log out Log_Path$ & datetime$ & System$ & th$
  end if
! CISCO_ICT_AWARE - To Here
  log clear
end if
faoff, Err
if Err then print errmlong$
goto Abort

! This is the normal entry for errors occurring in Basic statements

Error_Trap:
off error
print errmlong$
beep
SaveErrn = errn
unpowered,Err
if Err then print errmlong$

!       IF A BOARD IS PRESENT, FAIL IT
!       THEN TERMINATE LOGGING (IF ENABLED) AND REPORTING

if Logging_Started and not Pass_Fail_Reported then
  fail device
  report Board_Not_Tested$
  print "     **  ";Fail_Msg$;"  **"
  copy Fail_File$ over "/dev/tty"
  if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
  end if
  if Serializing then report Serial_Nr$ & Serial$
  report using Eject_Ticket
  if Using_Buffered_Reporting then report out, Err
  report is *, Err
  report clear
end if
if Logging_Started and Logging then
  log using """{@RPT~80|"",80a,""}""" ; errm$(SaveErrn)
  log board end Error_Code, SaveErrn
!-030104S
! log out Log_Path$ & datetime$ & System$ & th$
!-030104E
! CISCO_ICT_AWARE - From Here
  if Aware_fail_report then
    log out "/tmp/fail_log"
    execute "AwareFailMap -m "&Aware_bom_map$&"-r /tmp/fail_log", Err; append, nowait
    copy "/tmp/fail_log" over Log_Path$ & datetime$ & System$ & th$
  else
     log out Log_Path$ & datetime$ & System$ & th$
  end if
! CISCO_ICT_AWARE - To Here
  log clear
end if

!       REMOVE THE BOARD FROM THE TESTHEAD

faoff, Err
if Err then print errmlong$
if learning or Err then goto Abort
on error recover Error_Trap
goto Wait_For_Start

!       ABORT PROGRAM: UNRECOVERABLE ERROR, LEARN ERROR OR STOP KEY

Abort:

off break
off error
!#report is *, Err
log is *, Err
beep
if (nrun=1) and not Did_First_Run_Inits then
  print No_Init_Warning$
  clear nrun
else
  if Version_Inits_Needed then
    print No_Version_Init_Warning$
    clear nrun
  end if
end if
print "     ";Stop_Msg$
beep
stop
end

!       END OF ERROR TRAPS

!       Test/Learn Sections
!    [ Assumes unpowered mode. ]
! Note concerning LEARN MODE:  some sections are not truly "learned" but are
! run in learn mode for other reasons.  For example, analog tests may be run
! in learn mode in order to log limits information used by Pushbutton QSTATS,
! and preshorts/shorts are run "just in case" -- to avoid bad learns & damage.
! To keep a section from being run in learn mode, place 'if not learning then'
! just before that section and place 'end if' just after it.
!##############################################################################
sub Test_Sections
global PreshortsMsg$, ShortsMsg$, PowerMsg$, DigitalMsg$, AnalogMsg$
global DigitalFuncMsg$, AnalogPoweredMsg$, BScanIncktMsg$, BScanIntconMsg$
global Status, Failed_In_Preshorts, Failed_In_Shorts, Failed_In_Functional
global Failed_In_Digital, Failed_In_Power_Supplies, Failed_In_Analog
global Logging, True, False, Passed
global Mode$, Failed_In_BScan
global TestJetMsg$, Failed_In_TestJet
global PolarityMsg$, Failed_In_Polarity_Check
global BScanPShortsMsg$
global ConnectCheckMsg$, Failed_In_ConnectCheck
global Failed_In_Flash, FlashProgMsg$, Programming
global AnalogClusterMsg$, Failed_In_Analog_Cluster
global BScanSiNailsMsg$, Failed_In_BScan_SiNails
global SW_ScanPathVerifyMsg$, Failed_In_SW_Testing
global SW_DrVerifyMsg$, SW_IrVerifyMsg$
global SW_InterconnectMsg$, SW_MemInterconnectMsg$
global SW_ClusterMsg$, SW_MemBistMsg$
global SW_ProgrammingMsg$, Failed_In_SW_Programming
global SW_FlashMsg$, Failed_In_SW_Flash
global VectorlessTestMsg$, Failed_In_VectorlessTest
global Count_number,Failed_Pin_Test,Pin_Msg$

!+030104S
global SHO_TEST, PRES_TEST, TJ_TEST, ANA_TEST, POL_TEST
global CCHK_TEST, ANAC_TEST, PWR_TEST, REG_TEST, CPLD_TEST
global DIG_TEST, FUNCT_TEST, ANAF_TEST
global NVRAM_TEST, LED_TEST
global BSP_TEST, BSI_TEST, BSC_TEST, BSS_TEST
global SWV_TEST, SWP_TEST, SWI_TEST, SWM_TEST
global SWC_TEST, SWB_TEST, SWD_TEST, SWF_TEST
global Continue_after_shorts_failed

! IYET
global Using_IYET, Sampling, IYET_Preshorts_Attempts, IYET_Shorts_Attempts
global IYET_Analog_Tests_Attempts, IYET_VectorlessTest_Attempts

Custom_failed = boardfailed
clear failures
!+030104E
!goto AA

!@Preshorts_start= msec

PRES:  if PRES_TEST = 0 then goto PRES_END
if Using_IYET then
  call IYET (PreshortsMsg$, IYET_Preshorts_Attempts)
else
  call Pre_Shorts (Failed_In_Preshorts, Mode$ & PreshortsMsg$)
end if
!if boardfailed then pause
if boardfailed then subexit
PRES_END:

!@Preshorts_time= (msec- Preshorts_start)/1000
!@print "preshorts_time:";Preshorts_time

!@Shorts_start= msec
SHO:  if SHO_TEST = 0 then goto SHO_END
if Using_IYET then
 call IYET (ShortsMsg$, IYET_Shorts_Attempts)
else
  call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
end if
 !if boardfailed then pause
 if boardfailed then subexit
SHO_END:
!@Shorts_time= (msec- Shorts_start)/1000
!@print "shorts_time:";Shorts_time

!@Tj_start=msec
TJ:  if TJ_TEST = 0 then goto TJ_END
if Using_IYET then
  call IYET (VectorlessTestMsg$, IYET_VectorlessTest_Attempts)
else
  call VectorlessTest (Failed_In_VectorlessTest, Mode$ & VectorlessTestMsg$)
end if
 !if boardfailed then pause
 if boardfailed then subexit
TJ_END:
!@Tj_time=(msec-Tj_start)/1000
!@print "Tj_time:";Tj_time

!@Ana_start=msec
ANA:  if ANA_TEST = 0 then goto ANA_END
if Logging or not learning then
  if Using_IYET and not learning and not Sampling then
   call IYET (AnalogMsg$, IYET_Analog_Tests_Attempts)
  else
    call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
  end if
!  if boardfailed then pause
  if boardfailed then subexit
end if
ANA_END:
!@Ana_time=(msec-Ana_start)/1000
!@print "Ana_time:";Ana_time

!!+ For LED Color Detect Tests (Added by genledtest on Wed Aug 10 10:46:05 2016)
!LED:  if LED_TEST = 0 then goto LED_END
!print tab(5);Mode$;"LED color testing"
!Status = 6
!!!!! ONLY FOR FIXTURE DEBUG. COMMENT OUT THIS CALL BEFORE RELEASE. !!!!!
!call LED_FixtureElectronics_SelfTests
!!#if boardfailed then subexit
!if boardfailed then
!  Custom_failed = 1
!  clear failures
!end if

!call LED_Power_On

!call LED_Color_Detect_Tests
!#if boardfailed then subexit
!if boardfailed then
!  Custom_failed = 1
!  clear failures
!end if

!call LED_Power_Off
!LED_END:

POL:  if POL_TEST = 0 then goto POL_END
call Polarity_Check (Failed_In_Polarity_Check, Mode$ & PolarityMsg$)
if boardfailed then subexit  !030104
POL_END:

CCHK:  if CCHK_TEST = 0 then goto CCHK_END
call Connect_Check (Failed_In_ConnectCheck, Mode$ & ConnectCheckMsg$)
if boardfailed then subexit  !030104
CCHK_END:

ANAC:  if ANAC_TEST = 0 then goto ANAC_END
call Analog_Cluster_Tests (Failed_In_Analog_Cluster, Mode$ & AnalogClusterMsg$)
if boardfailed then subexit  !030104
ANAC_END:

!ANAP:  if ANAP_TEST = 0 then goto ANAP_END
call Pre_Powered_Tests (Failed_In_Analog, Mode$ & "Pre Powered ")
if boardfailed then subexit
!ANAP_END:


PWR:  if PWR_TEST = 0 then goto PWR_END
!        beep
!        print "?????????????????????????????????????????"
!        print "??  Precaution:                        ??"
!        print "??     Are all supplies configured to  ??"
!        print "??     power-up properly?              ??"
!        print "??     SKIPPED POWERED TESTS.          ??"
!        print "?????????????????????????????????????????"
!        beep
!        goto PWR_END
!     end if
!!powered
 AA:
  call Check_fixture_Stage (Failed_Pin_Test, "Checking Where Fixture")

  call Pins_Long (Failed_Pin_Test, Mode$ & "Long Probe Contact")
  if boardfailed then subexit


call Setup_Power_Supplies_pro (Failed_In_Power_Supplies, PowerMsg$)
 if boardfailed then
   report out
 end if
 if boardfailed then
   call Disconnect_Power_On_Board
   subexit
 end if


 call Program_IR3570 (Failed_In_Digital, Message$)
 if boardfailed then
   call Disconnect_Power_On_Board
   subexit
 end if


 call Program_tps53659
 if boardfailed then
   call Disconnect_Power_On_Board
   subexit
 end if


!@Ps_start=msec
call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
if boardfailed then
  report out
!  pause
end if
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if

PWR_END:
!@Ps_time=(msec-Ps_start)/1000
!@print "Ps_time:";Ps_time

call Program_34c04
 if boardfailed then
   call Disconnect_Power_On_Board
   subexit
 end if
! pause

!+030104S
REG:  if REG_TEST = 0 then goto REG_END
print tab(5);Mode$;"On Board Power Supplies"
call Regulators (Failed_In_Power_Supplies, PowerMsg$)
if boardfailed then
  report
  report "----------------------------------"
  report "Regulator(s) on board failed.     "
  report
  report "********* TEST INCOMPLETE ********"
  report "**** MUST RETEST AFTER REPAIR ****"
  report
  report "----------------------------------"
  subexit
end if
REG_END:


CPLD:  if CPLD_TEST = 0 then goto CPLD_END
print tab(5);"Programming/Verifying CPLDs"
call CPLDs (Failed_In_Functional, Mode$ & DigitalFuncMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
CPLD_END:
!+030104E


SWV:  if SWV_TEST = 0 then goto SWV_END
call ScanWorks_Scan_Path_Verify_Tests (Failed_In_SW_Testing, Mode$ & SW_ScanPathVerifyMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
SWV_END:

SWP:  if SWP_TEST = 0 then goto SWP_END
call ScanWorks_Pretest
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
SWP_END:

BSP:  if BSP_TEST = 0 then goto BSP_END
!@call BScan_Powered_Shorts_Tests (Failed_In_Shorts, Mode$ & BScanPShortsMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
BSP_END:


BSS:  if BSS_TEST = 0 then goto BSS_END
call BScan_Silicon_Nails_Tests (Failed_In_BScan_SiNails, Mode$ & BScanSiNailsMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
BSS_END:

BSI:  if BSI_TEST = 0 then goto BSI_END
 call BScan_Interconnect_Tests (Failed_In_BScan, Mode$ & BScanIntconMsg$)
if boardfailed then
   call Disconnect_Power_On_Board
  subexit
end if
BSI_END:

!@Bsc_start=msec
!!BSC:  if BSC_TEST = 0 then goto BSC_END
!!FOC21434JPE
!!BSC_END
   !call Cycle_Power_On_Board
   call BScan_Incircuit_Tests (Failed_In_BScan, Mode$ & BScanIncktMsg$)
if boardfailed then
  report out
! pause
end if
  if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
BSC_END:
!@Bsc_time=(msec-Bsc_start)/1000
!@print "Bsc_time:";Bsc_time


!@Dig_start=msec
DIG:  if DIG_TEST = 0 then goto DIG_END
!~call  Cycle_Power_On_Board
 call Digital_Tests (Failed_In_Digital, Mode$ & DigitalMsg$)
if boardfailed then
  report out
! pause
end if
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
DIG_END:
!@Dig_time=(msec-Dig_start)/1000
!@print "Dig_time:";Dig_time

!@Anaf_start=msec
ANAF:  if ANAF_TEST = 0 then goto ANAF_END
 call Analog_Functional_Tests (Failed_In_Functional, Mode$ & AnalogPoweredMsg$)
 if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if

ANAF_END:
!@Anaf_time=(msec-Anaf_start)/1000
!@print "Anaf_time:";Anaf_time

!If you:
!       * use both ScanWorks and 3070 InterconnectPlus chain tests
! AND   * comment out any 3070 interconnect tests (e.g. duplicate coverage)
! AND   * those commented tests have unnailed nodes (possible undetected shorts)
!THEN   * Move the following BScan_Incircuit_Tests routine below the ScanWorks
!               Interconnect_Tests call

!Reason: an interconnect test, which finds shorts, should be run on each chain prior to
!the BScan_Incircuit_Tests routine.  The connect tests give precise opens diagnostics,
!but board damage from undetected shorts could occur while they are being run.


SWI:  if SWI_TEST = 0 then goto SWI_END
  call ScanWorks_Interconnect_Tests (Failed_In_SW_Testing, Mode$ & SW_InterconnectMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
SWI_END:


! If you are using Boundary-Scan and you want to cycle power,
! then uncomment the following call.
! call Reset_Board


FUNCT:  if FUNCT_TEST = 0  then goto FUNCT_END
!@call Functional_Tests (Failed_In_Functional, Mode$ & DigitalFuncMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
FUNCT_END:

SWM:  if SWM_TEST = 0 then goto SWM_END
  call ScanWorks_Mem_Interconnect_Tests (Failed_In_SW_Testing, Mode$ & SW_MemInterconnectMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
SWM_END:

SWC:  if SWC_TEST = 0 then goto SWC_END
  call ScanWorks_Cluster_Tests (Failed_In_SW_Testing, Mode$ & SW_ClusterMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
SWC_END:

SWB:  if SWB_TEST = 0 then goto SWB_END
  call ScanWorks_Mem_BIST (Failed_In_SW_Testing, Mode$ & SW_MemBistMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
SWB_END:

! If you are using Boundary-Scan and you want to cycle power,
! then uncomment the following call.
! call Reset_Board

if Programming then
  if learning then subexit

  !----------------------------------------------------------------------------
  ! Only add the following powersupply setup if it is necessary to cycle power.
  ! Perhaps to get FPGAs or other ASICs to a three-state condition.
  !
  !    !flash! unpowered  ! Only if volatile logic exists upstream
  !
  !    !flash!  put any required gprelays here
  !
  !    !flash!  powered    ! if unpowered above, also use the following only if
  !                        ! digital devices aren't interferring
  !    ! call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
  !    ! if boardfailed then
  !    !    call Disconnect_Power_On_Board
  !    !    subexit
  !    ! end if
  !----------------------------------------------------------------------------
  ! Add the device name to be tested in the call to the Program_Flash
  ! subroutine. If multiple devices are installed, duplicate the call line for
  ! each device.  Pass an empty string as the Message$ parameter to supress
  ! printing messages for devices 2 through N.
  !----------------------------------------------------------------------------

  ! call Program_Flash ("", Failed_In_Flash, FlashProgMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if

SWD:  if SWD_TEST = 0 then goto SWD_END
  call ScanWorks_Device_Programming (Failed_In_SW_Programming, SW_ProgrammingMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if
SWD_END:

SWF:  if SWF_TEST = 0 then goto SWF_END
  call ScanWorks_Flash_Programming (Failed_In_SW_Flash, SW_FlashMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if
end if
SWF_END:

NVRAM:  if NVRAM_TEST = 0 then goto NVRAM_END
print tab(5);"Programming IDROM"
!call Program_IDROM_with_KGB_PCAMAP
if boardfailed then
  Custom_failed = 1
  clear failures
end if
NVRAM_END:

!@!  !2nd shorts test
!@!  unpowered|faon1.0
!@!  if not boardfailed then
!@!   clear failures
!@!   report clear
!@!  end if

!@! if Using_IYET then
!@!  call IYET (ShortsMsg$, IYET_Shorts_Attempts)
!@! else
!@!   call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
!@! end if
!@!if boardfailed then pause
  !if boardfailed then subexit

TEST_END:  !030104

Status = Passed

subend

!       Pin Test Subroutines

!##############################################################################
def fn Chek_Point_OK
! This is the subroutine for forcing the testing of pin contacts.
! If this routine is called before Test_sections (Chek_Point_Mode = Pretest),
! then the internal status will be set to Passed or Failed_Pin_Test.
! If this routine is called after test (Chek_Point_Mode = Failures), then the
! internal status is modified only if failures occur.
!
! The meaning of the function is slightly different when it is called before
! test versus after test.  If called before test, the function returns True
! if, no matter how many times it was cycled, pin test did finally pass.
! If called after test, the function returns True if pin test failed but
! passed after retry.
!
! Note: fn Pinsfailed is external to testmain.
!
global Pin_Msg$, Passed, Chek_Point_Msg$
global Retry_PinTest$, Recycle_Vacuum$, Status, True, False
global Cycle_Vacuum$, Failed_Pin_Test, Max_Times_To_Fix_Contact
global Logging, Serial$, Known_Good$, Chek_Point_Mode, Pretest, Failures

if learning then return (False)
Attempts = 0
loop
  Contact_Passed = not fn Pinsfailed (Chek_Point_Msg$)
  if not Contact_Passed then
    Status = Failed_Pin_Test
  else
    if Chek_Point_Mode = Pretest then Status = Passed
  end if
  Attempts = Attempts + 1
  exit if Contact_Passed or (Attempts > Max_Times_To_Fix_Contact)
  print Pin_Msg$
! question Retry_PinTest$, Retry
! exit if not Retry
! question Cycle_Vacuum$, Cycle
! if Cycle then
    faoff 2
!   question Recycle_Vacuum$
    faon 1.5
! Warning: Reducing the value for 'faon' from the default value of 1.5
! can potentially cause testhead damage.
    unpowered
! end if
  if Chek_Point_Mode = Pretest then
    clear failures
!   if Logging then log board start Serial$, Known_Good$
  end if
end loop


if Chek_Point_Mode = Failures then
  if Contact_Passed and Attempts > 1 then
    if Logging then
      log clear for retest
      log board end Failed_Pin_Test
    end if
    clear failures
    report clear
  end if
  return (Contact_Passed and Attempts > 1)
else
  if Logging and Chek_Point_Mode = Pretest then
    if Status = Failed_Pin_Test then
      log board start Serial$, Known_Good$
      log board end Failed_Pin_Test
    end if
  end if

  return (Contact_Passed)
end if
fnend

!       Reset_Board Subroutine

!##############################################################################
sub Reset_Board
   !---------------------------------------------------------------------------
   ! This 'pause' section is placed here to remind the test programmer
   ! that some powered tests may depend upon the TCK/TMS signals of
   ! boundary scan chains/devices being held in a stable state.
   ! When the testplan is run, the tests are properly sequenced
   ! to assure that the disabled state is set; however, board level
   ! circuitry may interfere with the persistence of the disabled state.
   ! You may need to take additional measures; for example, you may
   ! place your own pullup/down resistor in the fixture to assure a
   ! stable TMS and/or TCK, or utilize a GP relay to disable some TCK
   ! oscillator, etc.
   ! For further explanation, see the Boundary-Scan Manual for the
   ! section titled 'Maintaining Persistence of Boundary-Scan Disables'.
   !
   !---------------------------------------------------------------------------
   ! When Boundary-Scan tests are complete, you may need to produce
   ! a hard reset on the board-under-test to bring the ICs back into
   ! operational mode.  One way of doing this is to cycle power to the
   ! board using the following call:

   call Cycle_Power_On_Board ! Cycle Power to reset digital state of board
   ! call ScanWorks_Pretest    ! Configure volatile devices, if needed

   ! Power cycling is time consuming and may not be necessary.  Some boards
   ! may not need any resetting.  Others may have a digital reset node
   ! you can toggle with a digital test to reset the board.
   !
   ! When you have evaluated the needs of this board and modified this
   ! section, remove the pause and these comments.  You should take care
   ! to document the action you have taken for future reference.
   !---------------------------------------------------------------------------
subend

!       Backtrace Subroutine

!##############################################################################
sub Backtrace (Test$)
global Confirming$, Confirm_Failed$

find start node Test$     ! get first node to probe
loop
  exit if btdone
  if (external test (btnode$)) then ! perform external test
    call External_Test (BT_Pass, BT_Results)
  else
    test node btnode$   ! perform digital functional test
    BT_Pass = nodepass
    BT_Results = noderesults
    call Print_Results (BT_Pass, BT_Results)
  end if
  find next node btnode$, BT_Pass, BT_Results  ! next node to probe
  if btconfirm then      ! confirm the diagnosis
    find next node btnode$, BT_Pass, BT_Results, confirm
    print Confirming$
  end if
  if btreset then        ! restart from new failing node
    find next node btnode$, BT_Pass, BT_Results, reset
    print Confirm_Failed$ & btnode$ & """"
  end if
end loop
make diagnosis  ! report failed node information
subend

!       Sample External Test Subroutine for Backtracing

!##############################################################################
sub External_Test (BT_Pass, BT_Results)
! Sample external test
! Perform test as needed based on value of BT_Key$
! Set Pass=1 for pass or Pass=0 for fail
! Results must be -150000 for an external test
BT_Key$ = exttest$
BT_Pass = 1
BT_Results = -150000
subend

!       Decode and print backtrace node test results

!##############################################################################
sub Print_Results (BT_Pass, BT_Results)
global BT_Passed$, BT_SR_Fail$, BT_CRC_Fail$, BT_Notest$, BT_Indeter$
global BT_Interm$, BT_Incons$, BT_Open$, BT_NResults$

BT_Node$ = "node """ & btnode$ & """"
if BT_Pass then  ! node passed
  print BT_Node$; tab(23); BT_Passed$
else
  if BT_Results > 0 then  ! node failed SR test
    print BT_Node$; tab(23); BT_SR_Fail$; BT_Results
  else
    if BT_Results <= 0 and BT_Results >= -65535 then ! node failed CRC test
      call Decode_crc ( -BT_Results, BT_Crc$ )
      print BT_Node$; tab(23); BT_CRC_Fail$; BT_Crc$; """"
    else
      if BT_Results = -100000 then  ! node not tested
        print BT_Node$; tab(23); BT_Notest$
      else
        if BT_Results = -160000 then  ! node was indeterminate
          print BT_Node$; tab(23); BT_Indeter$
        else
          if BT_Results = -200005 then  ! node was intermittent
            print BT_Node$; tab(23); BT_Interm$
          else
            if BT_Results = -200006 then  ! node was inconsistent
              print BT_Node$; tab(23); BT_Incons$
            else
              if BT_Results = -200010 then  ! node has an open trace
                print BT_Node$; tab(23); BT_Open$
              else
                print BT_Node$; tab(23); BT_NResults$; BT_Results
              end if ! BT_Results = -200010
            end if ! BT_Results = -200006
          end if ! BT_Results = -200005
        end if ! BT_Results = -160000
      end if ! BT_Results = -100000
    end if ! BT_Results < 1 and BT_Results > -100000
  end if ! BT_Results > 0
end if ! BT_Pass
subend

!       Format a 16 bit crc value to an ASCII CRC

!##############################################################################
sub Decode_crc (BT_Value, BT_Crc$)
option bit 32
BT_Crc$ = "0000"
BT_Temp = binand (BT_Value, hti("0000000F"))
BT_Crc$[4;1] = chr$(fn HexChar(BT_Temp))
BT_Temp = binand (BT_Value, hti("000000F0")) / 16
BT_Crc$[3;1] = chr$(fn HexChar(BT_Temp))
BT_Temp = binand (BT_Value, hti("00000F00")) / 256
BT_Crc$[2;1] = chr$(fn HexChar(BT_Temp))
BT_Temp = binand (BT_Value, hti("0000F000")) / 4096
BT_Crc$[1;1] = chr$(fn HexChar(BT_Temp))
subend

!       Build a hex character

!##############################################################################
def fn HexChar (A)
if A >= 0 and A < 10 then
  return (A + 48)
else
  if A >= 10 and A < 16 then
    return  (A + 87)
  else
    return 63
  end if
end if
fnend

!       Data Logging Subroutines

!##############################################################################
sub Start_Logging
global Analog_Sample_Rate, QSTATS_Mode, Histo, Board$, Tests_On_This_Board
global Sampling, True, False
global Proc_Step$, Batch$, Oper$, Board_Rev$, Testplan$
global Testrev$, Known_Good$, Serial$, Version_Label$
global  Customer$, BStyle$, Site$, Line$, Deviation_Log$

Sampling = False
if learning then
  log level is all
else
  if rnd < Analog_Sample_Rate * (QSTATS_Mode = Histo) then
    !log level is analog without nhls, pins
    log level is all
    Sampling = True
  else
    !log level is indictments without nhls
    log level is all
  end if
end if
print "Log level: ";lli$;";  Report level: ";rli$;";  Board type: ";Board$
PS$ = Proc_Step$
if Tests_On_This_Board = 1 then
  log board Board$, PS$, Batch$, Oper$, Board_Rev$, Testplan$, Testrev$, "", "", Version_Label$
end if
log board start Serial$, Known_Good$
   log "{@CUST|"&Customer$&"}"
   log "{@BSTYLE|"&BStyle$&"}"
   log "{@SITE|"&Site$&"}"
   log "{@LINE|"&Line$&"}"
   log "{@MEAS|Deviations||"&Deviation_Log$&"}"
print
subend

!##############################################################################
def fn Get_Serial_Num$(Prompt$)
global Serial_Length, Bad_Serial_Image$, Default_Serial_Number$

loop
  print using """"&Prompt$&""",#"
  Ident$=""
  input "",Ident$
  if Ident$ = "" then Ident$ = Default_Serial_Number$
  exit if Ident$ = Default_Serial_Number$
  exit if (len(Ident$) = Serial_Length) or not Serial_Length
  print using Bad_Serial_Image$; len(Ident$), Serial_Length
end loop
return (Ident$)
! return (lwc$(Ident$))
fnend

!##############################################################################
!  If the Board name contains any invalid characters, stop processing.
sub Verify_Board_Names
global Stop_Msg$, Bad_Board_Name$, Board$

Found_Bad = 0
if fn IllegalChars_In_Board_Name(Board$) then
  Found_Bad = 1
  print Bad_Board_Name$  |   print "    ";Board$
end if
if Found_Bad then
  print | print Stop_Msg$
  beep
  stop
end if
subend

!##############################################################################
! Check to see if the Board name contains any invalid characters, now only
! check spaces.  Return 1 if yes, and 0 if no.
def fn IllegalChars_In_Board_Name (Board$)
global True, False

if len (Board$) > 0 and pos (Board$, " ") > 0  then
  return True
else
  return False
end if
fnend

!##############################################################################
sub Create_Log_Queue
global Log_Path$, Directory_Exists, Queue_Error_Msg$, Stop_Msg$

create dir Log_Path$, Err
Err = Err and (Err <> Directory_Exists)
if Err then
  print Queue_Error_Msg$  |   print "    ";errm$
  print | print Stop_Msg$
  beep
  stop
end if
subend

!##############################################################################
sub Setup_Logging
global Serial$, Default_Serial_Number$, Testplan$, Batch$
global Known_Good_Board$, Using_ART, Proc_Step$, Oper_Id_Prompt$
global Board$, Oper$, Known_Good_Prompt$
global Serializing

global Fixture_id$


randomize
Proc_Step$             = "ICT"
Batch$                 = datetime$ ! Set to a unique identifier so that Q-STATS II can
                                   ! calculate interboard handling and system idle times
!Testplan$              = Board$
Default_Serial_Number$ = "default_SN" & th$
Serial$                = Default_Serial_Number$
Known_Good_Board$      = ""
Oper$                  = "F"
if Using_ART then
!

loop
  print using """"&Oper_Id_Prompt$&""",#"
  input "",Oper$
  Oper$=upc$(Oper$)
  exit if (num(Oper$[1;1])<=90 and num(Oper$[1;1])>=65 and len(Oper$)=8)
  print Oper$
  print "Wrong operator ID,please SCAN again !!!"
end loop

!loop
!  print "Please Enter Fixture_Id_Prompt"
!  input "",Fixture_id$
!  Fixture_id$=upc$(Fixture_id$)
!@exit if (Fixture_id$[1;10]="TA-18275-0")
!  exit if (len(Fixture_id$)=11 and Fixture_id$[1;10]="TA-18275-0")
!  print Fixture_id$
!  print "Wrong Fixture ID,please SCAN again !!!"
!end loop

A=autofile
loop
  print "Please Enter Fixture_Id_Prompt"
  exit if A=2305
  exit if A=1058
  exit if A=2116
  exit if A=1033
  exit if A=2084
  exit if A=1154
  exit if A=2081
  print tab(1);chr$(27)&"&v7S Wrong Fixture ID,please double check fixture is right???"
end loop

if A=2305 then
   Fixture_id$= "TA-18275-01"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-01"
else
 if A=1058 then
   Fixture_id$= "TA-18275-02"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-02"
 else
  if A=2116 then
   Fixture_id$= "TA-18275-03"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-03"
else
  if A=1033 then
   Fixture_id$= "TA-18275-04"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-04"
else
  if A=2084 then
   Fixture_id$= "TA-18275-07"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-07"
else
  if A=1154 then
   Fixture_id$= "TA-18275-08"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-08"
else
  if A=2081 then
   Fixture_id$= "TA-18275-09"
   print tab(1);chr$(27)&"&v2S Fixtue_id is TA-18275-09"
      end if
     end if
    end if
   end if
  end if
 end if
end if

!Fixture_id$= "TA-17959-01"
!print tab(1);chr$(27)&"&v2S Fixtue_id is TA-17959-01"
end if
if Serializing then Known_Good_Board$ = fn Get_Serial_Num$(Known_Good_Prompt$)
subend

!       Initialization Subroutines

!##############################################################################
sub Initializations
global Logging, Using_Buffered_Reporting, Report_Printer$, Using_ART
global Serializing, Logging_Started, First_Run$, Testmain_Revision$
global Did_First_Run_Inits, QSTATS_Mode
global True, False, Off, No_Histo, Histo, Pretest, Failures
global Version_Inits_Needed, Using_Multiple_Versions
global Per_Run, Per_Board, Version_Prompting
global Using_AwareTest
! IYET
global Using_IYET

!+030104S
global Print_to_file
global Aware_fail_report
!+030104E

Testmain_Revision$="3070 05.30p 0603(full)"
True = 1
False = 0
Off = 0
No_Histo = 1
Histo = 2
Pretest = 1
Failures = 2
Per_Run = 1
Per_Board = 2
Version_Inits_Needed = False
call Set_Custom_Options
call Initialize_Board_Constants ! external to testmain
call Initialize_Constants
call Verify_Board_Names
Logging_Started = False
Logging = (QSTATS_Mode <> Off) or Using_ART
if Using_ART then Serializing = True
if Using_AwareTest then Serializing = True

! call Get_Board_Revision        ! to interactively set Board_Rev$

call Print_Startup_Message       ! prints out many variables' values
acknowledge all failures
learn capacitance off
if Using_Buffered_Reporting then
  buffered reporting on
else
  buffered reporting off
end if

!-030104S
!report is Report_Printer$
!-030104E
!+030104S
if Print_to_file then
   if Aware_fail_report then
    report is "C:\Program Files\paperless_repair\73-18275-05",window;append
    !@report is Report_Printer$
   else
   report is "C:\Program Files\paperless_repair\73-18275-05",window;append
   !@ report is Report_Printer$; echo
   end if
else
 report is "C:\Program Files\paperless_repair\73-18275-05",window;append
 !!@report is Report_Printer$
end if
!+030104E

printer is *
if Logging then
  call Setup_Logging
  call Create_Log_Queue
else
  !log level is none
  log level is all
end if
if Using_ART then
  report level is all
else
  report level is report
end if
if nrun = 1 then
  print First_Run$
  load board

!~object checking off
end if
if Using_Multiple_Versions and Version_Prompting = Per_Run then
  call Get_Version_Label
end if
if nrun = 1 or Version_Inits_Needed then
  call Do_Version_Inits
  Did_First_Run_Inits=True
end if

! IYET
if Using_IYET then call IYET_Initialize
subend

!##############################################################################
sub Print_Startup_Message
global Board$, Board_Rev$, Using_ART, QSTATS_Mode, Histo
global Analog_Sample_Rate, Chek_Point_Mode, Failures
global Report_Printer$, Using_Buffered_Reporting, Testmain_Revision$
global Serializing, Serial_Length
! IYET
global Using_IYET, IYET_Report_On

!+030104S
global Print_to_file
global Question_to_print
global Continue_after_pins_failed
global Continue_after_shorts_failed
global Multiple_versions, Version_selected
global Fab$, Bom$
!+030104E

!-030104S
!print using "@,2/"
!-030104E
!+030104S
print using "@,1/"
execute "title " & "FAB#  " & Fab$ & "  ---  " & "BOM#  " & Bom$
!+030104E

print "BOARD TYPE"
print "  Name:     ";Board$
print "  Revision: ";Board_Rev$
print "AGILENT 3070 TESTMAIN"
print "  Report Printer: ";Report_Printer$
print "  Revision:       ";Testmain_Revision$
!   Build list of options to be printed
!     O1$ is first line, O2$ is second line
O1$ =  "  Options: "
if Using_ART then O1$=O1$&" PR+"
if QSTATS_Mode then O1$=O1$&" QSTATS"
if Chek_Point_Mode then
  O1$=O1$&" Chek-Point"
  if Chek_Point_Mode = Failures then
    O1$=O1$&"-Failures"
  else
    O1$=O1$&"-Pretest"
  end if
end if
if (O1$="  Options: ") then
  O2$=O1$
else
  print O1$
  O2$= "           "
end if
if Serializing then O2$=O2$&" Serializing("&val$(Serial_Length)&")"
if learning then O2$=O2$&" LEARNING"
if Using_Buffered_Reporting then O2$=O2$&" Buffered-Reporting"
if QSTATS_Mode = Histo then
  O2$=O2$&" Histograms("&val$(Analog_Sample_Rate)&")"
end if
if not (O2$ = "           ") then print O2$
! IYET
O3$="           "
if Using_IYET then
  O3$=O3$&" Intelligent Yield Enhancement Test"
  if IYET_Report_On then O3$=O3$&"-Report"
end if
print O3$

!+030104S
print "CUSTOM RUN SELECTIONS"
if Print_to_file then
   print "  Buffer failures to file               : On"
else
   print "  Buffer failures to file               : Off"
end if
if Question_to_print then
   print "  Prompt to print failures to printer   : On"
else
   print "  Prompt to print failures to printer   : Off"
end if
if Continue_after_pins_failed then
   print "  Prompt to continue after pins failed  : On"
else
   print "  Prompt to continue after pins failed  : Off"
end if
if Continue_after_shorts_failed then
   print "  Prompt to continue after shorts failed: On"
else
   print "  Prompt to continue after shorts failed: Off"
end if

print using "2/"
!+030104E

!-030104S
!print using "3/"
!-030104E
subend

!##############################################################################
sub Get_Board_Revision
global Board_Rev$, Board_Rev_Prompt$

if Board_Rev$ = "" then
  print using """" & Board_Rev_Prompt$ & """,#"
  input "",Board_Rev$
end if
subend

!##############################################################################
sub Do_Version_Inits
global Version_Inits_Needed, Chek_Point_Mode, True, False, Off, Logging

unpowered
faoff
call Characterize
if Chek_Point_Mode <> Off then   ! preload pins into testhead memory
  Log_Level_Reset = False
  if lli$ = "all" then
    !log level is none            ! turn off digital datalogging
    log level is all
    Log_Level_Reset = True       ! for 'ignore all failures'
  end if
  ignore all failures
  Err = fn Pinsfailed ("")       ! external to testmain
  acknowledge all failures
  if Log_Level_Reset = True then log level is all  ! reset datalogging
end if
Version_Inits_Needed = False
subend

!##############################################################################
sub Get_Version_Label
global Version_Label$, Version_Prompt$, True, False
global Version_Inits_Needed

Old_Version$ = bvi$
Version_Inits_Needed = True
loop
  Version_Label$ = ""
  print using """" & Version_Prompt$ & """,#"
  input "", Version_Label$
  if Version_Label$ = "" or Version_Label$ = "*" then
    board version is *, Err
  else
    board version is Version_Label$, Err
  end if
  exit if not Err
  print errmlong$
end loop
if bvi$ = Old_Version$ then
  Version_Inits_Needed = False
end if
subend

!##############################################################################
def fn Replace_Character$(Char$)
  Val = num(Char$)
  if Val < 9 then
    String$ = "%00" & val$(Val)
  else
    if Val < 99 then
      String$ = "%0" & val$(Val)
    else
      String$ = "%" & val$(Val)
    end if
  end if
  return(String$)
fnend

def fn Replace_All_Chars$(String$, Char$)
To_Return$ = ""

String_Loop:

String_Loc = pos(String$, Char$)
if String_Loc = 0 then
  To_Return_New$ = To_Return$ & String$
else
  To_Return_New$ = To_Return$ & String$[1;String_Loc - 1] & fn Replace_Character$(Char$)
  String$ = String$[String_Loc + 1]
end if
To_Return$ = To_Return_New$
if String_Loc <> 0 then goto String_Loop
return(To_Return$)
fnend

def fn Remove_Special_Characters$(String$)
! used only with AwareTest.  Replaces all characters that cannot be
! used in an NT filename with their ASCII equivalent.

  To_Replace$ = fn Replace_All_Chars$(String$, "%")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "|")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "\")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "/")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "<")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, ">")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "*")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "?")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, ":")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, " ")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, """")
  return(To_Replace$)
fnend

!##############################################################################
sub Initialize_Constants
global PreshortsMsg$, ShortsMsg$, PowerMsg$, DigitalMsg$, AnalogMsg$
global DigitalFuncMsg$, AnalogPoweredMsg$
global Break_Detected, Mode$, Board_Not_Tested$
global True, False, InvOn$, InvOff$, First_Run$, Board_Rev_Prompt$
global Pass_Msg$, Fail_Msg$, Pass_File$, Fail_File$, Stop_Msg$, Break_Msg$
global No_Init_Warning$, Rep_Test$, Place_Board_Prompt$, Learning_Off_Msg$
global BT_Passed$, BT_SR_Fail$, BT_CRC_Fail$, BT_Notest$, BT_Indeter$
global BT_Interm$, BT_Incons$, BT_Open$, BT_NResults$
global Confirming$, Confirm_Failed$
global Failed_In_Learn, Failed_Pin_Test, Failed_In_Preshorts, Failed_In_Shorts
global Failed_In_Analog, Failed_In_Power_Supplies, Failed_In_Digital
global Failed_In_Functional, Failed_In_BScan, Passed, Failed
global Directory_Exists, Log_Path$, System$, Queue_Error_Msg$, Board$
global Break_Code, Error_Code
global But$, Serial_Prompt$, Bad_Serial_Image$, Oper_Id_Prompt$
global Known_Good_Prompt$, Serial_Nr$
global Retry_PinTest$, Cycle_Vacuum$, Recycle_Vacuum$
global Pin_Msg$, Max_Times_To_Fix_Contact
global BScanIntconMsg$, BScanIncktMsg$, Chek_Point_Msg$
global TestJetMsg$, Failed_In_TestJet
global VectorlessTestMsg$, Failed_In_VectorlessTest
global PolarityMsg$, Failed_In_Polarity_Check
global BScanPShortsMsg$, No_Version_Init_Warning$
global Version_Label$, Version_Prompt$
global ConnectCheckMsg$, Failed_In_ConnectCheck
global Failed_In_Flash, FlashProgMsg$
global Serial_Number_Directory$, Not_AXI_Tested$, Serial_Suffix$
global AnalogClusterMsg$, Failed_In_Analog_Cluster
global BScanSiNailsMsg$, Failed_In_BScan_SiNails
global SW_ScanPathVerifyMsg$, Failed_In_SW_Testing
global SW_DrVerifyMsg$, SW_IrVerifyMsg$
global SW_InterconnectMsg$, SW_MemInterconnectMsg$
global SW_ClusterMsg$, SW_MemBistMsg$
global SW_ProgrammingMsg$, Failed_In_SW_Programming
global SW_FlashMsg$, Failed_In_SW_Flash
global Bad_Board_Name$

!+030104S
global Aware_fail_report
!+030104E

Break_Detected           = False
InvOn$                   = chr$(27)&"&dB"&chr$(7)  ! chr$(7) rings bell
InvOff$                  = chr$(27)&"&d@"
Passed                   = 0
Failed                   = 1
Failed_Pin_Test          = 2
Failed_In_Learn          = 3
Failed_In_Shorts         = 4
Failed_In_Analog         = 6
Failed_In_Power_Supplies = 7
Failed_In_Digital        = 8
Failed_In_Functional     = 9
Failed_In_Preshorts      = 10
! Status codes 11, 12 reserved for use by EFS
Failed_In_BScan          = 8      ! Equate to Failed_In_Digital
Failed_In_TestJet        = 14
Failed_In_VectorlessTest = 14
Failed_In_Polarity_Check = 15
Failed_In_ConnectCheck   = 16
Failed_In_Analog_Cluster = 17
Failed_In_Flash          = 18
Failed_In_BScan_SiNails  = 19
Failed_In_SW_Testing     = 8      ! Equate to Failed_In_Digital
Failed_In_SW_Programming = 20
Failed_In_SW_Flash       = 21
Error_Code               = 80
Break_Code               = 82
Directory_Exists         = 100312
Log_Path$                = btgetenv$("AGILENT3070_ROOT")&"/qm/logdata/testerq/"&Board$&"/"
enter "uname -n |";System$              ! gets hostname (without domain)
Max_Times_To_Fix_Contact = 4            ! MUST BE >= 1
Pin_Msg$                 = "FIXTURE CONTACT PROBLEM"
O$                       = InvOn$&"Press YES"&InvOff$
O$                       = O$&" to retry Pins Test, "&InvOn$&"NO"&InvOff$
Retry_PinTest$           = O$&" to test a new board."
O$                       = InvOn$&"Press YES"&InvOff$&" to cycle vacuum, "
Cycle_Vacuum$            = O$&InvOn$&"NO"&InvOff$&" Otherwise."
O$                       = InvOn$&"Press YES"&InvOff$
Recycle_Vacuum$          = O$&" to turn vacuum on and continue testing."
Queue_Error_Msg$         = "Cannot create directory to queue up log data.  Error is:"
But$                     = "Board Under Test: "
Serial_Prompt$           = InvOn$&"Enter"&InvOff$&" Board Identifier: "
O$                       = "/,""Identifier has wrong length ("",dd,""), must be "
Bad_Serial_Image$        = O$&""",dd,""."",/"
Oper_Id_Prompt$          = InvOn$&"Enter"&InvOff$&" Operator Identifier: "
Known_Good_Prompt$       = InvOn$&"Enter"&InvOff$&" Verification Board Identifier: "
Rep_Test$                = "Repeating test of this board!"
First_Run$               = "Please stand by -- doing first-run initializations"
No_Init_Warning$         = "** WARNING: FIRST RUN INITIALIZATIONS NOT COMPLETED --"
No_Init_Warning$         = No_Init_Warning$ & " CLEARING NRUN **"
O$                       = "** WARNING: VERSION CHANGE INITIALIZATIONS NOT"
No_Version_Init_Warning$ = O$ & " COMPLETED -- CLEARING NRUN **"
Pass_File$               = btgetenv$("AGILENT3070_ROOT")&"/util/pass"
Fail_File$               = btgetenv$("AGILENT3070_ROOT")&"/util/fail"
Board_Not_Tested$        = "Board not tested."
Pass_Msg$                = "P A S S E D"
Fail_Msg$                = "F A I L E D"
Stop_Msg$                = "P R O G R A M   S T O P P E D"
Break_Msg$               = "Break/Stop detected."
Place_Board_Prompt$      = "Place board on fixture and "&InvOn$&"press START"
Board_Rev_Prompt$        = InvOn$&"Enter"&InvOff$&" Board Revision: "
Confirming$              = "Confirming diagnosis..."
Confirm_Failed$          = "Confirm failed; restarting at node """
Learning_Off_Msg$        = "Learning turned off"
if learning then
  Mode$                  = "Learning "
else
  Mode$                  = "Testing "
end if
PreshortsMsg$            = "Preshorts"
ShortsMsg$               = "Shorts"
PowerMsg$                = "Setting Up Power Supplies"
DigitalMsg$              = "Digital Incircuit"
AnalogMsg$               = "Analog Unpowered"
AnalogClusterMsg$        = "Analog Cluster"
TestJetMsg$              = "TestJet"
VectorlessTestMsg$       = "TestJet"
PolarityMsg$             = "Polarity Check"
ConnectCheckMsg$         = "Connect Check"
DigitalFuncMsg$          = "Digital Functional"
AnalogPoweredMsg$        = "Analog Powered and Mixed"
BScanIntconMsg$          = "Boundary Scan Interconnect"
BScanIncktMsg$           = "Boundary Scan Incircuit"
BScanPShortsMsg$         = "Boundary Scan Powered Shorts"
BScanSiNailsMsg$         = "Boundary Scan Silicon Nails"
FlashProgMsg$            = "Programming Flash"
SW_ScanPathVerifyMsg$    = "Scan Path Verify with ScanWorks"
SW_DrVerifyMsg$          = "DR Verify with ScanWorks"
SW_IrVerifyMsg$          = "IR Verify with ScanWorks"
SW_InterconnectMsg$      = "Interconnect with ScanWorks"
SW_MemInterconnectMsg$   = "Memory Interconnect with ScanWorks"
SW_ClusterMsg$           = "Cluster with ScanWorks"
SW_MemBistMsg$           = "Memory BIST with ScanWorks"
SW_ProgrammingMsg$       = "Programming Devices with ScanWorks"
SW_FlashMsg$             = "Programming Flash with ScanWorks"
Serial_Nr$               = "Serial #: "
BT_Passed$               = "passed"
BT_SR_Fail$              = "failed vector "
BT_CRC_Fail$             = "failed CRC is """
BT_Notest$               = "was not tested"
BT_Indeter$              = "was indeterminate"
BT_Interm$               = "was intermittent"
BT_Incons$               = "was inconsistent"
BT_Open$                 = "has an open trace"
BT_NResults$             = "noderesults= "
Chek_Point_Msg$          = "Testing Pin Contact"
Version_Label$           = ""
Version_Prompt$          = InvOn$&"Enter"&InvOff$&" Version Label: "
Serial_Number_Directory$ = "AXI_passed_boards/"
Serial_Suffix$           = ".SNF"
Not_AXI_Tested$          = "Board did not pass AXI; cannot test on Agilent 3070."
SNF_Error_Msg$           = "Error accessing serial number file. Error is: "
Bad_Board_Name$          = "Board name contains space, cannot proceed:"

!+030104S
call Custom_Init
!+030104E

subend

!##############################################################################
sub Set_Custom_Options
!  All variables likely to need to be changed are initialized here.
!  The Usage flag(s) can be set True or False to selectively enable or
!  disable the code needed for each indicated subsystem or feature.
global Using_ART, QSTATS_Mode, Testrev$
global Analog_Sample_Rate
global Serializing, Serial_Length
global Chek_Point_Mode
global Report_Printer$, True, False, Using_Buffered_Reporting
global Off, Pretest, Failures, No_Histo, Histo
global Per_Run, Per_Board, Version_Prompting
global Programming, AXI_Tested_Override
! IYET, WPR
global Using_IYET, IYET_Shorts_Attempts, IYET_Analog_Tests_Attempts
global IYET_Report_On, IYET_VectorlessTest_Attempts, IYET_Preshorts_Attempts

!+030104S
global Print_to_file
!+030104E

!   Usage flag(s)

QSTATS_Mode               = Off         ! Choose {Off, No_Histo, Histo}
!-030104S
!hek_Point_Mode           = Failures    ! Choose {Off, Pretest, Failures}
!-030104E
!+030104S
Chek_Point_Mode           = Off         ! Choose {Off, Pretest, Failures}
!+030104E
Using_ART                 = True        ! Agilent Repair Tool.
Serializing               = True       ! Will get set True if Using_ART.
!-030104S
!sing_Buffered_Reporting  = True        ! Report failures during board handling
!-030104E
!+030104S
Using_Buffered_Reporting  = True       ! Report failures during board handling
!+030104E
Programming               = False       ! Execute Flash and device programming.
Using_IYET                   = True     ! Agilent Intelligent Yield Enhancement
                                         ! Test (IYET)
IYET_Report_On               = True      !   Create & display report on breaks
IYET_Preshorts_Attempts      = 3         !   Preshorts re-test attempts
IYET_Shorts_Attempts         = 3         !   Shorts re-test attempts
IYET_Analog_Tests_Attempts   = 3         !   Analog unp. re-test attempts
IYET_VectorlessTest_Attempts = 3         !   VectorlessTest re-test attempts

!   Other parameters

!Report_Printer$           = btgetenv$("RPR"&th$) ! Final report destination
Report_Printer$           = "/dev/tty"  ! Send reports to the screen
Testrev$                  = "RevA"      ! Update this faithfully
Analog_Sample_Rate        = .10         ! Meaningful if QSTATS_Mode = Histo
Serial_Length             = 11          ! Board Id Length (0 = no checking)
Version_Prompting         = Per_Board   ! Choose {Per_Board, Per_Run}
                                        ! Used only on multiple version board
AXI_Tested_Override       = False       ! Choose {True, False}
                                        ! Used only on AwareTest board
subend

!##############################################################################
sub Cleanup_Flash
global Logging, Report_level$

if Report_level$ = "all" then report level is all
if Report_level$ = "none" then report level is none
if Report_level$ = "log" then report level is log
if Report_level$ = "report" then report level is report
if Logging then
  call Set_Log_Level
end if
subend

!       Data Logging Subroutines

!##############################################################################
sub Set_Log_Level
global Sampling

if learning then
  log level is all
else
  if Sampling then
    !log level is analog without nhls, pins
    log level is all
  else
    !log level is indictments without nhls
    log level is all
  end if
end if
subend

!##############################################################################
sub Custom_Init  !030104
global Fab$, Bom$, Board$, Board_Rev$, Board_Name$
global True,False
global Print_to_file
global Question_to_print
global Continue_after_pins_failed
global Continue_after_shorts_failed
global Print_board_msg
global Print_pass_ticket
global Report_Printer$
global SHO_TEST, PRES_TEST, TJ_TEST, ANA_TEST, POL_TEST
global CCHK_TEST, ANAC_TEST, PWR_TEST, REG_TEST, CPLD_TEST
global DIG_TEST, FUNCT_TEST, ANAF_TEST,ANAP_TEST
global NVRAM_TEST, LED_TEST
global BSP_TEST, BSI_TEST, BSC_TEST, BSS_TEST
global SWV_TEST, SWP_TEST, SWI_TEST, SWM_TEST
global SWC_TEST, SWB_TEST, SWD_TEST, SWF_TEST
global Fixture_size$
global Evaluation, Evaluation_runs
global Multiple_versions,Version_selected
global Aware_fail_report, Aware_bom_map$  ! CISCO_ICT_AWARE

!081704
global Bdg_Data_Dir$, Directory_Exists, Queue_Error_Msg$, Stop_Msg$, Eval_Rpt$
!081704

!------------------------------------------------------------------
! Set global board name and part numbers.
!------------------------------------------------------------------
Board$      = "73-18275-05"
Board_Rev$  = "A0"
Board_Name$ = "SHANNON48U-CR"
Fab$        = "28-13253-04 Rev A0"
Bom$        = "73-18275-05 Rev A0"
!------------------------------------------------------------------


!------------------------------------------------------------------
! Set test/debug options.
!------------------------------------------------------------------
Print_to_file                = False   !True=print to file.        !Debug
                                       !False=print to printer.    !Production
Question_to_print            = False   !True=prompt for printing.  !Debug
                                       !False=always print.        !Production
Continue_after_pins_failed   = False   !True=question to continue. !Debug
                                       !False=stop.                !Production
Continue_after_shorts_failed = False   !True=question to continue. !Debug
                                       !False=stop.                !Production
Print_board_msg              = True    !True=print.
                                       !False=don't print.
Print_pass_ticket            = True    !True=print.
                                       !False=don't print.
Evaluation                   = False   !True=evaluation run.
                                       !False=production run.
Evaluation_runs              = 20      !Number of test runs.
Fixture_size$                = "FULL" !Choose {FULL, BANK2}
Multiple_versions            = False   !False=single verion.
                                       !True=mutiple versions.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Must set this variable to True for ICT Aware Testing...
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Aware_fail_report            = False   !True=print pn for refdes
                                       !False=print as normal
!------------------------------------------------------------------


!------------------------------------------------------------------
! Set global board name and part numbers for multiple versions.
!------------------------------------------------------------------
if Multiple_versions then
   call Select_version
   if Version_selected = 1111 then
      Bom$        = "73-1111-xx Rev xx"
      if Aware_fail_report then
         Aware_bom_map$ = ".73-1111-xx.AWAREBOMMAP"  ! CISCO_ICT_AWARE
      end if
   end if
   if Version_selected = 2222 then
      Bom$        = "73-2222-xx Rev xx"
      if Aware_fail_report then
         Aware_bom_map$ = ".73-2222-xx.AWAREBOMMAP"  ! CISCO_ICT_AWARE
      end if
   end if
end if
!------------------------------------------------------------------


!------------------------------------------------------------------
! Set report to printer or file.
!------------------------------------------------------------------
!if Evaluation then Print_to_file = True
if Evaluation then
   Print_to_file                = True
   Question_to_print            = False
   Continue_after_pins_failed   = False
   Continue_after_shorts_failed = False

!081704
   Print_board_msg              = False
   Bdg_Data_Dir$ = "bdg_data"
   create dir Bdg_Data_Dir$, Err
   Err = Err and (Err <> Directory_Exists)
   if Err then
      print Queue_Error_Msg$  |   print "    ";errm$
      print | print Stop_Msg$
      beep
      stop
   end if
   Eval_Rpt$ = Bdg_Data_Dir$ & "/stability.rpt"
!081704
end if

if Print_to_file then
   Report_Printer$           = "debug/report" ! Final report destination.
else
!#!Report_Printer$           = "/dev/rpr"&th$ ! Final report destination.
!082905 - For PC Compatibility.
   Report_Printer$           = btgetenv$("RPR"&th$) ! Final report destination
end if
!------------------------------------------------------------------


!------------------------------------------------------------------
! For Debug - 0 for notest (branch around) and 1 for test.
!------------------------------------------------------------------
SHO_TEST    = 1  !Shorts
PRES_TEST   = 1  !Pre_Shorts
TJ_TEST     = 1  !TestJet
ANA_TEST    = 1  !Analog_Tests
ANAP_TEST   = 1  !Pre_Powered_Analog_Tests
POL_TEST    = 0  !Polarity_Check
CCHK_TEST   = 0  !Connect_Check
ANAC_TEST   = 0  !Analog_Cluster_Tests
LED_TEST    = 0  !Led_Tests
BSP_TEST    = 0  !BScan_Powered_Shorts_Tests
BSI_TEST    = 1  !BScan_Interconnect_Tests
BSC_TEST    = 1  !BScan_Incircuit_Tests
BSS_TEST    = 1  !BScan_Silicon_Nails_Tests
SWV_TEST    = 0  !ScanWorks_Scan_Path_Verify_Tests
SWP_TEST    = 0  !ScanWorks_Pretest
SWI_TEST    = 0  !ScanWorks_Interconnect_Tests
SWM_TEST    = 0  !ScanWorks_Mem_Interconnect_Tests
SWC_TEST    = 0  !ScanWorks_Cluster_Tests
SWB_TEST    = 0  !ScanWorks_Mem_BIST
SWD_TEST    = 0  !ScanWorks_Device_Programming
SWF_TEST    = 0  !ScanWorks_Flash_Programming
PWR_TEST    = 1  !Setup_Power_Supplies
REG_TEST    = 0  !Regulators
CPLD_TEST   = 0  !CPLDs
DIG_TEST    = 1  !Digital_Tests
FUNCT_TEST  = 0  !Functional_Tests  //U105 EEporm programming.
ANAF_TEST   = 1  !Analog_Functional_Tests
NVRAM_TEST  = 0  !Cookie_Tests
!------------------------------------------------------------------

subend


sub Print_board_testing_msg
global Fab$, Bom$, Board$, Board_Rev$, Board_Name$ ,Serial$

!#!Color          a/x    b/y   c/z
!#!----------     ---    ---   ---
!#!Black           0      0     0
!#!Blue            0      0     1
!#!Green           0      1     0
!#!Cyan            0      1     1
!#!Red             1      0     0
!#!Magenta         1      0     1
!#!Yellow          1      1     0
!#!White           1      1     1
!#!
!#!a,b,c: foreground
!#!x,y,z: background
!#!#I: pen number (0-7); try NOT to use pen #0
!#
!#!print chr$(27)&"&v1a1b1c1x0y1z7I"
!#!print chr$(27)&"&v1a1b1c0x0y1z7I"
!#!print chr$(27)&"&v1a1b1c.7x0y.4z7I"
!#
!#PEN_6:  !# blue on yellow
!#print chr$(27)&"&v0a0b1c1x1y0z6I"
!#
!#PEN_7:
!#print chr$(27)&"&v1a1b1c.9x0y.5z7I"
!#print tab(5);chr$(27)&"&v7S"&BoardMsg$


print chr$(27)&"&v0m1a1b1c0x0.6y0.6z5I"
print chr$(27)&"&v0m1a0b0c0x0.6y0.6z6I"
print tab(5);chr$(27)&"&v6S                                                   "
print tab(5);chr$(27)&"&v6S             C i s c o   S y s t e m s             "
print tab(5);chr$(27)&"&v5S               |                   |               "
print tab(5);chr$(27)&"&v5S             .|||.               .|||.             "
print tab(5);chr$(27)&"&v5S             |||||               |||||             "
print tab(5);chr$(27)&"&v5S           .|||||||.           .|||||||.           "
print tab(5);chr$(27)&"&v5S           |||||||||           |||||||||           "
print tab(5);chr$(27)&"&v5S         .|||||||||||.       .|||||||||||.         "
print tab(5);chr$(27)&"&v5S   ....:|||||||||||||||:...:|||||||||||||||:....   "
print tab(5);chr$(27)&"&v5S                                                   "
print tab(5);chr$(27)&"&v7S  ------------------------------------------------ "
print tab(5);chr$(27)&"&v7S                 TESTING  SHANNON48U-CR            "
print tab(5);chr$(27)&"&v7S  BOARD: "&Board$&"    *   BOARD REV.: "&Board_Rev$&"         "
print tab(5);chr$(27)&"&v7S  ------------------------------------------------ "
print"                                                                        "
print tab(5);chr$(27)&"&v2SSERIAL NO.: "&chr$(27)&"&v1S"&Serial$[1;11]

subend


sub Msgtest(This_test$)
    print tab(8);"Testing ";This_test$
    test This_test$
subend

!

sub Print_all_supplies
global Fixture_size$

 Supply_form: image 6d, 6d.3d, 6d.3d

 if Fixture_size$ = "BANK2" then
   print
   print "ALL SUPPLIES:"
   print "------------ "
   for I = 1 to 8|rps I,VIN,AIN|print using Supply_form; I, VIN, AIN|next I
   print
 end if

 if Fixture_size$ = "FULL" then
   print
   print "ALL SUPPLIES:"
   print "------------ "
   for I = 1 to 16|rps I,VIN,AIN|print using Supply_form; I, VIN, AIN|next I
   print
 end if
subend


sub Operator_debug
!   operator "OpDebug"
!      !
!      ! Softkey prompt strings
!      !
!
!      for I = 1 to 8
!         softkey I, "t", "", ""
!      next I
!
!      softkey 1,"r", "start","run"
!      softkey 2,"r", "probe   mod","digital probe"
!      softkey 3,"r", "find    pins","find pins"
!      softkey 4,"r", "graphics","board graphics"
!      softkey 5,"r", "faon","faon"
!      softkey 6,"r", "faoff","faoff"
!      softkey 7,"r", "stop","stop"
!      softkey 8,"r", "TestJet","verify testjet"
!
!     Prompt_First_Level$  = "  Press Desired Softkey Or Touch Pad:"&chr$(27)&"A"
!   Op_Debug:
!     print Prompt_First_Level$ | input User_Key$
!   !print User_Key$
!   if User_Key$ = "board graphics" then
!   if User_Key$ = "board graphics" then
!       board graphics,ERROR
!        if ERROR then board graphics end
!       goto Op_Debug
!   end if
!   if User_Key$ = "faoff" then
!       faoff
!       goto Op_Debug
!   end if
!   if User_Key$ = "faon" then
!       faon
!       goto Op_Debug
!   end if
!   if User_Key$ = "find pins" then
!      question "Do you want vacuum?",Vac
!       if Vac then faon
!       find pins
!       faoff
!       goto Op_Debug
!   end if
!   if User_Key$ = "digital probe" then
!       input "What device do you want to probe?",Device$
!       faon
!       unpowered
!       probe Device$,Err
!       faoff
!       goto Op_Debug
!   end if
!   if User_Key$ = "verify testjet" then
!       print "vacuum may need to be on to have the transfer pins make contact"
!       print "in some fixtures!"
!       question "Do you want vacuum?",Vac
!        if Vac then faon
!       question "Do you want to test the mux card?",Mux
!        if Mux then verify all mux cards
!       input "What TestJet pad do you want to test (type all for all)",TJet$
!       if upc$(TJet$) = "ALL" then
!         verify all testjet probes
!       else
!         verify testjet probes lwc$(TJet$)
!       end if
!       question "Press yes to continue",Mux
!       if Vac then faoff
!       operator "OpDebug"
!       goto Op_Debug
!   end if
!   if User_Key$ = "123321" then  program monitor
!      for I = 1 to 8
!         softkey I, "t", "", ""
!      next I
!   !operator "TM_Standard"
!   softkeys clear   !# Resets redefined softkeys
!   operator "standard"  !! restore standard softkeys
subend


sub Select_version
global Version_selected

print using "@"
print
print

beep
Ask_oper: Version_selected = 0
beep

operator "BOARD_NAME"  ! Must match in .hp3070 file.

!#===== Append following lines to .hp3070 file ========================#
!
!BOARD_NAME.Boxes:         2
!BOARD_NAME.X:             25
!BOARD_NAME.Y:             3
!BOARD_NAME.Columns:       2
!
!BOARD_NAME.Label1:        73-1111-xx Rev xx
!BOARD_NAME.Label2:        73-2222-xx Rev xx
!
!BOARD_NAME.Command1:      1111
!BOARD_NAME.Command2:      2222
!
!#===== Append above lines to .hp3070 file ========================#

   print
   input ">>>>> Click on Softkeys to select Board Version <<<<<", Version_selected
operator off

if Version_selected = 0  then goto Ask_oper

operator "standard"   !Restore the standard Softkey

subend


!Copy voltage regulator tests here, if applicable.
sub Regulators (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code

subend


!Copy PLD tests here, if applicable.
sub CPLDs (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code

subend


def fn Validate_SN (SN$)
   print
   print "All Uppercase = "; SN$
   print

   if len(SN$) = 11 or len(SN$) = 20 then  !Newer products and CAT6K
      !Format LLLYYWWWSSSS (3.4 - Cisco Doc. 701806-0000 Rev E0)
!     LLL  = 1  !Location (base 34, alpha, excluding I and O)
      LLL  = 1  !Location (base 36, alpha/numeric)  !052907
      YYWW = 1  !Year, Workweek (base 10, numeric)
!     SSSS = 1  !Sequential serial ID (base 34, alpha/numeric, excluding I and O)
      SSSS = 1  !Sequential serial ID (base 36, alpha/numeric)  !052907
      for I = 1 to 3
!        if not fn Exclusive_Alpha(SN$[I;1]) then
         if not fn Alpha_Numeric(SN$[I;1]) then  !052907
            print "Illegal character at location"; I; "("; SN$[I;1]; ")"
            LLL = 0
         end if
      next I

      for I = 4 to 7
         if not fn Numeric(SN$[I;1]) then
            print "Illegal character at location"; I; "("; SN$[I;1]; ")"
            YYWW = 0
         end if
      next I

      for I = 8 to 11
!        if not fn Exclusive_Alpha_Numeric(SN$[I;1]) then
         if not fn Alpha_Numeric(SN$[I;1]) then  !052907
            print "Illegal character at location"; I; "("; SN$[I;1]; ")"
            SSSS = 0
         end if
      next I

      if len(SN$) = 20 then  !CAT6K Only
         for I = 12 to 20
            if SN$[I;1] <> "\" then
               print "Illegal character at location"; I; "("; SN$[I;1]; ")"
               SSSS = 0
            end if
         next I
      end if

      return binand(binand(LLL, YYWW), SSSS)
   else
      if len(SN$) = 8 then  !Older products
         SSSSSSSS = 1
         for I = 1 to 8
!           if not fn Exclusive_Alpha_Numeric(SN$[I;1]) then
            if not fn Alpha_Numeric(SN$[I;1]) then  !052907
               print "Illegal character at location"; I; "("; SN$[I;1]; ")"
               SSSSSSSS = 0
            end if
         next I

         return SSSSSSSS
      else
         print "Illegal serial number length"; len(SN$)
         return 0
      end if
   end if
fnend

def fn Alpha_Numeric (Char$)  !Base 36, alpha/numeric
   if (num(Char$) < num("0") or (num(Char$) > num("9") and num(Char$) < num("A")) or num(Char$) > num("Z")) then
      return 0
   else
      return 1
   end if
fnend

def fn Alpha (Char$)  !Base 26, alpha
   if (num(Char$) < num("A") or num(Char$) > num("Z")) then
      return 0
   else
      return 1
   end if
fnend

def fn Exclusive_Alpha_Numeric (Char$)  !Base 34, alpha/numeric, excluding I and O
   if (num(Char$) < num("0") or (num(Char$) > num("9") and num(Char$) < num("A")) or num(Char$) > num("Z") or num(Char$) = num("I") or num(Char$) = num("O")) then
      return 0
   else
      return 1
   end if
fnend

def fn Exclusive_Alpha (Char$)  !Base 24, alpha, excluding I and O
   if (num(Char$) < num("A") or num(Char$) > num("Z") or num(Char$) = num("I") or num(Char$) = num("O")) then
      return 0
   else
      return 1
   end if
fnend

def fn Numeric (Char$)  !Base 10, numeric
   if (num(Char$) < num("0") or num(Char$) > num("9")) then
      return 0
   else
      return 1
   end if
fnend

! This custom subroutine is to check for board presence prior to testing.
sub Check_BD_Present  !081604
   print tab(5); "Checking for board presence..."
   Check_again:
      powered ,Error
      if Error=800096 then
         print "Board-Under-Test is not present!!!"
         print "Please load a board and close the lid."
         BACK: question "Press Yes to continue",Stat
            if Stat=0 then
               goto BACK
            else
               goto Check_again
            end if
      end if
      unpowered
subend

!081704
def fn Test_Status$(BFailed)

   if BFailed = 0 then
      return "PASSED"
   else
      return "FAILED"
   end if
fnend
!081704

!       IYET Subroutines

!##############################################################################
sub IYET_Initialize

global IYET_Path$, IYET_Failure_File$, IYET_Retest_Log_File$
global O$, InvOn$, InvOff$
global IYET_Vacuum_Off_Delay, IYET_Vacuum_On_Delay
global IYET_Report_On, IYET_Max_Report_Count, IYET_File_Timeout
global IYET_Err_Msg$, IYET_NoRT_Msg$
global IYET_Test_Msg$, IYET_Max_Msg$, IYET_Fail_Msg$
global IYET_Rpt1_Msg$, IYET_Rpt2_Msg$, IYET_Rpt3_Msg$
global Chek_Point_Mode, Max_Times_To_Fix_Contact, Failures, True, False

! Initialize paths and files
IYET_Path$                = "D:\clyde\iyet\73-18275-05\"
IYET_Retest_Log_File$     = IYET_Path$&"retest"&datetime$[1;6]&".txt"
IYET_Failure_File$        = IYET_Path$&"failure.txt"

! Initialize variables
IYET_Vacuum_Off_Delay     = 2.5
IYET_Vacuum_On_Delay      = 1.5
IYET_Max_Report_Count     = 10
IYET_File_Timeout         = 5

! Initialize message strings
IYET_Err_Msg$  = "Error with file: "
IYET_NoRT_Msg$ = "No re-tests found or missing file: "
IYET_Test_Msg$ = "Re-testing "
IYET_Max_Msg$  = "Maximum number of attempts for IYET must be >= 1."
IYET_Fail_Msg$ = " failed, releasing board..."

! Initialize report strings
IYET_Rpt1_Msg$ = "IYET Unstable Test Report - from file: "
IYET_Rpt2_Msg$ = "Unstable Test"
IYET_Rpt3_Msg$ = "# Re-tests"

! When pins test is "Failures", disable redundant re-contacts
if Chek_Point_Mode = Failures then Max_Times_To_Fix_Contact = 1

! Create IYET directory
create dir IYET_Path$, Error
if (Error <> 100312) and (Error <> 0) then
   print IYET_Err_Msg$ & IYET_Path$
   print errmlong$(Error)
   beep
   stop
end if

! Generate and print re-test report
if (Error = 100312) and IYET_Report_On then
   print using "@"
   print IYET_Rpt1_Msg$ & IYET_Retest_Log_File$
   print
   call IYET_Create_Report
   print
   O$ = InvOn$&"Press YES"&InvOff$
   Prompt$ = O$&" to continue testing with IYET."
   question Prompt$, Continue
   if not Continue then stop
   print using "@"
end if
subend

!##############################################################################
sub IYET_Create_Report
! Collect all failing devices from log file and create retest report

global IYET_Retest_Log_File$
global IYET_Retest_Failing_Devices$(*), IYET_Top_Retests$(*)
global IYET_Max_Report_Count, IYET_File_Timeout
global IYET_NoRT_Msg$, IYET_Err_Msg$
global IYET_Rpt1_Msg$, IYET_Rpt2_Msg$, IYET_Rpt3_Msg$

! Open retest log file and get failing devices
assign @Retest_Log, Error to IYET_Retest_Log_File$;read
if Error then
   print IYET_NoRT_Msg$ & IYET_Retest_Log_File$
   print
   subexit
end if

! Read all failing devices until end of file or until IYET_File_Timeout.
Start_Time = msec
I = 0
loop
   Input$ = ""
   enter @Retest_Log,,Error;Input$
   if (Error <> 0) and (Error <> 101007) then
      print IYET_Err_Msg$ & IYET_Retest_Log_File$
      print errmlong$(Error)
      beep
      stop
   end if

   ! Look for shorts, vectorless test failures
   if pos(Input$," Report for """) then
      End_Input = pos(Input$,""".")
      Begin_Input = pos(Input$,"""") + 1
      Temp_device$ = Input$[Begin_Input;End_Input - Begin_Input]
      IYET_Retest_Failing_Devices$(I) = Temp_device$
      I = I + 1
   end if

   ! Look for analog failures
   if pos(Input$,"HAS FAILED") then
      IYET_Retest_Failing_Devices$(I) = Input$[1;pos(Input$,"HAS FAILED")-1]
      I = I + 1
   end if

   exit if Error = 101007

   if (msec - Start_Time)/1000 > IYET_File_Timeout then
      print IYET_Err_Msg$ & IYET_Retest_Log_File$
      beep
      stop
   end if
end loop

assign @Retest_Log to *
Device_Total = I-1

! Count failures and remove duplicates
K = 0
for I = 0 to Device_Total
   if IYET_Retest_Failing_Devices$(I) <> "" then
      Temp$ =  IYET_Retest_Failing_Devices$(I)
      Temp_Retests = 1
      for J = I + 1 to Device_Total
         if IYET_Retest_Failing_Devices$(J) <> "" then
            if Temp$ = IYET_Retest_Failing_Devices$(J) then
               Temp_Retests = Temp_Retests + 1
               IYET_Retest_Failing_Devices$(J) = ""
            end if
         end if
      next J
      IYET_Top_Retests$(K,1) = Temp$
      IYET_Top_Retests$(K,2) = val$(Temp_Retests)
      K = K + 1
   end if
next I
Top_Retest_Total = K-1

! Sort ascending
for I = 0 to Top_Retest_Total
   for J = Top_Retest_Total to 1 step -1
      if val(IYET_Top_Retests$(J,2)) > val(IYET_Top_Retests$(J-1,2)) then
         Temp$ = IYET_Top_Retests$(J-1,1)
         Temp_Retests = val(IYET_Top_Retests$(J-1,2))

         IYET_Top_Retests$(J-1,1) = IYET_Top_Retests$(J,1)
         IYET_Top_Retests$(J-1,2) = IYET_Top_Retests$(J,2)

         IYET_Top_Retests$(J,1) = Temp$
         IYET_Top_Retests$(J,2) = val$(Temp_Retests)
      end if
   next J
next I

! Print
IYET_Max_Report_Count = IYET_Max_Report_Count - 1
if Top_Retest_Total <= IYET_Max_Report_Count then
   IYET_Max_Report_Count = Top_Retest_Total
end if

print IYET_Rpt2_Msg$;tab (50);IYET_Rpt3_Msg$

for I = 0 to IYET_Max_Report_Count
   print IYET_Top_Retests$(I,1);tab (55);IYET_Top_Retests$(I,2)
next I
subend

!##############################################################################
sub IYET_Vacuum_Off
! Edit this subroutine to match your vacuum actuation commands. Note that the
! delay for vacuum off is completed in the "IYET_Vacuum_On" subroutine.

global IYET_Start_Vacuum_Off

IYET_Start_Vacuum_Off = msec
faoff 2
subend

!##############################################################################
sub IYET_Vacuum_On(Prompt$)
! Edit this subroutine to match your vacuum actuation commands. Do not
! comment the line:
!
!  question Prompt$,Continue | if not Continue then stop
!
! unless your fixture is approved for actuation without operator
! intervention.

global IYET_Start_Vacuum_Off, IYET_Vacuum_Off_Delay, IYET_Vacuum_On_Delay

!question Prompt$,Continue | if not Continue then stop   !!ES

! Wait for vacuum to release
loop
   exit if (msec - IYET_Start_Vacuum_Off)/1000 > IYET_Vacuum_Off_Delay
end loop

faon IYET_Vacuum_On_Delay
subend

!##############################################################################
sub IYET_Get_Failed_Tests (IYET_Abort)   !IYET
! Collect all failing tests from failure file.
! To save time, this is called between the vacuum off and vacuum on.

global IYET_Failing_Tests$(*), IYET_Test_Total, IYET_File_Timeout
global IYET_Failure_File$, IYET_Retest_Log_File$, IYET_Err_Msg$
global Report_Printer$, Serial$, True, False

! Save failure ticket to retry log file
!F report is IYET_Retest_Log_File$,,Error;append

!F if Error then
!F    print IYET_Err_Msg$ & IYET_Retest_Log_File$
!F    print errmlong$(Error)
!F   beep
!F   stop
!F end if

report "Board #:";bni
report "Version:";bvi$
report "S/N:"&Serial$
report out  IYET_Retest_Log_File$,Error;append  !F
report out  "mylog.txt",Err;append!####add for beacon####

if Error then                                    !F move here
  print IYET_Err_Msg$ & IYET_Retest_Log_File$
  print errmlong$(Error)
  beep
  stop
end if


! Save failure ticket to temporary file
!F report is IYET_Failure_File$,,Err
!F if Error then
!F   print IYET_Err_Msg$ & IYET_Failure_File$
!F   print errmlong$(Error)
!F   beep
!F   stop
!Fend if

report out IYET_Failure_File$,Error;over  !F

 if Error then                                  !F move here
   print IYET_Err_Msg$ & IYET_Failure_File$
   print errmlong$(Error)
   beep
   stop
end if


! Restore original report printer
!F report is Report_Printer$      !F needn't

! Open failure ticket and get failing tests
assign @Ticket, Error to IYET_Failure_File$;read
if Error then
   print IYET_Err_Msg$ & IYET_Failure_File$
   print errmlong$(Error)
   beep
   stop
end if
!##############################################################################
! Read all failing tests until end of file or until IYET_File_Timeout.
Start_Time = msec
I = 0
IYET_Abort = False
loop
   Input$ = ""
   enter @Ticket,,Error;Input$
   if (Error <> 0) and (Error <> 101007) then
      print IYET_Err_Msg$ & IYET_Failure_File$
      print errmlong$(Error)
      beep
      stop
   end if

   ! Look for shorts, vectorless test failures
   if pos(Input$," Report for """) then
      End_Input = pos(Input$,""".")
      Begin_Input = pos(Input$,"""") + 1
      IYET_Failing_Tests$(I) = Input$[Begin_Input;End_Input - Begin_Input]
      I = I + 1
   end if

   ! Look for analog test failures
   if pos(Input$,"HAS FAILED") then
      IYET_Failing_Tests$(I) = Input$[1;pos(Input$,"HAS FAILED")-1]
      I = I + 1
   end if

   ! Look for compensation failures and set abort flag
   if pos(Input$,"Compensation capacitance has not been") then
      IYET_Abort = True
   end if

   exit if IYET_Abort

   exit if Error = 101007

   if (msec - Start_Time)/1000 > IYET_File_Timeout then
      print IYET_Err_Msg$ & IYET_Failure_File$
      beep
      stop
   end if
end loop

assign @Ticket to *
IYET_Test_Total = I - 1

! Abort if no tests are found
if IYET_Test_Total < 0 then IYET_Abort = True

! Clear report buffer and failures unless aborted
if not IYET_Abort then
   report clear
   clear failures
end if
subend

!##############################################################################
sub IYET_Retest_Failed_Tests
global IYET_Failing_Tests$(*), IYET_Test_Total, IYET_Test_Msg$

for I = 0 to IYET_Test_Total
  test lwc$(IYET_Failing_Tests$(I))
  A = dutfailed
  print tab(11);chr$(27)&"&v3S ",IYET_Test_Msg$,lwc$(IYET_Failing_Tests$(I)), A
next I
subend

!##############################################################################
sub IYET (TestType$, Maximum_Number_Attempts)
global Failed_In_Preshorts, PreshortsMsg$, Failed_In_Shorts, ShortsMsg$
global Failed_In_Analog, AnalogMsg$
global Failed_In_VectorlessTest, VectorlessTestMsg$
global Using_Buffered_Reporting, Logging, True, False, Mode$
global IYET_Fail_Msg$, IYET_Max_Msg$, Recycle_Vacuum$
global Count_number

! Check that maximum number of attempts is OK.
if Maximum_Number_Attempts < 1 then
   print IYET_Max_Msg$
   beep
   stop
end if
Retests_Remaining = dround(Maximum_Number_Attempts,1)

! Force log level, will be restored by Cleanup_Flash
if Logging then
  !log level is none
  log level is all
end if

! Force buffered reporting, save flag to restore at end
if not Using_Buffered_Reporting then
   buffered reporting on
   Not_Using_Buffered_Reporting = True
end if

! Call the test subroutine for the first time...
if TestType$ = PreshortsMsg$ then
   call Pre_Shorts (Failed_In_Preshorts, Mode$ & PreshortsMsg$)
end if

if TestType$ = ShortsMsg$ then
   call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
end if

if TestType$ = AnalogMsg$ then
  call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
end if

if TestType$ = VectorlessTestMsg$ then
  call VectorlessTest (Failed_In_VectorlessTest, Mode$ & VectorlessTestMsg$)
end if

Retests_Remaining = Retests_Remaining - 1

loop

   ! Exit if attempt is successful
   exit if (not boardfailed)

   ! Exit if done with re-tests
   exit if (Retests_Remaining = 0)

   ! Process failures during vacuum cycle time
   print tab(8);TestType$ & IYET_Fail_Msg$
     Count_number = Count_number + 1
   call IYET_Vacuum_Off
   call IYET_Get_Failed_Tests (IYET_Abort)
   call IYET_Vacuum_On(Recycle_Vacuum$)

   ! Exit if aborted
   exit if IYET_Abort

   ! For last time through the loop, restore logging and reporting
   if Retests_Remaining = 1 then call Cleanup_Flash

   ! Re-test
   call IYET_Retest_Failed_Tests
   Retests_Remaining = Retests_Remaining - 1

end loop

! Now some clean up. Could be redundant.

! Restore Log & Report level
call Cleanup_Flash

! Restore 'unbuffered' reporting, after dumping report buffer
if Not_Using_Buffered_Reporting then
   if boardfailed then report out
   buffered reporting off
end if
subend

sub Show_FPY
global FPY$, True, False, Using_Buffered_Reporting, Serial$, System$
dim FPY_SN$(299,1), FPY_Time$(299)

for I = 0 to 299
  FPY_SN$(I,0)= ""
  FPY_SN$(I,1)= ""
  FPY_Time$(I)= ""
next I

I = 0
assign @Rx ,Error1 to FPY$ ;read

loop
  enter @Rx ,,Error2 ;LineIn$
  exit if Error2 = 101007 !"END OF FILE"
  FPY_Time$(I)=LineIn$[1;12]
  FPY_SN$(I,0)=LineIn$[21;11]
  FPY_SN$(I,1)=LineIn$[33;6]
  I = I + 1
end loop

assign @Rx to *

Pass = 0
Fail = 0
NDF = 0

I = 0
loop
  exit if FPY_SN$(I,0) = ""
  !'This to find duplicate s/n
  Dup = False
  K = 1
  loop
    exit if I - K < 0
    if FPY_SN$(I, 0) = FPY_SN$(I - K, 0) then Dup = True
    K = K + 1
  end loop
  if Dup = False then
    if FPY_SN$(I, 1) = "PASSED" then Pass = Pass + 1  !count pass
  end if

  !' This to calculate NDF
  K = 1
  Found = False
  loop
    exit if Dup = True
    exit if FPY_SN$(I, 1) <> "FAILED"
    exit if FPY_SN$(I+K, 0) = ""
    exit if Found = True
    if FPY_SN$(I, 0) = FPY_SN$(I+K, 0) and FPY_SN$(I+K, 1) = "PASSED" then
      Time1 = val(FPY_Time$(I)[7;2])*60+ val(FPY_Time$(I)[9;2])
      Time2 = val(FPY_Time$(I+K)[7;2])*60+ val(FPY_Time$(I+K)[9;2])
      if Time2-Time1 < 30 then
        NDF = NDF + 1
        create dir "FPY/" & FPY_Time$(I)[1;6] & "/NDF", Error
        if (Error <> 100312) and (Error <> 0) then
          print "Cannot create directory for NDF failure log"
          print errmlong$(Error)
        else
          Filename$=System$ & "_" & FPY_Time$(I) & "_" & FPY_SN$(I, 0) & ".txt"
          File$ = "FPY/" & FPY_Time$(I)[1;6] & "/" & Filename$
          copy File$ over "FPY/" & FPY_Time$(I)[1;6] & "/NDF/" & Filename$
        end if
      else
        Fail = Fail + 1
      end if
      Found = True
    end if
    K = K + 1
  end loop
  if Found = False and Dup = False and FPY_SN$(I, 1) = "FAILED" then
    Fail = Fail + 1
  end if
  I = I+1
end loop

  print "Board pass = "; Pass+NDF; " boards"
  print "Board fail = "; Fail; " boards"
  print "Board NDF  = "; NDF; " boards"
  print "Today FPY  = "; dround(Pass*100/(Pass+Fail+NDF),4); "%"
  print "Today NDF  = "; dround(NDF*100/(Pass+Fail+NDF),4); "%"

subend

sub Get_Version
   !Get operator to scan  board assembly and version that is to be tested.
   !Enter the ISO information for each version here. This will be printed
   !by sub Print_Heading just above the sub Test_Sections messages.
   !Include any optional information, variables, etc. as desired.
   global Board$, Board_Rev$, Line$
   global Option, Selection, Assembly$, Scan_Count, Dev, Devia$
   global Bstyle$, Deviation$(*), Deviation_Log$, Num_Dev, Dev_Count
   global Assy_73$, Assy_73_Rev$, Assy_800$, Assy_800_Rev$
   global Option_short, Option_Elpd ,Option_D095428

   InvOn$  = chr$(27)&"&dB"&chr$(7)  ! chr$(7) rings bell
   InvOff$ = chr$(27)&"&d@"

   Choose_Board_Version:
 ! print using "@"

   loop

!<***************************************************************************>
!<--------------------------------------------------------------------------->
!<----- ALL VARIABLES & OPTIONS ADDED MUST BE SET TO 0 HERE ----------------->
!<--------------------------------------------------------------------------->
!<***************************************************************************>

   Assembly$      = ""   !clear variables if program loops
   Board$         = ""
   Board_Rev$     = ""
   Deviation_Log$ = ""
   Num_Dev        = 0
   Option_short   = 0
   Option_Elpd    = 0
   Option_D095428 = 0


   for D = 1 to 256
     Deviation$(D) = ""
   next D

!p question "ARE THERE ANY DEVIATION LABELS ?", Dev !
    Dev = 0

   if Dev >= 1 then
     input "ENTER THE NUMBER OF DEVIATIONS APPLIED TO THIS BOARD  ", Num_Dev
     input "Enter Deviation Number from Label(s) ", Deviation$(1)
            Deviation$(1) = upc$(Deviation$(1))
            Devia$ = Deviation$(1)

     if Num_Dev > 1 then
        for Count = 2 to Num_Dev
          input "NEXT Deviation Number", Deviation$(Count)
          Deviation$(Count) = upc$(Deviation$(Count))
        next Count
     end if

   !***************************************************************************
   !!THE FOLLOWING IS AN ERROR TRAP TO PREVENT SCANNING DUPLICATE DEVIATIONS
   !!IF MORE THAN 6 DEVIATIONS ARE USED A NEW SECTION MUST BE CREATED!!!!!!!
   !***************************************************************************

     if Num_Dev = 6 then
       if Deviation$(1) = Deviation$(2) or Deviation$(1) = Deviation$(3) or Deviation$(1) = Deviation$(4) or Deviation$(1) = Deviation$(5) or Deviation$(1) = Deviation$(6) or Deviation$(2) = Deviation$(3) or Deviation$(2) = Deviation$(4) or Deviation$(2) = Deviation$(5) or Deviation$(2) = Deviation$(6) or  Deviation$(3) = Deviation$(4) or Deviation$(3) = Deviation$(5) or Deviation$(3) = Deviation$(6) or Deviation$(4) = Deviation$(5) or Deviation$(4) = Deviation$(6) or Deviation$(5) = Deviation$(6) then
         print
         print "DUPLICATE DEVIATIONS WERE SCANNED--PLEASE RE-SCAN DEVIATIONS"
         print
         goto Choose_Board_Version
       end if
     end if


     if Num_Dev = 5 then
       if Deviation$(1) = Deviation$(2) or Deviation$(1) = Deviation$(3) or Deviation$(1) = Deviation$(4) or Deviation$(1) = Deviation$(5) or Deviation$(2) = Deviation$(3) or Deviation$(2) = Deviation$(4) or Deviation$(2) = Deviation$(5) or Deviation$(3) = Deviation$(4) or Deviation$(3) = Deviation$(5) or Deviation$(4) = Deviation$(5) then
         print
         print "DUPLICATE DEVIATIONS WERE SCANNED--PLEASE RE-SCAN DEVIATIONS"
         print
         goto Choose_Board_Version
       end if
     end if

     if Num_Dev = 4 then
       if Deviation$(1) = Deviation$(2) or Deviation$(1) = Deviation$(3) or Deviation$(1) = Deviation$(4) or Deviation$(2) = Deviation$(3) or Deviation$(2) = Deviation$(4) or Deviation$(3) = Deviation$(4) then
         print
         print "DUPLICATE DEVIATIONS WERE SCANNED--PLEASE RE-SCAN DEVIATIONS"
         print
         goto Choose_Board_Version
       end if
     end if

     if Num_Dev = 3 then
       if Deviation$(1) = Deviation$(2) or Deviation$(1) = Deviation$(3) or Deviation$(2) = Deviation$(3) then
         print
         print "DUPLICATE DEVIATIONS WERE SCANNED--PLEASE RE-SCAN DEVIATIONS"
         print
         goto Choose_Board_Version
       end if
     end if

     if Num_Dev = 2 then
       if Deviation$(1) = Deviation$(2) then
         print
         print "DUPLICATE DEVIATIONS WERE SCANNED--PLEASE RE-SCAN DEVIATIONS"
         print
         goto Choose_Board_Version
       end if
     end if


   !*************************************************************************
   !!END OF ERROR TRAP FOR DUPLICATE DEVIATIONS
   !*************************************************************************


      beep
     input "Scan ASSEMBLY BARCODE on board: ",Assembly$
      beep
      beep
     goto Set_Version
   end if


   if Dev = 0 then
      beep
      input "Scan ASSEMBLY BARCODE on board :" , Assembly$
      beep
      beep
     goto Set_Version
   end if

Set_Version:
!******************************************************************************
!******************************************************************************
! Variables used in menu selections:
! Please update this table when new variables are added!
! When variables are added, also set them to 0 in above section
!
!*Currently there are no Options in this testplan.
!*when Options are added put them here
!
!  -----------------------------------------------------------------------------
!Example:
!
!Option -- Used for Devaition or ECN affecting test:   1 = <change or new test>
!                                                      2 = <change or new test>
!                                                      3 =
!                                                      4 =
!  -----------------------------------------------------------------------------
!
!
!
!******************************************************************************
!******************************************************************************
!rint "Please complete a 10x3 before testing and new DC3 assemblies"
!rint "Please contact Steve Mantooth with any questions"
!ause

   if Assembly$ = "73-18275-05 A0" then
   ! print "PLEASE CALL AN ICT PROCESS TECH TO VERIFY THE COOKIE"
   ! pause!ALLpauses can be removed once a board is verified !!!
     Board$          =  Assembly$[1;11]
     Board_Rev$      =  Assembly$[13;2]
     Assy_73$        =  Assembly$[1;11]
     Assy_73_Rev$    =  Assembly$[13;2]
     Assy_800$       = ""
     Assy_800_Rev$   = ""
 !   Option_Elpd     = 1
 !   Option_short    = 1
     Bstyle$         = ""      ! Name assigned for TARS
 !   call Assign_Deviations    ! All options should be place before this line
         if Dev_count <> Num_Dev then
           print "YOU HAVE ENTERED AN INVALID DEVIATION"
           print "PLEASE CONTACT AN ICT PROCESS TECHNICIAN"!pause
         end if
     goto End_Set_Version
   end if

   print using "@"
   print "*******************************************************************"
   print "*     CHECK FOR THE CORRECT FIXTURE & CORRECT BARCODE LABEL       *"
   print "*  IF YOU STILL HAVE PROBLEMS  PLEASE CONTACT ICT TECH SUPPORT    *"
   print "*******************************************************************"

    beep

   end loop

   End_Set_Version:


      for Count = 1 to Num_Dev
     Deviation_Log$ = Deviation_Log$ & Deviation$(Count)
     if Count < Num_Dev then Deviation_Log$ = Deviation_Log$ & ", "
   next Count

subend
!##############################################################################
!                          END OF TESTMAIN
!##############################################################################


sub Initialize_Board_Constants
global Board$,Board_Rev$
global Using_Multiple_Versions, True, False
global Using_AwareTest

   Board$ = "73-18275-05"
   Board_Rev$ = "A0"

! 'vacuum well' statement goes here (if required)
   vacuum well a is 0,1,2,3
   Using_Multiple_Versions = False
   Using_AwareTest = False
subend

sub Characterize
global Status, Failed_In_Learn

   Status = Failed_In_Learn
   learn capacitance on
!~ test "analog/c122"  !*Small cap value 6.8p, skipped by jackwu 2017/12/24
!~ test "analog/c3745"  !*Small cap value 10p, skipped by jackwu 2017/12/24
!~ test "analog/c3764"  !*Small cap value 18p, skipped by jackwu 2017/12/24
!~ test "analog/c3765"  !*Small cap value 18p, skipped by jackwu 2017/12/24
!~ test "analog/fmkc1"  !*Small cap value 18p, skipped by jackwu 2017/12/24
!~ test "analog/fmkc2"  !*Small cap value 18p, skipped by jackwu 2017/12/24
!~ test "analog/c557"   !*Small cap value 100p, skipped by jackwu 2017/12/24
!~ test "analog/c561"   !*Small cap value 100p, skipped by jackwu 2017/12/24
   test "analog/fmcc19"                                 ! Parallel
   test "analog/fmcc35"                                 ! Parallel
!~ test "analog/c660"   !*Small cap value 22p, skipped by jackwu 2017/12/24
!~ test "analog/c1247"  !*Small cap value 22p, skipped by jackwu 2017/12/24
!~ test "analog/c1248"  !*Small cap value 22p, skipped by jackwu 2017/12/24
!~ test "analog/c1448"  !*Small cap value 22p, skipped by jackwu 20171224
   test "analog/c1655"                                  ! Parallel
   test "analog/c3215"
   test "analog/c3521"  ! test commented in testorder   ! Parallel
   test "analog/c3702"  ! test commented in testorder   ! Parallel
   test "analog/fmsc11"  ! test commented in testorder  ! Parallel
!~ test "analog/c3757"  !*Small cap value 27p, skipped by jackwu 2017/12/24
!~ test "analog/c3760"  !*Small cap value 27p, skipped by jackwu 2017/12/24
!~ test "analog/c3761"  !*Small cap value 27p, skipped by jackwu 2017/12/24
!~ test "analog/c3763"  !*Small cap value 27p, skipped by jackwu 2017/12/24
!~ test "analog/fmgc8"  !*Small cap value 27p, skipped by jackwu 2017/12/24
!~ test "analog/fmgc9"  !*Small cap value 27p, skipped by jackwu 2017/12/24
!~ test "analog/fmhc42" !*Small cap value 27p, skipped by jackwu 2017/12/24
   learn capacitance off
subend

sub Pre_Shorts (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   test "analog/fmgj1%presence"
!@ test "analog/j30%presence"  ! Covered by Shorts test Clyde 2019/6/20
!@ test "analog/j31%presence"  ! Covered by Shorts test Clyde 2019/6/20
!@ test "analog/j32%presence"  ! Covered by Shorts test Clyde 2019/6/20
!@ test "analog/j5%presence"   ! Covered by Shorts test Clyde 2019/6/20
   test "analog/j6%presence"
   test "analog/j83%presence"
   test "analog/p1%presence"
!@ test "analog/p10%presence"  !! Remove in EA564619 by Clyde 2019/06/06
!@  test "analog/p15%presence" !Not in BOM by Brog 2017/04/10
!@  test "analog/p17%presence" !Not in BOM by Brog 2017/04/10
!@ test "analog/p18%presence"  !! Remove in EA564619 by Clyde 2019/06/06
!@  test "analog/p19%presence" !Not in BOM by Brog 2017/04/10
   test "analog/p2%presence"
!@ test "analog/p20%presence" !Not in BOM by Brog 2017/04/10
!@  test "analog/p21%presence" !Not in BOM by Brog 2017/04/10
!@  test "analog/p4%presence"  !Not in BOM by Brog 2017/04/10
!@  test "analog/p5%presence" !Not in BOM by Brog 2017/04/10
   test "analog/p7%presence"
   test "analog/p8%presence"
!@  test "analog/p9%presence" !Not in BOM by Brog 2017/04/10
   test "analog/u1%presence"
   test "analog/u25%presence"
   test "analog/u74%presence"
   test "analog/u71%presence"
subend

sub Shorts (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   test "shorts"
subend

sub Pins_Long (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
I = 0
Retry:
   I = I + 1
   test "pins_long"
   if dutfailed then
      report out
      if I = 4 then subexit
      print I
      clear failures|report clear
      faon
      auxdisconnect all
      faoff2
      faon
      auxconnect 5
      wait 1
      faoff2
      goto Retry
   end if
subend



sub Analog_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   !!!!!!!!!!  For different u25 supplier update by Clyde Huang on 2018/7/9
   test "analog/r1077"! the u25 supplier  DELTA
   test "analog/r1251"! the u25 supplier  DELTA
   if dutfailed then
   clear failures | report clear
   test "analog/r1077a"! the u25 supplier MURATA
   test "analog/r1251a"! the u25 supplier MURATA
   end if
   !!!!!!!!!!  For different u25 supplier influences !!!!!!!!!!!!!
   test "analog/fmac53"                                 ! Parallel w/>5 devices
   test "analog/c1391"                                  ! Parallel w/>5 devices
   test "analog/c1382"                                  ! Parallel w/>5 devices
   test "analog/c238"                                   ! Parallel w/>5 devices
   test "analog/c2073"                                  ! Parallel w/>5 devices
   test "analog/c104"                                   ! Parallel w/>5 devices
   test "analog/c179"                                   ! Parallel w/>5 devices
   test "analog/c105"                                   ! Parallel w/>5 devices
   test "analog/c180"                                   ! Parallel w/>5 devices
   test "analog/c1430"                                  ! Parallel w/>5 devices
   test "analog/fmac58"                                 ! Parallel w/>5 devices
   test "analog/c52"                                    ! Parallel w/>5 devices
   test "analog/c177"                                   ! Parallel w/>5 devices
   test "analog/fmhc43"                                 ! Parallel w/>5 devices
   test "analog/fmhc40"                                 ! Parallel w/>5 devices
   test "analog/c181"                                   ! Parallel w/>5 devices
   test "analog/c1345"                                  ! Parallel w/>5 devices
   test "analog/fmfc3"                                  ! Parallel w/>5 devices
   test "analog/c1390"                                  ! Parallel w/>5 devices
   test "analog/fmfc8"                                  ! Parallel w/>5 devices
   test "analog/fmtc8"                                  ! Parallel w/>5 devices
   test "analog/fmdc53"                                 ! Parallel w/>5 devices
   test "analog/c41"                                    ! Parallel w/>5 devices
   test "analog/fmkc3"                                  ! Parallel w/>5 devices
   test "analog/fmmc3"                                  ! Parallel w/>5 devices
   test "analog/c5375"
   test "analog/c5374"
   test "analog/c1705"
   test "analog/c133"
   test "analog/c1457"
   test "analog/c184"
   test "analog/c190"
   test "analog/c237"
   test "analog/c241"
   test "analog/c249"
   test "analog/c252"
   test "analog/c256"
   test "analog/c258"
   test "analog/c165"
   test "analog/c585"
   test "analog/c595"
   test "analog/c610"
   test "analog/c616"
   test "analog/c617"
   test "analog/c618"
   test "analog/c619"
   test "analog/c655"
   test "analog/c1120"
   test "analog/c1121"
   test "analog/c1122"
   test "analog/c1123"
!@ test "analog/c1124" !*removed wiring for freqency test by jackwu 2018/01/06
!@ test "analog/c1125" !*removed wiring for freqency test by jackwu 2018/01/06
   test "analog/c1153"
   test "analog/c1154"
   test "analog/c1155"
   test "analog/c1156"
   test "analog/c1158"
   test "analog/c1159"
   test "analog/c1160"
   test "analog/c1161"
   test "analog/c1162"
   test "analog/c1163"
   test "analog/c1164"
   test "analog/c1165"
   test "analog/c1166"
   test "analog/c1167"
   test "analog/c1168"
   test "analog/c1169"
   test "analog/c1170"
   test "analog/c1171"
   test "analog/c1173"
   test "analog/c1209"
   test "analog/fmhc28"
   test "analog/fmhc29"
   test "analog/c1298"
   test "analog/c1299"
   test "analog/c1337"
   test "analog/c1401"
   test "analog/c1402"
   test "analog/c1405"
   test "analog/c1622"
   test "analog/c1794"
   test "analog/c1911"
   test "analog/c1912"
   test "analog/c2093"
   test "analog/c2094"
   test "analog/c2095"
   test "analog/c2096"
   test "analog/c2097"
   test "analog/c2098"
   test "analog/c2099"
   test "analog/c2100"
   test "analog/c2162"
   test "analog/c2189"
   test "analog/c2206"
   test "analog/c3216"
   test "analog/c3416"
   test "analog/c3437"
   test "analog/c3439"
   test "analog/c3441"
   test "analog/c3699"
   test "analog/c3700"
   test "analog/c3704"
   test "analog/c3718"
   test "analog/c3719"
   test "analog/c3720"
   test "analog/c3721"
   test "analog/c3742"
   test "analog/c3744"
   test "analog/c3755"
   test "analog/c3756"
   test "analog/c3777"
   test "analog/c3778"
   test "analog/c3779"
   test "analog/c3782"
   test "analog/c3813"
   test "analog/c3814"
   test "analog/c3858"
   test "analog/c5500"
   test "analog/fmac1"
   test "analog/fmac28"
   test "analog/fmac29"
   test "analog/fmac30"
   test "analog/fmcc4"
   test "analog/fmcc7"
   test "analog/fmkc15"
   test "analog/fmfc1"
   test "analog/fmfc2"
   test "analog/fmgc1"
   test "analog/fmgc2"
   test "analog/fmgc3"
   test "analog/fmgc4"
   test "analog/fmgc7"
   test "analog/fmgc11"
   test "analog/fmgc16"
   test "analog/fmgc29"
   test "analog/fmhc13"
   test "analog/fmhc54"
   test "analog/fmkc27"
   test "analog/fmmc91"
   test "analog/fmsc1"
   test "analog/fmsc2"
   test "analog/fmsc12"
   test "analog/fmtc1"
   test "analog/fmtc2"
   test "analog/imbc20"
   test "analog/c254"
   test "analog/c556"
   test "analog/c562"
   test "analog/c658"
   test "analog/c1656"
   test "analog/c1658"
   test "analog/c3214"
   test "analog/c3414"
   test "analog/c3436"
   test "analog/c3697"
   test "analog/c3746"
   test "analog/c3747"
   test "analog/fmhc10"
   test "analog/fmhc16"
   test "analog/fmhc51"
   test "analog/fmhc53"
   test "analog/fmkc7"
   test "analog/fmkc8"
   test "analog/fmsc8"
   test "analog/c36"
   test "analog/c40"
   test "analog/c46"
   test "analog/c139"
   test "analog/c244"
   test "analog/c251"
   test "analog/c661"
   test "analog/c1212"
   test "analog/c1702"
   test "analog/c2070"
   test "analog/c2071"
   test "analog/c3211"
   test "analog/c3412"
   test "analog/c3415"
!! test "analog/fmac5" !!Not in BOM by Brog 2017/04/10
   test "analog/fmgc5"
   test "analog/fmcc1"
   test "analog/imbc22"
   test "analog/c2134"
   test "analog/fmhc15"
   test "analog/fmhc55"
   test "analog/c80"
   test "analog/c81"
   test "analog/c82"
   test "analog/c83"
   test "analog/c84"
   test "analog/c85"
   test "analog/c86"
   test "analog/c97"
   test "analog/c98"
   test "analog/c99"
   test "analog/c100"
   test "analog/c101"
   test "analog/c102"
   test "analog/c103"
   test "analog/c106"
   test "analog/c110"
   test "analog/c114"
   test "analog/c119"
   test "analog/c128"
   test "analog/c131"
   test "analog/c134"
   test "analog/c137"
   test "analog/c352"
   test "analog/c1860"
   test "analog/c1862"
   test "analog/c1864"
   test "analog/c1869"
   test "analog/c1870"
   test "analog/c1871"
   test "analog/c1872"
   test "analog/c1873"
   test "analog/c1874"
   test "analog/c1876"
   test "analog/c1877"
   test "analog/c1878"
   test "analog/c1879"
   test "analog/c1882"
   test "analog/c1883"
   test "analog/c1884"
   test "analog/c1886"
   test "analog/c1887"
   test "analog/c1888"
   test "analog/c1897"
   test "analog/c1898"
   test "analog/c1899"
   test "analog/c1901"
   test "analog/c1904"
   test "analog/c1905"
   test "analog/c1906"
   test "analog/fmac4"
   test "analog/c188"
   test "analog/fmhc30"
   test "analog/c124"
   test "analog/c138"
   test "analog/fmhc2"
   test "analog/c662"
   test "analog/c3231"
   test "analog/c3417"
   test "analog/imbc23"
   test "analog/c121"
   test "analog/c1657"
   test "analog/c3438"
   test "analog/c3698"
   test "analog/fmhc52"
   test "analog/fmsc9"
   test "analog/c123"
   test "analog/c135"
   test "analog/c3864"
   test "analog/c125"
   test "analog/c1211"
   test "analog/c1208"
   test "analog/fmhc8"
   test "analog/c648"
   test "analog/c3237"
   test "analog/c3419"
   test "analog/c564"
   test "analog/c565"
   test "analog/c566"
   test "analog/c572"
   test "analog/fmcc2"                                  ! Parallel
   test "analog/fmcc3"                                  ! Parallel
   test "analog/c1403"
   test "analog/fmcc8"                                  ! Parallel
   test "analog/fmcc9"                                  ! Parallel
   test "analog/fmcc44"  ! test commented in testorder  ! Parallel
   test "analog/fmfc6"
   test "analog/fmtc6"
   test "analog/imbc5"  ! test commented in testorder   ! Parallel
   test "analog/imbc24"                                 ! Parallel
   test "analog/imbc33"                                 ! Parallel
   test "analog/fmcc19"                                 ! Parallel
   test "analog/fmcc35"                                 ! Parallel
   test "analog/fmhc14"
   test "analog/fmcc20"
   test "analog/fmcc26"
   test "analog/imbc10"
   test "analog/imbc11"
   test "analog/imbc14"                                 ! Parallel
   test "analog/imbc19"                                 ! Parallel
   test "analog/c1404"
   test "analog/c1655"                                  ! Parallel
   test "analog/c3215"
   test "analog/c3521"  ! test commented in testorder   ! Parallel
   test "analog/c3702"  ! test commented in testorder   ! Parallel
   test "analog/fmsc11"  ! test commented in testorder  ! Parallel
   test "analog/fmfc7"  ! test commented in testorder   ! Parallel
   test "analog/fmtc7"  ! test commented in testorder   ! Parallel
   test "analog/fmgc10"
   test "analog/fmhc6"
!@ test "analog/fmhc35" !*Small cap value 150p, skipped by jackwu 2017/12/24
   test "analog/imbc21"
   test "analog/imbc31"
   test "analog/fmsr7"
!@  test "analog/r1411" !not in bom by Dylan 2018/9/10
   test "analog/r405"                                   ! Zero Ohm
   test "analog/1l82"                                   !Pre_Shorts
   test "analog/1l83"                                   !Pre_Shorts
   test "analog/1l85"                                   !Pre_Shorts
   test "analog/1l86"                                   !Pre_Shorts
   test "analog/1l87"                                   !Pre_Shorts
   test "analog/fhml6"                                  !Pre_Shorts
   test "analog/fl1%pin1_2"                             !Pre_Shorts
   test "analog/fl1%pin3_4"                             !Pre_Shorts
   test "analog/fl2%pin1_2"                             !Pre_Shorts
   test "analog/fl2%pin3_4"                             !Pre_Shorts
   test "analog/fmal1"    !REV03                        !Pre_Shorts
   test "analog/fmal2"    !REV03                        !Pre_Shorts
   test "analog/fmal3"    !REV03                        !Pre_Shorts
   test "analog/fmar1"                                  !Pre_Shorts
   test "analog/fmar7"                                  !Pre_Shorts
   test "analog/fmar8"                                  !Pre_Shorts
   test "analog/fmar9"                                  !Pre_Shorts
   test "analog/fmar10"                                 !Pre_Shorts
   test "analog/fmar16"                                 !Pre_Shorts
   test "analog/fmar17"                                 !Pre_Shorts
   test "analog/fmar18"                                 !Pre_Shorts
   test "analog/fmar19"                                 !Pre_Shorts
   test "analog/fmar20"                                 !Pre_Shorts
   test "analog/fmar21"                                 !Pre_Shorts
   test "analog/fmar22"     !REV03                      !Pre_Shorts
   test "analog/fmar23"     !REV03                      !Pre_Shorts
   test "analog/fmar24"     !REV03                      !Pre_Shorts
   test "analog/fmcl1"                                  !Pre_Shorts
   test "analog/fmcl2"                                  !Pre_Shorts
   test "analog/fmcr1"                                  !Pre_Shorts
   test "analog/fmcr6"                                  !Pre_Shorts
   test "analog/fmcr10"                                 !Pre_Shorts
   test "analog/fmcr14"                                 !Pre_Shorts
   test "analog/fmcr28"                                 !Pre_Shorts
   test "analog/fmcr29"                                 !Pre_Shorts
   test "analog/fmcr32"                                 !Pre_Shorts
   test "analog/fmcr33"                                 !Pre_Shorts
   test "analog/fmcr34"                                 !Pre_Shorts
   test "analog/fmcr35"                                 !Pre_Shorts
   test "analog/fmcr36"                                 !Pre_Shorts
   test "analog/fmcr37"                                 !Pre_Shorts
   test "analog/fmcr40"                                 !Pre_Shorts
   test "analog/fmfr2"                                  !Pre_Shorts
   test "analog/fmfr8"                                  !Pre_Shorts
   test "analog/fmfr13"                                 !Pre_Shorts
   test "analog/fmgt1%1_2"                              !Pre_Shorts
   test "analog/fmgt1%1_3"                              !Pre_Shorts
   test "analog/fmgt1%4_5"                              !Pre_Shorts
   test "analog/fmgt1%4_6"                              !Pre_Shorts
   test "analog/fmgt1%7_8"                              !Pre_Shorts
   test "analog/fmgt1%7_9"                              !Pre_Shorts
   test "analog/fmgt1%10_11"                            !Pre_Shorts
   test "analog/fmgt1%10_12"                            !Pre_Shorts
   test "analog/fmgt1%15_13"                            !Pre_Shorts
   test "analog/fmgt1%15_14"                            !Pre_Shorts
   test "analog/fmgt1%18_16"                            !Pre_Shorts
   test "analog/fmgt1%18_17"                            !Pre_Shorts
   test "analog/fmgt1%21_19"                            !Pre_Shorts
   test "analog/fmgt1%21_20"                            !Pre_Shorts
   test "analog/fmgt1%24_22"                            !Pre_Shorts
   test "analog/fmgt1%24_23"                            !Pre_Shorts
   test "analog/fmhf1"                                  !Pre_Shorts
   test "analog/fmhf2"                                  !Pre_Shorts
   test "analog/fmhf3"                                  !Pre_Shorts
   test "analog/fmhl1"                                  !Pre_Shorts
   test "analog/fmhl2"                                  !Pre_Shorts
   test "analog/fmhl5"                                  !Pre_Shorts
   test "analog/fmhr1"                                  !Pre_Shorts
   test "analog/fmhr10"                                 !Pre_Shorts
   test "analog/fmhr13"                                 !Pre_Shorts
   test "analog/fmhr14"                                 !Pre_Shorts
   test "analog/fmhr15"                                 !Pre_Shorts
   test "analog/fmhr18"                                 !Pre_Shorts
   test "analog/fmhr20"                                 !Pre_Shorts
   test "analog/fmhr49"                                 !Pre_Shorts
   test "analog/fmhr53"                                 !Pre_Shorts
   test "analog/fmhr54"                                 !Pre_Shorts
   test "analog/fmht1%1_2"                              !Pre_Shorts
   test "analog/fmht1%3_4"                              !Pre_Shorts
   test "analog/fmht1%5_6"                              !Pre_Shorts
   test "analog/fmht1%7_8"                              !Pre_Shorts
   test "analog/fmht1%9_10"                             !Pre_Shorts
   test "analog/fmht1%11_12"                            !Pre_Shorts
   test "analog/fmkl1"                                  !Pre_Shorts
   test "analog/fmkl2"                                  !Pre_Shorts
   test "analog/fmkr18"                                 !Pre_Shorts
   test "analog/fmkr19"                                 !Pre_Shorts
   test "analog/fmsl1"                                  !Pre_Shorts
   test "analog/fmsr6"                                  !Pre_Shorts
   test "analog/fmsr8"                                  !Pre_Shorts
   test "analog/fmsr11"                                 !Pre_Shorts
   test "analog/fmsr12"                                 !Pre_Shorts
   test "analog/fmtr2"                                  !Pre_Shorts
   test "analog/fmtr8"                                  !Pre_Shorts
   test "analog/fmtr13"                                 !Pre_Shorts
   test "analog/imbl1"                                  !Pre_Shorts
   test "analog/imbl2"                                  !Pre_Shorts
   test "analog/imbr20"                                 !Pre_Shorts
   test "analog/imbr40"                                 !Pre_Shorts
   test "analog/imbr41"                                 !Pre_Shorts
   test "analog/l1"                                     !Pre_Shorts
   test "analog/l2"                                     !Pre_Shorts
   test "analog/l3"                                     !Pre_Shorts
   test "analog/l10"                                    !Pre_Shorts
   test "analog/l11"                                    !Pre_Shorts
   test "analog/l13"                                    !Pre_Shorts
   test "analog/l14"                                    !Pre_Shorts
   test "analog/l15"                                    !Pre_Shorts
   test "analog/l16"                                    !Pre_Shorts
   test "analog/l17"                                    !Pre_Shorts
   test "analog/l20"                                    !Pre_Shorts
   test "analog/l24"                                    !Pre_Shorts
   test "analog/l25"                                    !Pre_Shorts
   test "analog/l26"                                    !Pre_Shorts
   test "analog/l27"                                    !Pre_Shorts
   test "analog/l29"                                    !Pre_Shorts
   test "analog/l31"                                    !Pre_Shorts
   test "analog/l32"                                    !Pre_Shorts
   test "analog/l33"                                    !Pre_Shorts
   test "analog/l35"                                    !Pre_Shorts
   test "analog/l36"                                    !Pre_Shorts
   test "analog/l37"                                    !Pre_Shorts
   test "analog/l38"                                    !Pre_Shorts
   test "analog/l40"                                    !Pre_Shorts
   test "analog/l41"                                    !Pre_Shorts
   test "analog/l42"                                    !Pre_Shorts
   test "analog/l43"                                    !Pre_Shorts
   test "analog/l45"                                    !Pre_Shorts
   test "analog/l46"                                    !Pre_Shorts
   test "analog/l47"                                    !Pre_Shorts
   test "analog/l48"                                    !Pre_Shorts
   test "analog/l49"                                    !Pre_Shorts
   test "analog/l50"                                    !Pre_Shorts
   test "analog/l51"                                    !Pre_Shorts
   test "analog/l52"                                    !Pre_Shorts
   test "analog/l53"                                    !Pre_Shorts
   test "analog/l54"                                    !Pre_Shorts
   test "analog/l55"                                    !Pre_Shorts
   test "analog/l56"                                    !Pre_Shorts
   test "analog/l57"                                    !Pre_Shorts
   test "analog/l58"                                    !Pre_Shorts
   test "analog/l59"                                    !Pre_Shorts
   test "analog/l61"                                    !Pre_Shorts
   test "analog/l62"                                    !Pre_Shorts
   test "analog/l63"                                    !Pre_Shorts
   test "analog/l64"                                    !Pre_Shorts
   test "analog/l65"                                    !Pre_Shorts
   test "analog/l66"                                    !Pre_Shorts
   test "analog/l67"                                    !Pre_Shorts
   test "analog/l68"                                    !Pre_Shorts
   test "analog/l69"                                    !Pre_Shorts
   test "analog/l70"                                    !Pre_Shorts
   test "analog/l72"                                    !Pre_Shorts
   test "analog/l73"                                    !Pre_Shorts
   test "analog/l74"                                    !Pre_Shorts
   test "analog/l75"                                    !Pre_Shorts
   test "analog/l76"                                    !Pre_Shorts
   test "analog/l77"                                    !Pre_Shorts
   test "analog/l78"                                    !Pre_Shorts
   test "analog/l79"                                    !Pre_Shorts
   test "analog/l80"                                    !Pre_Shorts
   test "analog/l81"                                    !Pre_Shorts
   test "analog/l82"                                    !Pre_Shorts
   test "analog/l83"                                    !Pre_Shorts
   test "analog/l84"                                    !Pre_Shorts
   test "analog/l85"                                    !Pre_Shorts
   test "analog/l86"                                    !Pre_Shorts
   test "analog/l88"                                    !Pre_Shorts
   test "analog/l89"                                    !Pre_Shorts
   test "analog/l90"                                    !Pre_Shorts
   test "analog/l91"                                    !Pre_Shorts
   test "analog/l93"                                    !Pre_Shorts
   test "analog/l94"                                    !Pre_Shorts
   test "analog/l95"                                    !Pre_Shorts
   test "analog/l96"                                    !Pre_Shorts
   test "analog/l97"                                    !Pre_Shorts
   test "analog/l98"                                    !Pre_Shorts
   test "analog/l99"                                    !Pre_Shorts
   test "analog/l100"                                   !Pre_Shorts
   test "analog/l101"                                   !Pre_Shorts
   test "analog/l102"                                   !Pre_Shorts
   test "analog/l103"                                   !Pre_Shorts
   test "analog/l104"                                   !Pre_Shorts
   test "analog/l105"                                   !Pre_Shorts
   test "analog/l106"                                   !Pre_Shorts
   test "analog/l107"                                   !Pre_Shorts
   test "analog/l109"                                   !Pre_Shorts
   test "analog/l110"                                   !Pre_Shorts
   test "analog/l111"                                   !Pre_Shorts
   test "analog/l113"                                   !Pre_Shorts
   test "analog/l116"                                   !Pre_Shorts
   test "analog/l117"                                   !Pre_Shorts
   test "analog/l237"                                   !Pre_Shorts
   test "analog/l486"                                   !Pre_Shorts
   test "analog/r18"                                    ! Zero Ohm !Pre_Shorts
   test "analog/r48"                                    ! Zero Ohm !Pre_Shorts
   test "analog/r54"                                    ! Zero Ohm !Pre_Shorts
   test "analog/r57"                                    ! Zero Ohm !Pre_Shorts
   test "analog/r60"                                    ! Zero Ohm !Pre_Shorts
   test "analog/r115"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r123"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r125"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r140"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r267"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r269"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r270"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r271"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r294"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r331"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r334"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r391"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r397"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r407"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r491"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r494"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r531"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r546"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r609"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r633"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r635"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r677"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r679"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r825"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r847"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r872"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r876"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r916"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r943"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r947"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r949"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r971"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r972"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r982"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r998"                                   ! Zero Ohm !Pre_Shorts
   test "analog/r1038"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1039"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1040"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1045"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1050"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1051"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1053"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1058"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1059"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1072"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1073"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1074"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1084"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1085"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1098"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1103"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1112"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1113"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1115"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1179"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1185"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1192"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1209"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1212"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1222"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1223"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1234"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1236"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1239"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1241"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1242"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1256"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1258"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1264"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1299"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1305"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1306"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1323"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1335"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1337"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1338"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1367"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1376"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1378"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1389"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1391"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1471"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1747"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1765"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1766"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1802"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1809"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1818"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1838"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1841"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1865"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1868"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1896"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1904"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1905"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1906"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1914"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1938"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1939"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1952"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1959"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1961"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1977"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r1979"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2003"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2018"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2131"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2132"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2146"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2147"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2157"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2162"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2199"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2234"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2239"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2262"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2264"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2266"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2268"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2507"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2508"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2509"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2510"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2541"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2542"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2546"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2548"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2558"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2585"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2732"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2733"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2858"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2859"                                  ! Zero Ohm !Pre_Shorts
   test "analog/r2887"                                  ! Zero Ohm !Pre_Shorts
   test "analog/rmhr9"                                  !Pre_Shorts
   test "analog/fmar2"
   test "analog/fmar3"
   test "analog/fmar4"
   test "analog/r1345"
   test "analog/fmar5"
   test "analog/fmar6"
   test "analog/fmar25"
   test "analog/fmkr1"
   test "analog/fmkr3"
   test "analog/fmkr4"
   test "analog/fmkr5"
   test "analog/fmkr10"
   test "analog/fmkr11"
   test "analog/fmkr12"
   test "analog/fmkr13"
   test "analog/fmkr14"
   test "analog/fmkr15"
   test "analog/fmkr22"
   test "analog/fmkr23"
   test "analog/fmkr24"
   test "analog/fmkr25"
   test "analog/fmkr26"
   test "analog/fmkr30"
   test "analog/fmsr15"
   test "analog/r3"
   test "analog/r4"
   test "analog/r9"
   test "analog/r10"
   test "analog/r13"
   test "analog/r14"
   test "analog/r71"
   test "analog/r77"
   test "analog/r78"
   test "analog/r86"
   test "analog/r88"
   test "analog/r89"
   test "analog/r94"
   test "analog/r96"
   test "analog/r97"
   test "analog/r98"
   test "analog/r99"
   test "analog/r100"
   test "analog/r120"
   test "analog/r128"
   test "analog/r134"
   test "analog/r136"
   test "analog/r192"
   test "analog/r200"
   test "analog/r215"
   test "analog/r218"
   test "analog/r221"
   test "analog/r223"
   test "analog/r233"
   test "analog/r361"
   test "analog/r487"
   test "analog/r489"
   test "analog/r495"
   test "analog/r499"
   test "analog/r505"
   test "analog/r507"
   test "analog/r543"
   test "analog/r550"
   test "analog/r553"
   test "analog/r554"
   test "analog/r558"
   test "analog/r559"
   test "analog/r560"
   test "analog/r561"
   test "analog/r601"
   test "analog/r602"
   test "analog/r603"
   test "analog/r604"
   test "analog/r605"
   test "analog/r606"
   test "analog/r607"
   test "analog/r608"
   test "analog/r661"
   test "analog/r718"
   test "analog/r719"
   test "analog/r723"
   test "analog/r736"
   test "analog/r744"
   test "analog/r748"
   test "analog/r767"
   test "analog/r769"
   test "analog/r809"
   test "analog/r819"
   test "analog/r877"
   test "analog/r879"
   test "analog/r880"
   test "analog/r881"
   test "analog/r883"
   test "analog/r884"
   test "analog/r885"
   test "analog/r890"
   test "analog/r891"
   test "analog/r893"
   test "analog/r894"
   test "analog/r899"
   test "analog/r903"
   test "analog/r904"
   test "analog/r908"
   test "analog/r909"
   test "analog/r911"
   test "analog/r912"
   test "analog/r913"
   test "analog/r919"
   test "analog/r923"
   test "analog/r926"
   test "analog/r933"
   test "analog/r934"
   test "analog/r935"
   test "analog/r939"
   test "analog/r940"
   test "analog/r946"
   test "analog/r950"
   test "analog/r959"
   test "analog/r963"
   test "analog/r970"
   test "analog/r991"
   test "analog/r1006"
   test "analog/r1020"
   test "analog/r1029"
   test "analog/r1030"
   test "analog/r1037"
   test "analog/r1071"
   test "analog/r1076"
   test "analog/r1089"
   test "analog/r1102"
   test "analog/r1111"
   test "analog/r1122"
   test "analog/r1123"
   test "analog/r1125"
   test "analog/r1126"
   test "analog/r1127"
   test "analog/r1128"
   test "analog/r1129"
   test "analog/r1130"
   test "analog/r1131"
   test "analog/r1132"
   test "analog/r1133"
   test "analog/r1134"
   test "analog/r1135"
   test "analog/r1136"
   test "analog/r1137"
   test "analog/r1138"
   test "analog/r1139"
   test "analog/r1144"
   test "analog/r1145"
   test "analog/r1146"
   test "analog/r1147"
   test "analog/r1148"
   test "analog/r1149"
   test "analog/r1150"
   test "analog/r1151"
   test "analog/r1152"
   test "analog/r1153"
   test "analog/r1154"
   test "analog/r1155"
   test "analog/r1157"
   test "analog/r1158"
   test "analog/r1167"
   test "analog/r1171"
   test "analog/r1172"
   test "analog/r1174"
   test "analog/r1175"
   test "analog/r1176"
   test "analog/r1180"
   test "analog/r1181"
   test "analog/r1182"
   test "analog/r1183"
   test "analog/r1184"
   test "analog/r1187"
   test "analog/r1188"
   test "analog/r1198"
   test "analog/r1199"
   test "analog/r1208"
   test "analog/r1221"
   test "analog/r1224"
   test "analog/r1228"
   test "analog/r1252"
   test "analog/r1254"
   test "analog/r1255"
   test "analog/r1259"
   test "analog/r1262"
   test "analog/r1300"
   test "analog/r1357"
   test "analog/r1365"
   test "analog/r1370"
   test "analog/r1372"
   test "analog/r1380"
   test "analog/r1384"
   test "analog/r1390"
   test "analog/r1496"
   test "analog/r1509"
   test "analog/r1539"
   test "analog/r1916"
   test "analog/r1957"
   test "analog/r2002"
   test "analog/r2016"
   test "analog/r2017"
   test "analog/r2024"
   test "analog/r2027"
   test "analog/r2030"
   test "analog/r2031"
   test "analog/r2034"
   test "analog/r2037"
   test "analog/r2060"
   test "analog/r2352"
   test "analog/r2353"
   test "analog/r2356"
   test "analog/r2368"
   test "analog/r2369"
   test "analog/r2370"
   test "analog/r2371"
   test "analog/r2372"
   test "analog/r2373"
   test "analog/r2374"
   test "analog/r2550"
   test "analog/r2551"
   test "analog/r2552"
   test "analog/r2553"
   test "analog/r2580"
   test "analog/r2581"
   test "analog/r2582"
   test "analog/r2583"
   test "analog/r2666"
   test "analog/r2891"
   test "analog/r2892"
   test "analog/fmar11"
   test "analog/fmar12"
   test "analog/fmcr8"
   test "analog/fmhr16"
   test "analog/fmhr17"
   test "analog/imbr10"
   test "analog/imbr11"
   test "analog/imbr30"
   test "analog/r272"
   test "analog/r416"
   test "analog/r423"
   test "analog/r928"
   test "analog/r929"
   test "analog/r930"
   test "analog/r1193"
   test "analog/r1207"
   test "analog/r1263"
   test "analog/r1346"
   test "analog/fmar13"
   test "analog/fmar14"
   test "analog/r1328"
   test "analog/fmar15"
   test "analog/fmcr2"
   test "analog/fmcr3"
   test "analog/r408"
   test "analog/fmcr4"
   test "analog/fmgr11"
   test "analog/r293"
   test "analog/r420"
   test "analog/r426"
   test "analog/fmcr5"
   test "analog/imbr28"
   test "analog/r170"
   test "analog/r868"
   test "analog/r2125"
   test "analog/r2145"
   test "analog/fmcr7"
   test "analog/fmcr11"
   test "analog/imbr1"
   test "analog/imbr37"
   test "analog/r620"
   test "analog/fmcr9"
   test "analog/fmcr13"
   test "analog/fmcr12"
   test "analog/fmgr5"
   test "analog/fmgr10"
   test "analog/fmkr2"
   test "analog/fmkr29"
   test "analog/imbr35"
   test "analog/r20"
   test "analog/r49"
   test "analog/r58"
   test "analog/r118"
   test "analog/r143"
   test "analog/r145"
   test "analog/r164"
   test "analog/r172"
   test "analog/r241"
   test "analog/r242"
   test "analog/r298"
   test "analog/r301"
   test "analog/r302"
   test "analog/r309"
   test "analog/r315"
   test "analog/r317"
   test "analog/r320"
   test "analog/r322"
   test "analog/r329"
   test "analog/r395"
   test "analog/r399"
   test "analog/r402"
   test "analog/r417"
   test "analog/r422"
   test "analog/r459"
   test "analog/r496"
   test "analog/r501"
   test "analog/r504"
   test "analog/r515"
   test "analog/r528"
   test "analog/r551"
   test "analog/r555"
   test "analog/r611"
   test "analog/r612"
   test "analog/r613"
   test "analog/r614"
   test "analog/r615"
   test "analog/r616"
   test "analog/r698"
   test "analog/r703"
   test "analog/r708"
   test "analog/r712"
   test "analog/r717"
   test "analog/r725"
   test "analog/r737"
   test "analog/r739"
   test "analog/r742"
   test "analog/r743"
   test "analog/r746"
   test "analog/r747"
   test "analog/r755"
   test "analog/r763"
   test "analog/r764"
   test "analog/r772"
   test "analog/r782"
   test "analog/r811"
   test "analog/r888"
   test "analog/r889"
   test "analog/r910"
   test "analog/r920"
   test "analog/r921"
   test "analog/r948"
   test "analog/r968"
   test "analog/r974"
   test "analog/r977"
   test "analog/r979"
   test "analog/r981"
   test "analog/r989"
   test "analog/r990"
   test "analog/r999"
   test "analog/r1023"
   test "analog/r1032"
   test "analog/r1035"
   test "analog/r1041"
   test "analog/r1043"
   test "analog/r1049"
   test "analog/r1056"
   test "analog/r1057"
   test "analog/r1061"
   test "analog/r1062"
   test "analog/r1088"
   test "analog/r1095"
   test "analog/r1096"
   test "analog/r1106"
   test "analog/r1141"
   test "analog/r1143"
   test "analog/r1160"
   test "analog/r1162"
   test "analog/r1165"
   test "analog/r1191"
   test "analog/r1194"
   test "analog/r1195"
   test "analog/r1205"
   test "analog/r1206"
   test "analog/r1214"
   test "analog/r1230"
   test "analog/r1243"
   test "analog/r1245"
   test "analog/r1247"
   test "analog/r1267"
   test "analog/r1269"
   test "analog/r1272"
   test "analog/r1277"
   test "analog/r1279"
   test "analog/r1280"
   test "analog/r1281"
   test "analog/r1285"
   test "analog/r1286"
   test "analog/r1287"
   test "analog/r1289"
   test "analog/r1294"
   test "analog/r1298"
   test "analog/r1303"
   test "analog/r1307"
   test "analog/r1308"
   test "analog/r1310"
   test "analog/r1311"
   test "analog/r1330"
   test "analog/r1347"
   test "analog/r1348"
   test "analog/r1349"
   test "analog/r1350"
   test "analog/r1352"
   test "analog/r1366"
   test "analog/r1382"
   test "analog/r1434"
   test "analog/r1436"
   test "analog/r1444"
   test "analog/r1445"
   test "analog/r1460"
!@ test "analog/r1608"  !Not in BOM by Brog  2018/04/10
!@ test "analog/r1609"  !Not in BOM by Brog  2018/04/10
   test "analog/r1767"
   test "analog/r1792"
   test "analog/r1893"
   test "analog/r1903"
   test "analog/r1921"
   test "analog/r1983"
   test "analog/r1990"
   test "analog/r1991"
   test "analog/r1993"
   test "analog/r1996"
   test "analog/r1998"
   test "analog/r2001"
   test "analog/r2004"
   test "analog/r2006"
   test "analog/r2008"
   test "analog/r2009"
   test "analog/r2010"
   test "analog/r2011"
   test "analog/r2012"
   test "analog/r2013"
   test "analog/r2019"
   test "analog/r2020"
   test "analog/r2038"
   test "analog/r2041"
   test "analog/r2046"
   test "analog/r2050"
   test "analog/r2057"
   test "analog/r2061"
   test "analog/r2077"
   test "analog/r2108"
   test "analog/r2193"
   test "analog/r2222"
   test "analog/r2232"
   test "analog/r2269"
   test "analog/r2282"
   test "analog/r2324"
   test "analog/r2348"
   test "analog/r2350"
   test "analog/r2375"
   test "analog/r2686"
   test "analog/r2687"
   test "analog/r2863"
   test "analog/r2951"
   test "analog/fmcr15"
   test "analog/fmcr16"
   test "analog/fmcr18"
   test "analog/fmcr19"
   test "analog/fmcr20"
   test "analog/fmcr21"
   test "analog/fmcr22"
   test "analog/fmcr23"
   test "analog/fmcr25"
   test "analog/fmcr26"
   test "analog/imbr13"
   test "analog/imbr14"
   test "analog/imbr22"
   test "analog/imbr23"
   test "analog/fmcr17"
   test "analog/fmcr30"
   test "analog/fmcr27"
   test "analog/fmcr31"
   test "analog/fmfr3"
   test "analog/fmfr5"
   test "analog/fmfr12"
   test "analog/fmgr8"
   test "analog/fmgr12"
   test "analog/fmgr13"
   test "analog/fmgr15"
   test "analog/fmgr16"
   test "analog/fmgr17"
   test "analog/fmgr18"
   test "analog/fmgr19"
   test "analog/fmgr20"
   test "analog/fmgr21"
   test "analog/fmgr22"
   test "analog/fmgr23"
   test "analog/fmgr24"
   test "analog/fmgr25"
   test "analog/fmgr26"
   test "analog/fmhr8"
   test "analog/fmhr45"
   test "analog/fmhr46"
   test "analog/fmhr50"
   test "analog/fmhr52"
   test "analog/fmkr16"
   test "analog/fmsr10"
   test "analog/fmtr3"
   test "analog/fmtr5"
   test "analog/fmtr9"
   test "analog/fmtr12"
   test "analog/imbr25"
   test "analog/imbr31"
   test "analog/r5"
   test "analog/r6"
   test "analog/r19"
   test "analog/r21"
   test "analog/r23"
   test "analog/r24"
   test "analog/r30"
   test "analog/r31"
   test "analog/r32"
   test "analog/r33"
   test "analog/r42"
   test "analog/r67"
   test "analog/r84"
   test "analog/r91"
   test "analog/r124"
   test "analog/r135"
   test "analog/r148"
   test "analog/r149"
   test "analog/r386"
   test "analog/r387"
   test "analog/r392"
   test "analog/r394"
   test "analog/r419"
   test "analog/r427"
   test "analog/r428"
   test "analog/r429"
   test "analog/r431"
   test "analog/r432"
   test "analog/r433"
   test "analog/r434"
   test "analog/r484"
   test "analog/r497"
   test "analog/r512"
   test "analog/r523"
   test "analog/r525"
   test "analog/r526"
   test "analog/r529"
   test "analog/r530"
   test "analog/r532"
   test "analog/r580"
   test "analog/r589"
   test "analog/r704"
   test "analog/r705"
   test "analog/r806"
   test "analog/r854"
   test "analog/r856"
   test "analog/r859"
   test "analog/r864"
   test "analog/r867"
   test "analog/r878"
   test "analog/r992"
   test "analog/r1013"
   test "analog/r1042"
   test "analog/r1046"
   test "analog/r1047"
   test "analog/r1048"
   test "analog/r1054"
   test "analog/r1063"
   test "analog/r1066"
   test "analog/r1067"
   test "analog/r1078"
   test "analog/r1081"
   test "analog/r1087"
   test "analog/r1094"
   test "analog/r1105"
   test "analog/r1124"
   test "analog/r1156"
   test "analog/r1170"
   test "analog/r1186"
   test "analog/r1190"
   test "analog/r1216"
   test "analog/r1217"
   test "analog/r1219"
   test "analog/r1225"
   test "analog/r1231"
   test "analog/r1253"
   test "analog/r1265"
   test "analog/r1268"
   test "analog/r1290"
   test "analog/r1296"
   test "analog/r1297"
   test "analog/r1336"
   test "analog/r1339"
   test "analog/r1340"
   test "analog/r1341"
   test "analog/r1342"
   test "analog/r1343"
   test "analog/r1344"
   test "analog/r1406"
   test "analog/r1408"
   test "analog/r1427"
   test "analog/r1813"
   test "analog/r1883"
   test "analog/r1885"
   test "analog/r1887"
   test "analog/r1900"    !REV03
   test "analog/r1917"
   test "analog/r1920"
   test "analog/r1927"
   test "analog/r1929"
   test "analog/r1958"
   test "analog/r1976"
   test "analog/r2021"
   test "analog/r2022"
   test "analog/r2033"
   test "analog/r2040"
   test "analog/r2062"
   test "analog/r2075"
   test "analog/r2076"
   test "analog/r2112"
   test "analog/r2114"
   test "analog/r2143"
   test "analog/r2144"
   test "analog/r2148"
   test "analog/r2149"
   test "analog/r2151"
   test "analog/r2152"
   test "analog/r2198"
   test "analog/r2200"
   test "analog/r2201"
   test "analog/r2204"
   test "analog/r2205"
   test "analog/r2208"
   test "analog/r2217"
   test "analog/r2218"
   test "analog/r2219"
   test "analog/r2226"
   test "analog/r2227"
   test "analog/r2230"
   test "analog/r2233"
   test "analog/r2238"
   test "analog/r2240"
   test "analog/r2537"
   test "analog/r2918"
   test "analog/r2919"
   test "analog/r2920"
   test "analog/r2921"
   test "analog/r2922"
   test "analog/r2923"
   test "analog/r52"
   test "analog/r132"
   test "analog/r246"
   test "analog/r247"
   test "analog/r259"
   test "analog/r260"
   test "analog/r286"
   test "analog/r287"
   test "analog/r305"
   test "analog/r306"
   test "analog/r582"
   test "analog/r595"
   test "analog/r597"
   test "analog/r599"
   test "analog/r600"
   test "analog/r1075"
   test "analog/r1163"
   test "analog/r1210"
   test "analog/r1211"
   test "analog/r1261"
   test "analog/r2043"
   test "analog/r2044"
   test "analog/r2045"
   test "analog/r2047"
   test "analog/r2049"
   test "analog/r2051"
   test "analog/r2066"
   test "analog/r2165"
   test "analog/r2166"
   test "analog/r2194"
   test "analog/r2688"
   test "analog/fmfr1"
   test "analog/fmfr4"
   test "analog/fmfr6"
   test "analog/fmhr51"
   test "analog/fmsr1"
   test "analog/fmsr3"
   test "analog/fmtr4"
   test "analog/fmtr6"
   test "analog/r53"
   test "analog/r103"
   test "analog/r415"
   test "analog/r424"
   test "analog/r436"
   test "analog/r437"
   test "analog/r618"
   test "analog/r706"
   test "analog/r892"
   test "analog/r902"
   test "analog/r907"
   test "analog/r1318"
   test "analog/r1331"
   test "analog/r1334"
   test "analog/r1355"
   test "analog/r1387"
   test "analog/r1817"
   test "analog/r85"
   test "analog/r1953"
   test "analog/r1969"
   test "analog/r1971"
   test "analog/fmfr7"
   test "analog/fmfr11"
   test "analog/fmgr1"
   test "analog/fmgr2"
   test "analog/fmgr3"
   test "analog/fmgr4"
   test "analog/r27"
   test "analog/r29"
   test "analog/r39"
   test "analog/r875"
   test "analog/r1725"
   test "analog/r1750"
   test "analog/r2026"
   test "analog/r2032"
   test "analog/r2036"
   test "analog/fmgr6"
   test "analog/fmhr7"
   test "analog/fmkr9"
   test "analog/r815"
   test "analog/r2242"
   test "analog/fmgr9"
   test "analog/r22"
   test "analog/r41"
   test "analog/r50"
   test "analog/r214"
   test "analog/r216"
   test "analog/r217"
   test "analog/r220"
   test "analog/r222"
   test "analog/r226"
   test "analog/r232"
   test "analog/r252"
   test "analog/r265"
   test "analog/r376"
   test "analog/r377"
   test "analog/r378"
   test "analog/r379"
   test "analog/r380"
   test "analog/r381"
   test "analog/r382"
   test "analog/r467"
   test "analog/r468"
   test "analog/r626"
   test "analog/r627"
   test "analog/r630"
   test "analog/r631"
   test "analog/r662"
   test "analog/r665"
   test "analog/r666"
   test "analog/r668"
   test "analog/r671"
   test "analog/r728"
   test "analog/r729"
   test "analog/r799"
   test "analog/r810"
   test "analog/r817"
   test "analog/r822"
   test "analog/r827"
   test "analog/r841"
   test "analog/r842"
   test "analog/r857"
   test "analog/r858"
   test "analog/r886"
   test "analog/r887"
   test "analog/r895"
   test "analog/r905"
   test "analog/r906"
   test "analog/r915"
   test "analog/r917"
   test "analog/r918"
   test "analog/r922"
   test "analog/r932"
   test "analog/r938"
   test "analog/r955"
   test "analog/r960"
   test "analog/r961"
   test "analog/r962"
   test "analog/r966"
   test "analog/r969"
   test "analog/r995"
   test "analog/r1002"
   test "analog/r1003"
   test "analog/r1004"
   test "analog/r1005"
   test "analog/r1007"
   test "analog/r1064"
   test "analog/r1090"
   test "analog/r1091"
   test "analog/r1092"
   test "analog/r1097"
   test "analog/r1100"
   test "analog/r1101"
   test "analog/r1109"
   test "analog/r1140"
   test "analog/r1142"
   test "analog/r1159"
   test "analog/r1161"
   test "analog/r1240"
   test "analog/r1317"
   test "analog/r1319"
   test "analog/r1320"
   test "analog/r1322"
   test "analog/r1325"
   test "analog/r1358"
   test "analog/r1359"
   test "analog/r1360"
   test "analog/r1361"
   test "analog/r1362"
   test "analog/r1363"
   test "analog/r1364"
   test "analog/r1371"
   test "analog/r1375"
   test "analog/r1379"
   test "analog/r1383"
   test "analog/r1403"
   test "analog/r1404"
   test "analog/r1793"
   test "analog/r1888"
   test "analog/r1889"   !REV03
   test "analog/r1890"   !REV03
   test "analog/r1892"
   test "analog/r1894"
   test "analog/r1984"
   test "analog/r1985"
   test "analog/r2028"
   test "analog/r2029"
   test "analog/r2063"
   test "analog/r2067"
   test "analog/r2078"
   test "analog/r2081"
   test "analog/r2116"
   test "analog/r2117"
   test "analog/r2118"
   test "analog/r2119"
   test "analog/r2120"
   test "analog/r2121"
   test "analog/r2123"
   test "analog/r2124"
   test "analog/r2127"
   test "analog/r2128"
   test "analog/r2129"
   test "analog/r2130"
   test "analog/r2163"
   test "analog/r2164"
   test "analog/r2308"
   test "analog/r2312"
   test "analog/r2313"
   test "analog/r2314"
   test "analog/r2315"
   test "analog/r2316"
   test "analog/r2317"
   test "analog/r2318"
   test "analog/r2325"
   test "analog/r2328"
   test "analog/r2335"
   test "analog/r2336"
   test "analog/r2337"
   test "analog/r2338"
   test "analog/r2343"
   test "analog/r2344"
   test "analog/r2345"
   test "analog/r2346"
   test "analog/r2351"
   test "analog/r2467"
   test "analog/r2543"
   test "analog/r2544"
   test "analog/r2545"
   test "analog/r2685"
   test "analog/fmhr2"
   test "analog/r593"
   test "analog/fmhr4"
   test "analog/fmhr5"
   test "analog/fmhr6"
   test "analog/fmhr11"
   test "analog/fmhr26"
   test "analog/fmhr27"
   test "analog/fmhr31"
   test "analog/r2241"
   test "analog/cr8%cr_1_3"
   test "analog/cr8%cr_2_3"
   test "analog/c1336"
   test "analog/r816"
   test "analog/r2072"
   test "analog/r2073"
   test "analog/r2142"
   test "analog/r2263"
   test "analog/c3759"
   test "analog/c3766"
   test "analog/c1831"
   test "analog/fmhr12"
   test "analog/imbr12"
   test "analog/imbr18"
   test "analog/fmhr22"
   test "analog/r26"
   test "analog/r28"
   test "analog/r40"
   test "analog/fmhr25"
   test "analog/fmhr28"
   test "analog/fmhr29"
   test "analog/fmhr30"
   test "analog/fmhr38"
   test "analog/r941"
   test "analog/r942"
   test "analog/r994"
   test "analog/r1327"
   test "analog/fmhr39"
   test "analog/r2159"
   test "analog/fmhr40"
   test "analog/r138"
   test "analog/fmhr41"
   test "analog/r1017"
   test "analog/r1018"
   test "analog/r1332"
   test "analog/fmhr42"
   test "analog/fmhr44"
   test "analog/r400"
   test "analog/r1213"
   test "analog/fmhr43"
   test "analog/r519"
   test "analog/r629"
   test "analog/r2479"
   test "analog/r2480"
   test "analog/fmhr47"
   test "analog/fmhr48"
   test "analog/fmhr55"
   test "analog/fmhr56"
   test "analog/r956"
   test "analog/fmhr57"
   test "analog/fmkr6"
   test "analog/r25"
   test "analog/r34"
   test "analog/r430"
   test "analog/r435"
   test "analog/r440"
   test "analog/r441"
   test "analog/r446"
   test "analog/r447"
   test "analog/r1377"
   test "analog/r2064"
   test "analog/r2347"
   test "analog/fmkr8"
   test "analog/fmkr17"
   test "analog/fmkr20"
   test "analog/fmkr27"
   test "analog/r266"
   test "analog/r273"
   test "analog/r276"
   test "analog/r289"
   test "analog/r291"
   test "analog/r310"
   test "analog/r321"
   test "analog/r324"
   test "analog/r332"
   test "analog/r343"
   test "analog/r344"
   test "analog/r350"
   test "analog/r357"
   test "analog/r359"
   test "analog/r367"
   test "analog/r368"
   test "analog/r370"
   test "analog/r371"
   test "analog/r373"
   test "analog/r676"
   test "analog/r681"
   test "analog/r813"
   test "analog/r826"
   test "analog/r828"
   test "analog/r832"
   test "analog/r834"
   test "analog/r836"
   test "analog/r838"
   test "analog/r840"
   test "analog/r846"
   test "analog/r848"
   test "analog/r850"
   test "analog/r852"
   test "analog/r855"
   test "analog/r860"
   test "analog/r861"
   test "analog/r865"
   test "analog/r866"
   test "analog/r871"
   test "analog/r873"
   test "analog/r874"
   test "analog/r882"
!@ test "analog/r1196"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r1197"  !! Remove in EA564619 by Clyde 2019/06/06
   test "analog/r1368"
   test "analog/r1369"
   test "analog/r1374"
   test "analog/r1381"
   test "analog/r1394"
   test "analog/r1395"
   test "analog/r1419"
   test "analog/r1420"
   test "analog/r1421"
   test "analog/r1422"
   test "analog/r1423"
   test "analog/r1424"
   test "analog/r1704"
   test "analog/r1709"
   test "analog/r1720"
   test "analog/r1736"
   test "analog/r1737"
   test "analog/r1742"
   test "analog/r1751"
   test "analog/r1752"
   test "analog/r2014"
   test "analog/r2015"
   test "analog/r2126"
   test "analog/r2223"
   test "analog/r2224"
   test "analog/r2225"
   test "analog/r2448"
   test "analog/r2449"
   test "analog/r2456"
   test "analog/r2457"
   test "analog/r2458"
   test "analog/r2459"
   test "analog/fmmr1"
   test "analog/fmmr2"
   test "analog/fmmr5"
   test "analog/fmmr6"
   test "analog/fmmr7"
   test "analog/fmmr8"
   test "analog/fmmr9"
   test "analog/fmmr10"
   test "analog/fmmr41"
   test "analog/r2099"
   test "analog/r2106"
   test "analog/r2107"
   test "analog/fmsr5"
   test "analog/r1354"
   test "analog/fmsr13"
   test "analog/r1353"
   test "analog/fmtr1"
   test "analog/fmtr7"
   test "analog/r1954"
   test "analog/fmtr11"
   test "analog/imbr7"
   test "analog/r1028"
   test "analog/imbr19"
   test "analog/imbr21"
   test "analog/imbr26"
   test "analog/imbr27"
   test "analog/imbr29"
   test "analog/r1"
   test "analog/r2"
   test "analog/r7"
   test "analog/r8"
   test "analog/r11"
   test "analog/r12"
   test "analog/r610"
   test "analog/r72"
   test "analog/r92"
   test "analog/r137"
   test "analog/r414"
   test "analog/r425"
   test "analog/r438"
   test "analog/r439"
   test "analog/r485"
   test "analog/r897"
   test "analog/r898"
   test "analog/r900"
   test "analog/r901"
   test "analog/r76"
   test "analog/r95"
   test "analog/r139"
   test "analog/r488"
   test "analog/r1235"
   test "analog/r87"
   test "analog/r101"
   test "analog/r506"
   test "analog/r535"
   test "analog/r542"
   test "analog/r958"
   test "analog/r146"
   test "analog/r147"
   test "analog/r179"
   test "analog/r198"
   test "analog/r210"
   test "analog/r211"
   test "analog/r224"
   test "analog/r225"
   test "analog/r227"
   test "analog/r229"
   test "analog/r250"
   test "analog/r254"
   test "analog/r255"
   test "analog/r256"
   test "analog/r333"
   test "analog/r341"
   test "analog/r345"
   test "analog/r346"
   test "analog/r347"
   test "analog/r352"
   test "analog/r353"
   test "analog/r354"
   test "analog/r355"
   test "analog/r403"
   test "analog/r404"
   test "analog/r406"
   test "analog/r411"
   test "analog/r2156"
   test "analog/r212"
   test "analog/r230"
   test "analog/r231"
   test "analog/r263"
   test "analog/r264"
   test "analog/r340"
   test "analog/r348"
   test "analog/r351"
   test "analog/r365"
   test "analog/r366"
   test "analog/r412"
   test "analog/r413"
   test "analog/r228"
   test "analog/r236"
   test "analog/r237"
   test "analog/r238"
   test "analog/r239"
   test "analog/r1410"
   test "analog/r1443"
   test "analog/r1446"
   test "analog/r1451"
   test "analog/r1452"
   test "analog/r1456"
   test "analog/r1458"
   test "analog/r1459"
   test "analog/r1749"
   test "analog/r1918"
   test "analog/r2025"
   test "analog/r2035"
   test "analog/r2048"
   test "analog/r2052"
   test "analog/r2095"
   test "analog/r2097"
   test "analog/r2111"
   test "analog/r2158"
   test "analog/r2160"
   test "analog/r2161"
   test "analog/r2196"
   test "analog/r2197"
   test "analog/r2871"
   test "analog/r243"
   test "analog/r249"
   test "analog/r257"
   test "analog/r275"
   test "analog/r288"
   test "analog/r290"
   test "analog/r295"
   test "analog/r296"
   test "analog/r307"
   test "analog/r314"
   test "analog/r316"
   test "analog/r318"
   test "analog/r323"
   test "analog/r325"
   test "analog/r339"
   test "analog/r349"
   test "analog/r356"
   test "analog/r358"
   test "analog/r360"
   test "analog/r362"
   test "analog/r363"
   test "analog/r364"
   test "analog/r369"
   test "analog/r372"
   test "analog/r374"
   test "analog/r375"
   test "analog/r808"
   test "analog/r814"
   test "analog/r823"
   test "analog/r829"
   test "analog/r833"
   test "analog/r835"
   test "analog/r837"
   test "analog/r845"
   test "analog/r849"
   test "analog/r851"
   test "analog/r862"
   test "analog/r1702"
   test "analog/r1705"
   test "analog/r1708"
   test "analog/r1716"
   test "analog/r1719"
   test "analog/r1724"
   test "analog/r1729"
   test "analog/r1730"
   test "analog/r1735"
   test "analog/r1741"
   test "analog/r1748"
   test "analog/r1753"
   test "analog/r1756"
   test "analog/r1757"
   test "analog/r1761"
   test "analog/r1762"
   test "analog/r277"
   test "analog/r278"
   test "analog/r279"
   test "analog/r280"
   test "analog/r281"
   test "analog/r282"
   test "analog/r283"
   test "analog/r284"
   test "analog/r297"
   test "analog/r308"
   test "analog/r313"
   test "analog/r2237"
   test "analog/r299"
   test "analog/r303"
   test "analog/r304"
   test "analog/r311"
   test "analog/r312"
   test "analog/r518"
   test "analog/r924"
   test "analog/r951"
   test "analog/r964"
   test "analog/r1237"
   test "analog/r1238"
   test "analog/r2203"
   test "analog/r336"
   test "analog/r337"
   test "analog/r338"
   test "analog/r1324"
   test "analog/r1333"
   test "analog/r388"
   test "analog/r390"
   test "analog/r396"
   test "analog/r401"
   test "analog/r409"
   test "analog/r410"
   test "analog/r418"
   test "analog/r421"
   test "analog/r820"
   test "analog/r1189"
   test "analog/r1388"
   test "analog/r1392"
   test "analog/r1393"
   test "analog/r1400"
   test "analog/r1401"
   test "analog/r1402"
   test "analog/r1848"
   test "analog/r1849"
   test "analog/r1850"
   test "analog/r1851"
   test "analog/r1852"
   test "analog/r1853"
   test "analog/r448"
   test "analog/r454"
   test "analog/r461"
   test "analog/r500"
   test "analog/r2141"
   test "analog/r2150"
   test "analog/r2300"
   test "analog/r502"
   test "analog/r621"
   test "analog/r503"
   test "analog/r508"
   test "analog/r1931"
   test "analog/r2379"
   test "analog/r592"
!@ test "analog/r750"   !! Remove in EA564619 by Clyde 2019/06/06
   test "analog/r760"
!@ test "analog/r2283"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2295"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2296"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2297"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2298"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2305"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2306"  !! Remove in EA564619 by Clyde 2019/06/06
!@ test "analog/r2307"  !! Remove in EA564619 by Clyde 2019/06/06
   test "analog/r1270"
   test "analog/r1275"
   test "analog/r1283"
   test "analog/r1288"
   test "analog/r2000"
   test "analog/r853"
   test "analog/r1992"
   test "analog/r1994"
   test "analog/r1997"
   test "analog/r1999"
   test "analog/r925"
   test "analog/r965"
   test "analog/r1022"
   test "analog/r927"
   test "analog/r988"
   test "analog/r936"
   test "analog/r937"
   test "analog/r1026"
   test "analog/r1027"
   test "analog/r1116"
   test "analog/r1117"
   test "analog/r1226"
   test "analog/r1227"
   test "analog/r952"
   test "analog/r1008"
   test "analog/r957"
   test "analog/r1014"
   test "analog/r984"
   test "analog/r985"
   test "analog/r986"
   test "analog/r987"
   test "analog/r1000"
   test "analog/r1001"
   test "analog/r993"
   test "analog/r1036"
   test "analog/r997"
   test "analog/r1055"
   test "analog/r1114"
   test "analog/r1169"
   test "analog/r1232"
   test "analog/r1233"
   test "analog/r1309"
   test "analog/r1314"
   test "analog/r1315"
   test "analog/r1316"
   test "analog/r2571"
   test "analog/r1321"
   test "analog/r1356"
   test "analog/r1407"
   test "analog/r1414"
!@ test "analog/r1415"!*Add clock divider and removed the wiring by jackwu 2017/12/24
   test "analog/r1416"
   test "analog/r1417"
   test "analog/r1418"
   test "analog/r1814"
   test "analog/r1891"
   test "analog/r2039"
   test "analog/r2231"
   test "analog/r2511"
   test "analog/r2600"
   test "analog/r2663"
   test "analog/r2664"
   test "analog/r2665"
   test "analog/r1923"
   test "analog/r2191"
   test "analog/r1924"
   test "analog/r2167"
   test "analog/r1955"
   test "analog/r1972"
   test "analog/r1975"
   test "analog/r1978"
   test "analog/r2005"
   test "analog/r2192"
   test "analog/r2267"
   test "analog/r2299"
   test "analog/fmfq1%qf1"
   test "analog/fmfq1%qf2"
   test "analog/fmhq1%qf"
   test "analog/fmhq2%qf"
   test "analog/fmsq2%qf1"
   test "analog/fmsq2%qf2"
   test "analog/fmtq1%qf1"
   test "analog/fmtq1%qf2"
   test "analog/q1%qf"
   test "analog/q2%qf"
   test "analog/q17%qf"
   test "analog/q19%qf1"
   test "analog/q19%qf2"
   test "analog/q34%qf1"
   test "analog/q34%qf2"
   test "analog/q36%qf"
   test "analog/q40%qf1"
   test "analog/q40%qf2"
   test "analog/q41%qf2"
   test "analog/q70%qf1"
   test "analog/q70%qf2"
   test "analog/u58%qf1"
   test "analog/u58%qf2"
   test "analog/u59%qf1"
   test "analog/u59%qf2"
   test "analog/cr1%pin1_2"
   test "analog/cr1%pin3_4"
   test "analog/cr2%pin1_2"
   test "analog/cr2%pin3_4"
   test "analog/cr3%pin1_2"
   test "analog/cr3%pin3_4"
   test "analog/cr5%pin1_2"
   test "analog/cr5%pin3_4"
!  test "analog/cr16"! Not in BOM by Dylan 2018/4/10
!  test "analog/cr17"! Not in BOM by Dylan 2018/4/10
!  test "analog/cr18"! Not in BOM by Dylan 2018/4/10
   test "analog/cr19"
   test "analog/cr20%pin1_2"
   test "analog/cr20%pin3_4"
!  test "analog/cr23"! Not in BOM by Dylan 2018/4/10
   test "analog/cr41"
   test "analog/cr44%pin1_2"
   test "analog/cr44%pin3_4"
   test "analog/cr49%pin1_2"
   test "analog/cr49%pin3_4"
   test "analog/cr50%pin1_2"
   test "analog/cr50%pin3_4"
   test "analog/cr51%pin1_2"
   test "analog/cr51%pin3_4"
   test "analog/cr52%pin1_2"
   test "analog/cr52%pin3_4"
   test "analog/cr53%pin1_2"
   test "analog/cr53%pin3_4"
   test "analog/cr54%pin1_2"
   test "analog/cr54%pin3_4"
   test "analog/cr55%pin1_2"
   test "analog/cr55%pin3_4"
   test "analog/cr56%pin1_2"
   test "analog/cr56%pin3_4"
   test "analog/cr57%pin1_2"
   test "analog/cr57%pin3_4"
   test "analog/cr58%pin1_2"
   test "analog/cr58%pin3_4"
   test "analog/cr59%pin1_2"
   test "analog/cr59%pin3_4"
   test "analog/cr60%pin1_2"
   test "analog/cr60%pin3_4"
   test "analog/cr61%pin1_2"
   test "analog/cr61%pin3_4"
   test "analog/cr62%pin1_2"
   test "analog/cr62%pin3_4"
   test "analog/cr63%pin1_2"
   test "analog/cr63%pin3_4"
   test "analog/cr64%pin1_2"
   test "analog/cr64%pin3_4"
   test "analog/cr66%pin1_2"
   test "analog/cr66%pin3_4"
   test "analog/cr67%pin1_2"
   test "analog/cr67%pin3_4"
   test "analog/cr68%pin1_2"
   test "analog/cr68%pin3_4"
   test "analog/cr69%pin1_2"
   test "analog/cr69%pin3_4"
   test "analog/cr70%pin1_2"
   test "analog/cr70%pin3_4"
   test "analog/cr71%pin1_2"
   test "analog/cr71%pin3_4"
   test "analog/cr72%pin1_2"
   test "analog/cr72%pin3_4"
   test "analog/cr73%pin1_2"
   test "analog/cr73%pin3_4"
   test "analog/cr74%pin1_2"
   test "analog/cr74%pin3_4"
   test "analog/cr75%pin1_2"
   test "analog/cr75%pin3_4"
   test "analog/cr76%pin1_2"
   test "analog/cr76%pin3_4"
   test "analog/cr77%pin1_2"
   test "analog/cr77%pin3_4"
   test "analog/cr78%pin1_2"
   test "analog/cr78%pin3_4"
   test "analog/cr79%pin1_2"
   test "analog/cr79%pin3_4"
   test "analog/cr80%pin1_2"
   test "analog/cr80%pin3_4"
   test "analog/cr81%pin1_2"
   test "analog/cr81%pin3_4"
   test "analog/cr82%pin1_2"
   test "analog/cr82%pin3_4"
   test "analog/cr83%pin1_2"
   test "analog/cr83%pin3_4"
   test "analog/cr84%pin1_2"
   test "analog/cr84%pin3_4"
   test "analog/cr85%pin1_2"
   test "analog/cr85%pin3_4"
   test "analog/cr86%pin1_2"
   test "analog/cr86%pin3_4"
   test "analog/cr87%pin1_2"
   test "analog/cr87%pin3_4"
   test "analog/cr88%pin1_2"
   test "analog/cr88%pin3_4"
   test "analog/cr89%pin1_2"
   test "analog/cr89%pin3_4"
   test "analog/cr90%pin1_2"
   test "analog/cr90%pin3_4"
   test "analog/cr91%pin1_2"
   test "analog/cr91%pin3_4"
   test "analog/cr92%pin1_2"
   test "analog/cr92%pin3_4"
   test "analog/cr93%pin1_2"
   test "analog/cr93%pin3_4"
   test "analog/cr94%pin1_2"
   test "analog/cr94%pin3_4"
   test "analog/cr95%pin1_2"
   test "analog/cr95%pin3_4"
!@ test "analog/cr96"! Not in BOM by Dylan 2018/4/10
!@ test "analog/cr99"! Not in BOM by Dylan 2018/4/10
!@ test "analog/cr100"! Not in BOM by Dylan 2018/4/10
!@ test "analog/cr101"! Not in BOM by Dylan 2018/4/10
!@ test "analog/cr102"! Not in BOM by Dylan 2018/4/10
   test "analog/cr278%pin1_2"
   test "analog/cr278%pin3_4"
   test "analog/fmgcr2%pin1_2"
   test "analog/fmgcr2%pin3_4"
   test "analog/fmgcr3%pin1_2"
   test "analog/fmgcr3%pin3_4"
   test "analog/fmhcr1%pin3_4"
   test "analog/cr6"
   test "analog/cr9%cr_1_3"
   test "analog/cr9%cr_2_3"
   test "analog/cr22%cr_1_5"
   test "analog/cr22%cr_2_1"
   test "analog/cr22%cr_2_3"
   test "analog/cr22%cr_2_4"
   test "analog/cr22%cr_2_6"
   test "analog/cr22%cr_3_5"
   test "analog/cr22%cr_4_5"
   test "analog/cr22%cr_6_5"
   test "analog/cr24%cr_1_5"
   test "analog/cr24%cr_2_1"
   test "analog/cr24%cr_2_3"
   test "analog/cr24%cr_2_4"
   test "analog/cr24%cr_2_6"
   test "analog/cr24%cr_3_5"
   test "analog/cr24%cr_4_5"
   test "analog/cr24%cr_6_5"
   test "analog/cr25%cr_1_5"
   test "analog/cr25%cr_2_1"
   test "analog/cr25%cr_2_3"
   test "analog/cr25%cr_2_4"
   test "analog/cr25%cr_2_6"
   test "analog/cr25%cr_3_5"
   test "analog/cr25%cr_4_5"
   test "analog/cr25%cr_6_5"
   test "analog/cr26%cr_1_5"
   test "analog/cr26%cr_2_1"
   test "analog/cr26%cr_2_3"
   test "analog/cr26%cr_2_4"
   test "analog/cr26%cr_2_6"
   test "analog/cr26%cr_3_5"
   test "analog/cr26%cr_4_5"
   test "analog/cr26%cr_6_5"
   test "analog/cr27%cr_1_5"
   test "analog/cr27%cr_2_1"
   test "analog/cr27%cr_2_3"
   test "analog/cr27%cr_2_4"
   test "analog/cr27%cr_2_6"
   test "analog/cr27%cr_3_5"
   test "analog/cr27%cr_4_5"
   test "analog/cr27%cr_6_5"
   test "analog/cr30%pin3_1"
   test "analog/cr30%pin3_2"
   test "analog/cr31%cr_1_5"
   test "analog/cr31%cr_2_1"
   test "analog/cr31%cr_2_3"
   test "analog/cr31%cr_2_4"
   test "analog/cr31%cr_2_6"
   test "analog/cr31%cr_3_5"
   test "analog/cr31%cr_4_5"
   test "analog/cr31%cr_6_5"
   test "analog/cr32%cr_1_5"
   test "analog/cr32%cr_2_1"
   test "analog/cr32%cr_2_3"
   test "analog/cr32%cr_2_4"
   test "analog/cr32%cr_2_6"
   test "analog/cr32%cr_3_5"
   test "analog/cr32%cr_4_5"
   test "analog/cr32%cr_6_5"
   test "analog/cr33%cr_1_5"
   test "analog/cr33%cr_2_1"
   test "analog/cr33%cr_2_3"
   test "analog/cr33%cr_2_4"
   test "analog/cr33%cr_2_6"
   test "analog/cr33%cr_3_5"
   test "analog/cr33%cr_4_5"
   test "analog/cr33%cr_6_5"
   test "analog/cr34%cr_1_5"
   test "analog/cr34%cr_2_1"
   test "analog/cr34%cr_2_3"
   test "analog/cr34%cr_2_4"
   test "analog/cr34%cr_2_6"
   test "analog/cr34%cr_3_5"
   test "analog/cr34%cr_4_5"
   test "analog/cr34%cr_6_5"
   test "analog/cr38%cr_1_5"
   test "analog/cr38%cr_2_1"
   test "analog/cr38%cr_2_3"
   test "analog/cr38%cr_2_4"
   test "analog/cr38%cr_2_6"
   test "analog/cr38%cr_3_5"
   test "analog/cr38%cr_4_5"
   test "analog/cr38%cr_6_5"
   test "analog/cr40%cr_1_5"
   test "analog/cr40%cr_2_1"
   test "analog/cr40%cr_2_3"
   test "analog/cr40%cr_2_4"
   test "analog/cr40%cr_2_6"
   test "analog/cr40%cr_3_5"
   test "analog/cr40%cr_4_5"
   test "analog/cr40%cr_6_5"
   test "analog/fmgcr1%cr_2_4"
   test "analog/fmgcr1%cr_2_6"
   test "analog/fmgcr1%cr_4_5"
   test "analog/fmgcr1%cr_6_5"
   test "analog/fmhcr10%pin1_3"
   test "analog/fmhcr11%pin3_2"
   test "analog/fmhcr12%pin1_3"
   test "analog/fmhcr12%pin3_2"
   test "analog/cr7"
   test "analog/cr10%cr"
   test "analog/fmhcr2"
   test "analog/fmhcr5"
   test "analog/fmhcr6"
   test "analog/fmhcr7"
   test "analog/fmhcr8"
   test "analog/fmhcr13"
   test "analog/fmhq3%q1"
   test "analog/fmhq3%q2"
   test "analog/q3%q1"
   test "analog/q3%q2"
   test "analog/q4%q1"
   test "analog/q4%q2"
   test "analog/q7"
   test "analog/q8%q1"
   test "analog/q8%q2"
   test "analog/q9"
   test "analog/q10%q1"
   test "analog/q10%q2"
   test "analog/q16%q1"
   test "analog/q16%q2"
   test "analog/q21"
   test "analog/q22%q1"
   test "analog/q22%q2"
   test "analog/q23%q1"
   test "analog/q23%q2"
   test "analog/q24%q1"
   test "analog/q24%q2"
   test "analog/q25%q1"
   test "analog/q25%q2"
   test "analog/q26%q1"
   test "analog/q26%q2"
   test "analog/q27%q1"
   test "analog/q27%q2"
   test "analog/q28%q1"
   test "analog/q28%q2"
   test "analog/q29%q1"
   test "analog/q29%q2"
   test "analog/q30%q1"
   test "analog/q30%q2"
   test "analog/q31%q1"
   test "analog/q31%q2"
   test "analog/q42"
   test "analog/q43%q1"
   test "analog/q43%q2"
   test "analog/q18"
   test "analog/q44"
   test "analog/cr10%ds"
   test "analog/u31%cr"
subend

sub VectorlessTest (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   test "testjet"
subend

sub Polarity_Check (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Connect_Check (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Analog_Cluster_Tests (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Verify_Grounds (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Pre_Powered_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   unpowered
   powered
   print tab(5);chr$(27)&"&v7STesting FET....."
   test "analog/q17%pwr"                                ! NCH
   test "analog/fmfq1%pwr1"                             ! NCH
   test "analog/fmfq1%pwr2"                             ! NCH
   test "analog/fmhq2%pwr"                              ! NCH
   test "analog/fmsq2%pwr1"                             ! NCH
   test "analog/fmsq2%pwr2"                             ! NCH
   test "analog/fmtq1%pwr1"                             ! NCH
   test "analog/fmtq1%pwr2"                             ! NCH
   test "analog/q1%pwr"                                 ! NCH
   test "analog/q2%pwr"                                 ! NCH
   test "analog/q19%pwr1"                               ! NCH
   test "analog/q19%pwr2"                               ! NCH
   test "analog/q34%pwr1"                               ! NCH
   test "analog/q34%pwr2"                               ! NCH
   unpowered
   powered
   test "analog/fmhq1%pwr"                              ! NCH
!  test "analog/q36%pwr"                                ! NCH
!  test "analog/q37%pwr"                                ! NCH
   test "analog/q40%pwr1"                               ! NCH
   test "analog/q40%pwr2"                               ! NCH
   test "analog/q41%pwr2"                               ! NCH
   test "analog/q70%pwr1"                               ! NCH
   test "analog/q70%pwr2"                               ! NCH
   test "analog/u58%pwr1"                               ! PCH
   test "analog/u58%pwr2"                               ! PCH
   test "analog/u59%pwr1"                               ! PCH
   test "analog/u59%pwr2"                               ! PCH
   unpowered
subend

sub Setup_Power_Supplies (Status_Code, Message$)
global Status
global Pslimit, Psgroup(*), True, False
global PMC_On

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   auxconnect 5|wait 1|unpowered|faoff|wait 1
   powered|cps
   dps 4,8,12,16   !Borg 2018/04/08

   gpconnect "SPI_GOLDEN_WP" to "GND"                   ! disable u79
   gpconnect "UNNAMED_247_N25QXX_I38_WPMVPPDQ2" to "GND"! disable u80
   gpconnect "SPI_CFG_WP" to "GND"                      ! disable u224
   gpconnect "JTAG_BUF_EN_L" to "GND"                   ! JTAG BUFFER

!   gpconnect  20648 to 20649
!   gpconnect  20650 to 20651
!   gpconnect  10622 to 10623
!   wait 5
!   gpdisconnect  20648 from 20649
!   gpdisconnect  20650 from 20651
!   gpdisconnect  10622 from 10623

   sps 13, 12.00, 2.0   !power on fan
   wait 500m
   !1--5--9 (18+18+18=54V) N54V_RTN
   !2--6--10(18+18+18=54V)
   !3--7--11(18+18+18=54V)

   sps 1,18.00,2.0;optimize| sps 5,18.00,2.0;optimize| sps 9,18.00,2.0;optimize
!! power supply increased due to parallel supply
   sps 2,18.10,2.0;optimize| sps 6,18.10,2.0;optimize| sps 10,18.10,2.0;optimize
!! power supply increased due to parallel supply
   sps 3,18.10,2.0;optimize| sps 7,18.10,2.0;optimize| sps 11,18.10,2.0;optimize


   Pslimit = pslimit
   pass device
   Psgroup(1) = 819     ! 333 (hex)
   Psgroup(2) = 3276     ! CCC (hex)
   Disabled = False
   for I = 1 to 2
      A = binand (Pslimit,Psgroup(I))
      if not bineor (A,Psgroup(I)) then
         if not Disabled then
            dps
            fail device
            Disabled = True
         end if
      else
         Pslimit = binand (Pslimit,bincmp(Psgroup(I)))
      end if
   next I
   if dutfailed then
      I = 1
      for Pscount = 1 to 12
         if binand (Pslimit,I) then
            report "Power Supply Number "
            report Pscount
            report "In Current Limit"
         end if
         I = 2*I
      next Pscount
      report "Power Supplies may be in parallel."
      report "________________________________________"
      report "Check for backwards"
      report "IC's or Capacitors."
      report "________________________________________"
   end if
!   if PMC_On then
    ! Turn on PMC here
    ! spmc <Channel Id >,<Voltage Lower Limit>
    ! spmc reset
    ! spmc interrupt <on/off>
    ! rpmc <Channel Id>,<failure flag variable>
!   end if

  Start_t = msec
  wait 35
!loop
!  gpconnect  20648 to 20649
 ! wait 100m
!  gpdisconnect  20648 from 20649
  wait 1
 ! gpconnect  20650 to 20651
 ! wait 500m
 ! gpdisconnect  20650 from 20651
 ! wait 1

   rps 1, V, I1|print V, I1
   rps 2, V, I2|print V, I2
   rps 3, V, I3|print V, I3

  Isum= I1+I2+I3 |print Isum
  print tab(5);"Total current:"; Isum;"A,Waiting...";(msec-Start_t)/1000;"s"
!  if Isum > 0.7 then
!  print tab(5);"Power up OK! Testing continue...."
!  goto P_check
!  else
!  print tab(5);"Power up failed!"
!  call Disconnect_Power_On_Board
!  unpowered | unpowered |unpowered | unpowered !pause
!  end if
P_check:

   test "analog/pwr_check"
   test "analog/u77_freq"                               ! 33.000MHz
   test "digital/u90"        !~OK!3.3V/1.05V            ! 74AVC2T45
   test "digital/u91"        !~OK!3.3V/1.05V            ! 74AVC2T45
   test "digital/u96"        !~OK!2.5V/1.05V            ! PCA9617
   test "digital/u103"       !~OK!2.5V                  ! 34C04

subend


sub Setup_Power_Supplies_pro (Status_Code, Message$)
global Status
global Pslimit, Psgroup(*), True, False
global PMC_On

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   auxconnect 5|wait 1|unpowered|faoff|wait 1
!  test "pins_long"
!  test "pins_short"
   powered|cps
   dps 4,8,12,16   !Borg 2018/04/08

   gpconnect "SPI_GOLDEN_WP" to "GND"                   ! disable u79
   gpconnect "UNNAMED_247_N25QXX_I38_WPMVPPDQ2" to "GND"! disable u80
   gpconnect "SPI_CFG_WP" to "GND"                      ! disable u224
   gpconnect "JTAG_BUF_EN_L" to "GND"                   ! JTAG BUFFER

!   gpconnect  20648 to 20649
!   gpconnect  20650 to 20651
!!   gpconnect  10622 to 10623
!   wait 5
!   gpdisconnect  20648 from 20649
!   gpdisconnect  20650 from 20651
!   gpdisconnect  10622 from 10623

   sps 13, 12.00, 2.0   !power on fan
   wait 500m
   !1--5--9 (18+18+18=54V) N54V_RTN
   !2--6--10(18+18+18=54V)
   !3--7--11(18+18+18=54V)

   sps 1,18.00,2.0;optimize| sps 5,18.00,2.0;optimize| sps 9,18.00,2.0;optimize
!! power supply increased due to parallel supply
   sps 2,18.10,2.0;optimize| sps 6,18.10,2.0;optimize| sps 10,18.10,2.0;optimize
!! power supply increased due to parallel supply
   sps 3,18.10,2.0;optimize| sps 7,18.10,2.0;optimize| sps 11,18.10,2.0;optimize


   Pslimit = pslimit
   pass device
   Psgroup(1) = 819     ! 333 (hex)
   Psgroup(2) = 3276     ! CCC (hex)
   Disabled = False
   for I = 1 to 2
      A = binand (Pslimit,Psgroup(I))
      if not bineor (A,Psgroup(I)) then
         if not Disabled then
            dps
            fail device
            Disabled = True
         end if
      else
         Pslimit = binand (Pslimit,bincmp(Psgroup(I)))
      end if
   next I
   if dutfailed then
      I = 1
      for Pscount = 1 to 12
         if binand (Pslimit,I) then
            report "Power Supply Number "
            report Pscount
            report "In Current Limit"
         end if
         I = 2*I
      next Pscount
      report "Power Supplies may be in parallel."
      report "________________________________________"
      report "Check for backwards"
      report "IC's or Capacitors."
      report "________________________________________"
   end if
!   if PMC_On then
    ! Turn on PMC here
    ! spmc <Channel Id >,<Voltage Lower Limit>
    ! spmc reset
    ! spmc interrupt <on/off>
    ! rpmc <Channel Id>,<failure flag variable>
!   end if

  Start_t = msec
  wait 15
!loop
!  gpconnect  20648 to 20649
!  wait 100m
!  gpdisconnect  20648 from 20649
  wait 1

   rps 1, V, I1|print V, I1
   rps 2, V, I2|print V, I2
   rps 3, V, I3|print V, I3

  Isum= I1+I2+I3 |print Isum
  print tab(5);"Total current:"; Isum;"A,Waiting...";(msec-Start_t)/1000;"s"

  test "analog/pwr_check_pro"
subend



sub Cycle_Power_On_Board
global PowerMsg$
global Failed_In_Power_Supplies
   call Disconnect_Power_On_Board
   call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
subend

sub Disconnect_Power_On_Board
global PMC_On
!   gpconnect  10622 to 10623
    gpconnect  20648 to 20649
!   gpconnect  20650 to 20651
   dps
   unpowered|faon|wait 1|auxdisconnect all|wait 1|faoff
   wait 5
!  gpdisconnect  10622 from 10623
    gpdisconnect  20648 from 20649
!   gpdisconnect  20650 from 20651

    ! Turn off PMC for all or selected channels here
    ! spmc <Channel Id> off
    ! spmc off
   !end if
subend

sub BScan_Powered_Shorts_Tests (Status_Code, Message$)
global Status

!  if Message$ <> "" then  print tab(5);Message$
!  Status = Status_Code
subend

sub BScan_Interconnect_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
   looptest 3 "digital/u29_fmgu3_aio"     !~OK
   looptest 3 "digital/u29_fmgu3"         !~OK
   looptest 3 "digital/u29_fmgu3_dis"     !~OK
subend

sub BScan_Incircuit_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
   test "digital/u23_connect"       !~OK   !3.3V,1.0V
   test "digital/u22_connect"       !~OK   !3.3V,1.0V
   test "digital/u21_connect"       !~OK   !3.3V,1.0V
   test "digital/u20_connect"       !~OK   !3.3V,1.0V
   test "digital/u19_connect"       !~OK   !3.3V,1.0V
   test "digital/u18_connect"       !~OK   !3.3V,1.0V
   test "digital/fmgu3_connect"     !~OK   !3.3V,1.5V,0.9V
   test "digital/u73_connect"       !~OK   !3.3V,1.5V,1.2V,1.05V
!! test "digital/u15_connect"       !!cause power down jackwu 2018/01/10
!! test "digital/u73_p_connect"     !!cause power down jackwu 2018/01/10
!! test "digital/u29_connect"       !!cause power down jackwu 2018/01/10
!! test "digital/u57_connect"       !!cause power down jackwu 2018/01/10
!! test "digital/u57_u57_dis"       !!cause power down jackwu 2018/01/10
subend

sub BScan_Silicon_Nails_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
!@ test "digital/fmmu9"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu8"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu3"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu7"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu6"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu5"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu4"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu2"!unstable,removed by jackwu 2018/01/10
!@ test "digital/fmmu1"!unstable,removed by jackwu 2018/01/10
subend

sub Cover_Extend_Tests (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$

!------------------------------------------------------------------------------
!print "Test Programmer Action Reminder:"
!print "Evaluate, act, and then delete this 'pause' section."

!pause ! Comment out pause and print statements above when evaluation complete.

!------------------------------------------------------------------------------
! This 'pause' section is placed here to remind the test programmer
! that the Cover-Extend tests must be debugged before they can
!
! When you have debugged the Cover-Extend test, you should
! comment out the print/pause statements above.
!------------------------------------------------------------------------------

!   Status = Status_Code
!   call BScan_Disable_All_Chains
!   if boardfailed then
!      print "BScan disable failure; Cover-Extend tests skipped"
!      subexit
!   end if
subend

sub BScan_Disable_All_Chains
!------------------------------------------------------------------------------
print "Test Programmer Action Reminder:"
print "Evaluate, act, and then delete this 'pause' section."

pause ! Comment out pause and print statements above when evaluation complete.

!------------------------------------------------------------------------------
! This 'pause' section is placed here to remind the test programmer
! that the Boundary-Scan disable tests depend upon their respective
! TCK/TMS signals being held in a stable state while other testing
! is done.  This assures that the disabled state of the Boundary-Scan
! chain is not accidentally lost.  Board level circuitry may
! interfere with the persistance of the disabled state.  You may
! need to take additional measures;  for example, you may place your
! own pullup/down resistor in the fixture to assure a stable TMS
! and/or TCK, or utilize a GP relay to disable some TCK oscillator, etc.
! For further explanation, see the Boundary-Scan Manual for the
! section titled 'Maintaining Persistance of Boundary-Scan Disables'.
!
! When you have assured persistance of the disable state, you should
! comment out the print/pause statements above.  It would also be a
! good idea to briefly document here the measures you may have taken
! (if any were needed) to assure persistance of the disables.
!------------------------------------------------------------------------------

   test "digital/u29_fmgu3_dis"
   test "digital/u57_u57_dis"
subend

sub Digital_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
   gpdisconnect "JTAG_BUF_EN_L" from "GND"
   wait 50m
   test "digital/u87"        !~OK!3.3V                  ! 74CBTLV3257
   test "digital/u8"         !~OK!3.3V                  ! MAX3232
   test "digital/u32"        !~OK!3.3V                  ! NC7SZ04P5X
   test "digital/u36"        !~OK!3.3V/1.8V             ! 74AVC2T45
   test "digital/u43"        !~OK!3.3V                  ! NC7WV04P6X
   test "digital/u86"        !~OK!3.3V                  ! 74CBTLV3257
   test "digital/u108"       !~OK!3.3V                  ! MCU
!! test "digital/u123" !Not in BOM jackwu 2018/04/10
   test "digital/fmgu1"      !~OK!3.3V                  ! MAX3078
   test "digital/fmku3"      !~OK!3.3V                  ! M25P40
!! test "digital/u79" !!cause power down jackwu 2018/01/10
!! test "digital/u80" !!cause power down jackwu 2018/01/10
!! test "digital/u81" !!cause power down jackwu 2018/01/10
!! test "digital/u95" !!cause power down jackwu 2018/01/10
!! test "digital/u97" !!cause power down jackwu 2018/01/10
!! test "digital/u104"!!cause power down jackwu 2018/01/10
!! test "digital/u224"!!cause power down jackwu 2018/01/10
!! test "digital/u26"    !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u51"    !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u63"    !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u66"    !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u72"    !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u109"   !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u126"   !!JTAG buffer short probe jackwu 2018/01/10
!! test "digital/u40"    !!Clock buffer,frequency test in u17 jackwu 2018/01/10
!! test "digital/u77"    !!Clock buffer,frequency test in u17 jackwu 2018/01/10
!! test "digital/u10"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u89"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u62"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u47"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u48"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u46"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u54"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u61"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u65"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u45"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u53"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u60"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u64"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u56"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u12"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u30"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u67"    !!ISO circuit jackwu 2018/01/10
!! test "digital/u69"    !!ISO circuit jackwu 2018/01/10
subend


sub Program_IR3570 (Status_Code, Message$)
global IR_IMBU1(*)
global IR_IMBU1_POINTER(*)
global IR_FMCU1(*)
global IR_FMCU1_POINTER(*)
global IR_Pointer_A6, IR_Pointer_A7
global Status
   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
   print tab(6); " Pre-verify IMBU1 IR3570"
   looptest 3 "programming/imbu1_ver"
   if not dutfailed then goto SKIP_IMBU1_PGM
   clear failures|report clear
   print tab(6); " Programming IMBU1 IR3570"
   test "programming/imbu1_capture";IR_IMBU1(*)
   if dutfailed then goto SKIP_IMBU1_PGM
   call Pointer_Calculate (IR_IMBU1(*),IR_IMBU1_POINTER(*))

   if IR_Pointer_A6 = 3 or IR_Pointer_A7 = 9 then goto SKIP_IMBU1

   if IR_Pointer_A7 = 3 or IR_Pointer_A7 = 4 or IR_Pointer_A7 = 5 or IR_Pointer_A7 = 6 or IR_Pointer_A7 = 7 or IR_Pointer_A7 = 8 then goto SKIP_IMBU1_PGM
   test "programming/imbu1_prog";IR_IMBU1_POINTER(*)
   looptest 3 "programming/imbu1_ver"
   SKIP_IMBU1_PGM:

   print tab(6); " Pre-verify FMCU1 IR3570"
   looptest 3 "programming/fmcu1_ver"
   if not dutfailed then goto SKIP_FMCU1_PGM
   clear failures|report clear
   print tab(6); " Programming FMCU1 IR3570"
   test "programming/fmcu1_capture";IR_FMCU1(*)
   if dutfailed then goto SKIP_FMCU1_PGM
   call Pointer_Calculate (IR_FMCU1(*),IR_FMCU1_POINTER(*))

   if IR_Pointer_A6 = 3 or IR_Pointer_A7 = 9 then goto SKIP_FMCU1

   if IR_Pointer_A7 = 3 or IR_Pointer_A7 = 4 or R_Pointer_A7 = 5 or IR_Pointer_A7 = 6 or IR_Pointer_A7 = 7 or IR_Pointer_A7 = 8 then goto SKIP_FMCU1_PGM
   test "programming/fmcu1_prog";IR_FMCU1_POINTER(*)
   looptest 3 "programming/fmcu1_ver"
   SKIP_FMCU1_PGM:
     goto END

   SKIP_IMBU1:
    test "programming/imbu1_limit"
     goto END
   SKIP_FMCU1:
    test "programming/fmcu1_limit"
   END:

subend

sub Pointer_Calculate (IR(*), IR_POINTER(*))
global IR_REG$(*)

   for K = 0 to 2
     Char_Data$=""
    for G = 0 to 7
        B = (K * 8) + G
        Char_Data$=Char_Data$ & val$(IR(B))
     next G
     Int_Data  = bti ( Char_Data$)
     Hex_Data$ = ith$(Int_Data)
     if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$
     IR_REG$(K) = Hex_data$
   next K

   Reg_71 = binior (hti(IR_REG$(0)), 4)
   Reg_A6 = binand (hti(IR_REG$(1)),hti("07"))
   Reg_A7 = binand (hti(IR_REG$(2)),hti("0F"))

   if Reg_A6 = 7 then IR_Pointer_A6 = 0
   if Reg_A6 = 0 then IR_Pointer_A6 = 1
   if Reg_A6 = 1 then IR_Pointer_A6 = 2
   if Reg_A6 > 1 and Reg_A6 < 7 then IR_Pointer_A6 = 3 !none left
   if Reg_A7 = 15 then IR_Pointer_A7 = 0
   if Reg_A7 = 0 then IR_Pointer_A7 = 1
   if Reg_A7 = 1 then IR_Pointer_A7 = 2
   if Reg_A7 = 2 then IR_Pointer_A7 = 3
   if Reg_A7 = 3 then IR_Pointer_A7 = 4
   if Reg_A7 = 4 then IR_Pointer_A7 = 5
   if Reg_A7 = 5 then IR_Pointer_A7 = 6
   if Reg_A7 = 6 then IR_Pointer_A7 = 7
   if Reg_A7 = 7 then IR_Pointer_A7 = 8
   if Reg_A7 > 7 and Reg_A7 < 15 then IR_Pointer_A7 = 9 !none left

   print IR_Pointer_A6
   print IR_Pointer_A7

   if IR_Pointer_A6 = 3 or IR_Pointer_A7 = 9 then
     print "Programming is over limit!!!"

   end if

   IR_POINTER(0) = binand(shift(Reg_71,7),1)
   IR_POINTER(1) = binand(shift(Reg_71,6),1)
   IR_POINTER(2) = binand(shift(Reg_71,5),1)
   IR_POINTER(3) = binand(shift(Reg_71,4),1)
   IR_POINTER(4) = binand(shift(Reg_71,3),1)
   IR_POINTER(5) = binand(shift(Reg_71,2),1)
   IR_POINTER(6) = binand(shift(Reg_71,1),1)
   IR_POINTER(7) = binand(shift(Reg_71,0),1)
   IR_POINTER(8) = binand(shift(IR_Pointer_A7,3),1)
   IR_POINTER(9) = binand(shift(IR_Pointer_A7,2),1)
   IR_POINTER(10) = binand(shift(IR_Pointer_A7,1),1)
   IR_POINTER(11) = binand(shift(IR_Pointer_A7,0),1)
   IR_POINTER(12) = binand(shift(IR_Pointer_A6,2),1)
   IR_POINTER(13) = binand(shift(IR_Pointer_A6,1),1)
   IR_POINTER(14) = binand(shift(IR_Pointer_A6,0),1)
subend

sub Program_tps53659
global Status

   safeguard cool
   print tab(8);"Programming/Verifying TPS53659"
!   pause
  test "tps53659/fmau1_prog_ver"
subend

sub Program_34c04
global Status

   safeguard cool
   print tab(8);"Programming/Verifying eeprom (U103 at34c04)"
  !pause
   test "programming/u103_wr"
 ! call Read_eeprom_u103
subend


sub Read_EEprom_u103

   global Serial$
   dim Read_Data_u103(4096)

   !! Start read out board 1 EEprom data
   assign @EE_data1 to "D:/FRU_data/73-18275-05/"&Serial$;write
   assign @EE_data2 to "EE_Data1_Chr_u103";write

      safeguard none
    ! pause
      test "programming/u103_rd";Read_Data_u103(*)

      !Convert Data Array to Data String
      for K = 0 to 511     ! 4096
        Char_Data$=""
        for G = 0 to 7
           B = (K * 8) + G
           Char_Data$=Char_Data$ & val$(Read_Data_u103(B))
        next G
        Int_Data  = bti ( Char_Data$)
        Hex_Data$ = ith$(Int_Data)
        if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

        ! Output to file
        ! EE_data1 addr and data in hex
        output @EE_data1;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

        ! EE_data2 addr and data in integers and chracters
        if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
         output @EE_data2;"   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
        else
         output @EE_data2;"   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
        end if

      next K

      assign @EE_data1 to *
      assign @EE_data2 to *

subend



sub Functional_Tests (Status_Code, Message$)
global AssyNum$
global Option
global Status

global HDR1(*),EE_D1(*),EE_R1(*),XSUM1(*)
global HDR2(*),EE_D2(*),EE_R2(*),XSUM2(*)
global HDR3(*),EE_D3(*),EE_R3(*),XSUM3(*)
global HDR4(*),EE_D4(*),EE_R4(*),XSUM4(*)
global HDR5(*),EE_D5(*),EE_R5(*),XSUM5(*)
global HDR6(*),EE_D6(*),EE_R6(*),XSUM6(*)
global HDR7(*),EE_D7(*),EE_R7(*),XSUM7(*)
global HDR8(*),EE_D8(*),EE_R8(*),XSUM8(*)



global Serial$

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code

 safeguard cool
 call Convert_Serial_Number(Serial$)
 call EE_Setup_u105
  wait 2
  print tab(1);chr$(27)&"&v2S Programming Data1 to u105"
  test "digital/u105%pro_p1";HDR1(*),EE_D1(*),XSUM1(*),EE_R1(*)
  if dutfailed then
   clear failures|report clear
   pass device
   print tab(1);chr$(27)&"&v2S Programming Data1_new to u105"
   test "digital/u105%pro_p1_new";HDR1(*),EE_D1(*),XSUM1(*),EE_R1(*)
   print tab(1);chr$(27)&"&v2S Programming Data2_new to u105"
   test "digital/u105%pro_p2_new";HDR2(*),EE_D2(*),XSUM2(*),EE_R2(*)
   print tab(1);chr$(27)&"&v2S Programming Data3_new to u105"
   test "digital/u105%pro_p3_new";HDR3(*),EE_D3(*),XSUM3(*),EE_R3(*)
  else
   print tab(1);chr$(27)&"&v2S Programming Data2 to u105"
   test "digital/u105%pro_p2";HDR2(*),EE_D2(*),XSUM2(*),EE_R2(*)
   print tab(1);chr$(27)&"&v2S Programming Data3 to u105"
   test "digital/u105%pro_p3";HDR3(*),EE_D3(*),XSUM3(*),EE_R3(*)
  end if

 if dutfailed then
 print tab(5);chr$(27)&"&v1S Programming Data to u105 FAILED"
 else
 print tab(5);chr$(27)&"&v2S Programming Data to u105 PASSED"
 end if
 call Read_EEprom_u105

subend

sub Analog_Functional_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code

!------------------------------------------------------------------------------
! Please note that all the Enhancement MOSFET tests have been commented out
! during testplan generation to prevent potential damage to the board.
! Uncomment the required tests and ensure that the board under test is
! NOT powered up while the Enhancement MOSFET tests are called.
!------------------------------------------------------------------------------

   test "analog/b2a"    !BAT
   test "analog/u88"    !V3P3_SLEW
   test "analog/u37"    !ISO_IBC_54N_RET
   test "analog/fmhu1"  !ISO_12V_BIAS_VOUT
   test "analog/imbu2"  !P1_05V,P1_2VDDQ
   test "analog/u28"    !P0_6V_DDR4_0_VTT
   test "analog/fmcu2"  !P1_8V_CORE
   test "analog/fmcu3"  !P1_8V_CORE
   test "analog/fmau2"  !P0_91V_VDD_DOP0
   test "analog/fmau3"  !P0_91V_VDD_DOP0
   test "analog/u82"    !P1V
   test "analog/fmau4"  !P1_1V_SREF_DOP
!! test "analog/u76"    !ISO circuit jackwu 2018/01/10
!! test "analog/fmhu4"  !ISO circuit jackwu 2018/01/10
   test "analog/u55"    !P1_8V
!! test "analog/fmhu5"  !ISO circuit jackwu 2018/01/10
   test "analog/fmsu1"  !P1_7V
   test "analog/u49"    !P5V
   test "analog/u50"    !P1_2V
   test "analog/u85"    !P2_5V
   test "analog/u13"    !P0_85V_SER_A_DOP
   test "analog/u84"    !P3_3V
   test "analog/fmfu1"  !P1_5V
   test "analog/fmtu1"  !P1_3V
   test "analog/u25"    !V_IBC_8.1V
!! test "analog/u31"    !ISO circuit jackwu 2018/01/10
!! test "analog/u52"    !ISO circuit jackwu 2018/01/10

   sps 15, 3.3, 1.0
   wait 500m
   test "analog/u17"  !cover u70,u14                    ! 156.25M
!! test "analog/fmgy1" !test commented in testorder jackwu 2018/01/10
!! test "analog/fmky1" !test commented in testorder jackwu 2018/01/10
!! test "analog/y4"    !test commented in testorder jackwu 2018/01/10
!! test "analog/y5"    !test commented in testorder jackwu 2018/01/10
!! test "analog/y8"    !test commented in testorder jackwu 2018/01/10
!! safeguard cool
!! test "mixed/fmau1"  !test commented in testorder jackwu 2018/01/10
!! test "mixed/fmcu1"  !test commented in testorder jackwu 2018/01/10
!! test "mixed/imbu1"  !test commented in testorder jackwu 2018/01/10
!! test "analog/u68" !test commented in testorder jackwu 2018/01/10
subend

sub Program_Flash (Device$, Status_Code, Message$)
global Status
global Report_level$, Logging

  if Device$ = "" then  subexit
  if Message$ <> "" then  print tab(5);Message$
  Status = Status_Code

  ! Verify Manufacturer ID and device ID codes.
  ! The ID test should be executed in digital for ICT purposes.
  test "digital/" & Device$ & "%id"
  if dutfailed then
    print tab(15); Device$; " : Device ID failed"
    subexit ! if the wrong device is installed, exit the program subroutine
  end if

  !remove reporting and logging while verifying device status
  Report_level$ = rli$
  report level is none
  if Logging then
    !log level is none
    log level is all
  end if
  print tab(8); "Verifying Status"
  safeguard none  !flash! This board meets design for On-Board Programming
                  !       criteria for safeguard none to be safe
                  !       Programming runs very slowly with safeguard on

  !flash! Comment the appropriate crc test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%crc"
  if not dutfailed then
    print tab(15); Device$; " : Device pre-programmed"
    call Cleanup_Flash
    subexit  ! the device is already properly programmed, exit subroutine
  else
    pass device  ! clears dutfailed, boardfailed if only failure
    print tab(15); Device$; " : Contains incorrect data"
  end if

  ! Verify device is blank.
  !flash! Comment the appropriate blank test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%blank"
  if dutfailed then
    pass device  ! clears dutfailed, boardfailed if only failure
    print tab(15); Device$; " : Not blank"
    print tab(8); "Erasing"
    !flash! call Setup_Power_Supplies_Program  ! add any necessary programming
                                               ! voltages to a new subroutine
    !flash! Comment the appropriate erase test(s) in Digital_Tests subroutine
    test "digital/" & Device$ & "%erase"
    if not dutfailed then
      print tab(8); "Erase complete"
    end if
  end if
  ! Some older devices may need two erase sequences. If erase fails
  ! twice on only one board, continue to program all. The final CRC
  ! check will determine the viability of the erase program sequence

  if dutfailed then
    pass device  ! clears dutfailed, boardfailed if only failure
    print tab(15); Device$; " : Needed to be erased twice"
    test "digital/" & Device$ & "%erase"
    if dutfailed then
      call Cleanup_Flash   !flash! move above erase test if full report
                           !       of failing erase tests is desired
      print tab(15); Device$; " : Erase Failed"
      subexit  ! if the device cannot be erased
    end if          !if dutfailed second erase
    print tab(8); "Erase complete"
  end if            !if dutfailed first erase
  print tab(8); "Programming"
  A=msec
  !flash! Comment the appropriate program test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%program"
  B = (msec-A)/1000
  if not dutfailed then
    print tab(15); "Programming complete in"; B;" seconds"
  else
    print tab(15); "Programming Failed"
    pass device
  end if
  !flash! call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
  !flash! if dutfailed then
  !flash!   print "Power supplies limited"
  !flash!   call Cleanup_Flash
  !flash!   subexit
  !flash! end if
  call Cleanup_Flash  !flash! move above program test for full reporting
  print tab(8); "Verifying Data"
  !flash! Comment the appropriate crc test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%crc"
  if dutfailed then
    print tab(15); Device$; " : Contains incorrect data"
  else
    print tab(15); Device$; " : Contains correct data"
  end if
subend

def fnPinsfailed (Message$)

   if Message$ <> "" then  print tab(5);Message$
   Pins_failed_flag = 0
   gpconnect "P3_3V_RTC" to "CR8_3"
   gpconnect "UNNAMED_75_CR1632_I6_PLUS" to "R753_1"
   gpconnect "UNNAMED_75_DIODEDUALCK_I8_A2" to "R753_2"
   gpconnect "CPU_DCPRTC" to "C298_1"

   test "pins"
   if dutfailed then Pins_failed_flag = 1
   return Pins_failed_flag
fnend

sub ScanWorks_Setup
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
   testhead cleanup
subend

sub ScanWorks_Pretest
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status, Failed_In_SW_Testing

!   Status = Failed_In_SW_Testing
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Cleanup
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
   scanworks reset
subend

sub ScanWorks_Scan_Path_Verify_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Interconnect_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Mem_Interconnect_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Cluster_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Mem_BIST (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Device_Programming (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Flash_Programming (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

! End of Testplan Writer Generated Testplan.



sub EE_Setup_u105

global Serializing, Serial_Num_Writing
global HDR1(*),EE_D1(*),EE_R1(*),XSUM1(*)
global HDR2(*),EE_D2(*),EE_R2(*),XSUM2(*)
global HDR3(*),EE_D3(*),EE_R3(*),XSUM3(*)
global HDR4(*),EE_D4(*),EE_R4(*),XSUM4(*)
global HDR5(*),EE_D5(*),EE_R5(*),XSUM5(*)
global HDR6(*),EE_D6(*),EE_R6(*),XSUM6(*)
global HDR7(*),EE_D7(*),EE_R7(*),XSUM7(*)
global HDR8(*),EE_D8(*),EE_R8(*),XSUM8(*)

global Mem_Table(*)
global Read_Data(*)
global Option ,Board$, Board_Rev$
global Check_EEPROM,True,False,Serial$
global Board_BOM$
dim Header1(0:15),Header2(0:15),Header3(0:15),Header4(0:15)
dim Header5(0:15),Header6(0:15),Header7(0:15),Header8(0:15)
dim Test(1:20)
dim Mac_Temp$(1:20)

!################################################################### #####!
!** SPROM COMMON BLOCK                                                   !
!** BLOCK 1  in WORD = (16 bits)                                         !
!################################################################### #####!
  print ""
  print tab(5); "IDEPROM PROGRAM VERSION"
  print tab(5); "-----------------------"

  Block_sig_0_1 = hti("ABAB") ! Hex           ! Byte 00-01 ! Address 0

  Block_ver1 = 3     ! Dec                    ! Byte 02    ! Address 1
  Block_len1 = 160   ! Dec                    ! Byte 03    ! Address 1

  Block_ver_len_2_3 = shift(Block_ver1,-8) + Block_len1

  Check_sum_4_5   = 0    ! Dec                ! Byte 04-05 ! Address 2
  Eprom_size_6_7  = 65535 ! Dec               ! Byte 06-07 ! Address 3
  Block_count_8_9 = 3    ! Dec                ! Byte 08-09 ! Address 4

!!====================================================== ======
!* FRU CODE : FABRIC
!!====================================================== ======
  Fru_maj_10_11 = hti("6003")  ! Hex          ! Byte 0A-0B ! Address 5
  Fru_min_12_13 = hti("0000")  ! Hex          ! Byte 0C-0D ! Address 6

!!====================================================== ======
!* OEM String : Fixed "Cisco Systems"
!!====================================================== ======
  OEM_Str$ = "Cisco Systems, Inc."            ! Byte 0E-21 ! Address 7 - 16
  call Chklength_S(OEM_Str$,20)

!!====================================================== ======
!! Product Number
!!====================================================== ======
  Prod_Num$ = "N9K-C9508-FM-E2"                    ! Byte 22-35 ! Addres 17- 26
  Product$ = Prod_Num$
  print tab(5); "Product Number: "; Prod_Num$
  call Chklength_S(Prod_Num$,20)

!!------------------------------------------------------------
!! Serial Number
!! Mem_Table(27-36)  ! Generated at Serial Routine
!!====================================================== ========
!  Serial$ = "FOC12345678"                    ! Byte 36-49 ! Addres 27- 36

!!====================================================== ======
!! Board Part Number ! Reset = 0 ! Ex.73-15576-03 => 73/15287/04
!!====================================================== ======
  Part_N_74_89$     = Board$                 ! Byte 4A-59 ! Address 37-44
  print tab(5); "Part Number: "; Part_N_74_89$
  call Chklength_S(Part_N_74_89$,16)

!!====================================================== ======
!! Part Number Revision
!!====================================================== ======
  Part_R_90_93$  = Board_Rev$  !             ! Byte 5A-5D ! Address 45
  print tab(5); "Part Number Revision: "; Part_R_90_93$
  call Chklength_S(Part_R_90_93$,4)

!! Mfg Deviation !
!!====================================================== ======
  Mfg_Dev_94_113$ = "0"                     ! Byte 5E-71 ! Address 47-56
  call Chklength_S(Mfg_Dev_94_113$,20)

!!====================================================== ======
!! Hardware Version ! Reset = 0
!!====================================================== ======
!@ Hardware Version (Decimal) = 0

  Hw_Rev_maj_114_115 = 0        !high byte   ! Byte 72-73 ! Address 57
  Hw_Rev_min_116_117 = 1100     !low byte    ! Byte 74-75 ! Address 58

  print tab(5); "Hardware Version: ";val$(Hw_Rev_maj_114_115); ".";  val$(Hw_Rev_min_116_117)

!!====================================================== ======
!! Manufacturing Bits
!!====================================================== ======
  Mfg_bits_118_119 = 0                        ! Byte 76-77 ! Address 59

!!====================================================== ======
!! Engineering Bits
!!====================================================== ======
  Eng_bits_120_121 = 0                        ! Byte 78-79 ! Address 60

!!====================================================== ======
!!SNMPOID Number ! TBD
!!====================================================== ======

  SOID_122 = 0
  SOID_123 = 0
  SOID_122_123 = shift(SOID_122,-8) + SOID_123  ! Byte 7A-7B ! Address 61
  SOID_124 = 0
  SOID_125 = 0
  SOID_124_125 = shift(SOID_124,-8) + SOID_125  ! Byte 7C-7D ! Address 62
  SOID_126 = 0
  SOID_127 = 0
  SOID_126_127 = shift(SOID_126,-8) + SOID_127  ! Byte 7E-7F ! Address 63
  SOID_128 = 0
  SOID_129 = 0
  SOID_128_129 = shift(SOID_128,-8) + SOID_129  ! Byte 80-81 ! Address 64
  SOID_130 = 0
  SOID_131 = 0
  SOID_130_131 = shift(SOID_130,-8) + SOID_131  ! Byte 82-83 ! Address 65
  SOID_132 = 0
  SOID_133 = 0
  SOID_132_133 = shift(SOID_132,-8) + SOID_133  ! Byte 84-85 ! Address 66
  SOID_134 = 0
  SOID_135 = 0
  SOID_134_135 = shift(SOID_134,-8) + SOID_135  ! Byte 86-87 ! Address 67
  SOID_136 = 0
  SOID_137 = 0
  SOID_136_137 = shift(SOID_136,-8) + SOID_137  ! Byte 88-89 ! Address 68

!!====================================================== ======
!! Power Consumption
!!====================================================== ======
  PWR_Com_138_139 = -4700                         ! Byte 8A-8B ! Address 69
  PWR_Com_138_139 = binand (PWR_Com_138_139,65535)

!!====================================================== ======
!! RMA Failure Code ! Reset = 0
!!====================================================== ======
  RMA_Fco_140_141 = 0                         ! Byte 8C-8D ! Address 70
  RMA_Fco_142_143 = 0                         ! Byte 8E-8F ! Address 71

!!====================================================== ======
!!CLEI CODES
!!====================================================== ======
  CLEI_Code_144_155$ = "N9K-C9508-FM-E2"           ! Byte 90-9B ! Address 72-77
  call Chklength_S(CLEI_Code_144_155$,12)
!!====================================================== ======
!!VID
!!====================================================== ======

  VID_156_159$ = "V00"                          ! Byte 9C-9F ! Address 78-79
  call Chklength_S(VID_156_159$,4)

!################################################################### #####!
!** SPROM FRU Specific Block                                             !
!** BLOCK 2  in WORD = (16 bits)                                         !
!################################################################### #####!
  Block_Sig_160_161 = hti("6003")  ! Hex       ! Byte A0-A1 ! Address 80
    Block_ver2 = 2                             ! Byte A2-A3 ! Address 81
    Block_len2 = 103
  Block_ver_len_162_163 = shift(Block_ver2,-8) + Block_len2

!!====================================================== ======
!! Block 2 Check Sum
!!====================================================== ======
   Check_sum_164_165 = 0                       ! Byte A4-A5 ! Address 82

!!====================================================== ======
!! Feature Bits
!!====================================================== ======
   Feature_b_166_167 = hti("0000")             ! Byte A6-A7 ! Address 83
   Feature_b_168_169 = hti("0000")             ! Byte A8-A9 ! Address 84
   Feature_b_170_171 = hti("0000")             ! Byte AA-AB ! Address 85
   Feature_b_172_173 = hti("0000")             ! Byte AC-AD ! Address 86

!!====================================================== ======
! Hardware Changes Bits
!!====================================================== ======
   HChange_b_174_175 = hti("0000")             ! Byte AE-AF ! Address 87
   HChange_b_176_177 = hti("0000")             ! Byte B0-B1 ! Address 88
   HChange_b_178_179 = hti("0000")             ! Byte B2-B3 ! Address 89
   HChange_b_180_181 = hti("0000")             ! Byte B4-B5 ! Address 90

!!====================================================== ======
!! Card_Index
!!====================================================== ======
   Card_indx_182_183 = 21111                   ! Byte B6-B7 ! Address 91
   print tab(5); "Feature Index: "; val$(Card_indx_182_183)

!!====================================================== ======
!! Mac_base
!!====================================================== ======
! TBD

   Mac_base_184_185  = 00                     ! Byte B8-B9 ! Address 92
   Mac_base_186_187  = 00                     ! Byte BA-BB ! Address 93
   Mac_base_188_189  = 00                     ! Byte BC-BD ! Address 94

!!====================================================== ======
!! Mac_length
!!====================================================== ======
   Mac_len_190_191  = 0                     ! Byte BE-BF ! Address 95

!!====================================================== ======
!! Cpu_Epld_Num
!!====================================================== ======
   Cpu_Num_192      = 2                       ! Byte C0-C1 ! Address 96
   Epld_Num_193     = 0
   Cpu_Epld_192_193 = shift( Cpu_Num_192, -8) + Epld_Num_193

!!====================================================== ======
!! Epld_Version
!!====================================================== ======
   Epld_A_194_195   = 0                    ! Byte C2-C3 ! Address 97
   Epld_B_196_197   = 0                    ! Byte C4-C5 ! Address 98
   Epld_C_198_199   = 0                    ! Byte C6-C7 ! Address 99
   Epld_D_200_201   = 0                    ! Byte C8-C9 ! Address 100
   Epld_E_202_203   = 0                    ! Byte CA-CB ! Address 101
   Epld_F_204_205   = 0                    ! Byte CC-CD ! Address 102
   Epld_G_206_207   = 0                    ! Byte CE-CF ! Address 103
   Epld_H_208_209   = 0                    ! Byte D0-D1 ! Address 104
   Epld_I_210_211   = 0                    ! Byte D2-D3 ! Address 105
   Epld_J_212_213   = 0                    ! Byte D4-D5 ! Address 106
   Epld_K_214_215   = 0                    ! Byte D6-D7 ! Address 107
   Epld_L_216_217   = 0                    ! Byte D8-D9 ! Address 108
   Epld_M_218_219   = 0                    ! Byte DA-DB ! Address 109
   Epld_N_220_221   = 0                    ! Byte DC-DD ! Address 110
   Epld_O_222_223   = 0                    ! Byte DE-DF ! Address 111

!!====================================================== ======
!! Port Type Number
!!====================================================== ======
   Port_Num_224_225_1 = 0
   Port_Num_224_225_2 = 0
   Port_Num_224_225 = shift( Port_Num_224_225_1, -8) +  Port_Num_224_225_2
   Port_Num_226_227_1 = 0
   Port_Num_226_227_2 = 0
   Port_Num_226_227 = shift( Port_Num_226_227_1, -8) +  Port_Num_226_227_2
   Port_Num_228_229_1 = 0
   Port_Num_228_229_2 = 0
   Port_Num_228_229 = shift( Port_Num_228_229_1, -8) +  Port_Num_228_229_2
   Port_Num_230_231_1 = 0
   Port_Num_230_231_2 = 0
   Port_Num_230_231 = shift( Port_Num_230_231_1, -8) +  Port_Num_230_231_2
   Port_Num_232_233_1 = 0
   Port_Num_232_233_2 = 0
   Port_Num_232_233 = shift( Port_Num_232_233_1, -8) +  Port_Num_232_233_2
   Port_Num_234_235_1 = 0
   Port_Num_234_235_2 = 0
   Port_Num_234_235 = shift( Port_Num_234_235_1, -8) +  Port_Num_234_235_2
   Port_Num_236_237_1 = 0
   Port_Num_236_237_2 = 0
   Port_Num_236_237 = shift( Port_Num_236_237_1, -8) +  Port_Num_236_237_2
   Port_Num_238_239_1 = 0
   Port_Num_238_239_2 = 0
   Port_Num_238_239 = shift( Port_Num_238_239_1, -8) +  Port_Num_238_239_2

!!====================================================== ======
!! Sram_Size
!!====================================================== ======
   Sram_Size_240_241 = 0                      ! Byte F0-F1 ! Address 120

!!====================================================== ======
!! Sensor Major/ Minor
!!====================================================== ======
!* Sensor # 1
   Sensor_242 = -128                          ! Byte F2-F3 ! Address 121
   Sensor_243 = -128
   Sensor_242 = binand (Sensor_242,255)
   Sensor_243 = binand (Sensor_243,255)
   Sensor_242_243 = shift( Sensor_242, -8) + Sensor_243

!* Sensor # 2
   Sensor_244 = -128                           ! Byte F4-F5 ! Address 122
   Sensor_245 = -128
   Sensor_244 = binand (Sensor_244,255)
   Sensor_245 = binand (Sensor_245,255)
   Sensor_244_245 = shift( Sensor_244, -8) + Sensor_245

!* Sensor # 3
   Sensor_246 = -128                           ! Byte F6-F7 ! Address 123
   Sensor_247 = -128
   Sensor_246 = binand (Sensor_246,255)
   Sensor_247 = binand (Sensor_247,255)
   Sensor_246_247 = shift( Sensor_246, -8) + Sensor_247

!* Sensor # 4
   Sensor_248 = 85                             ! Byte F8-F9 ! Address 124
   Sensor_249 = 75
   Sensor_248 = binand (Sensor_248,255)
   Sensor_249 = binand (Sensor_249,255)
   Sensor_248_249 = shift( Sensor_248, -8) + Sensor_249

!* Sensor # 5
   Sensor_250 = 105                            ! Byte FA-FB ! Address 125
   Sensor_251 = 95
   Sensor_250 = binand (Sensor_250,255)
   Sensor_251 = binand (Sensor_251,255)
   Sensor_250_251 = shift( Sensor_250, -8) + Sensor_251

!* Sensor # 6
   Sensor_252 = 110                              ! Byte FC-FD ! Address 126
   Sensor_253 = 100
   Sensor_252 = binand (Sensor_252,255)
   Sensor_253 = binand (Sensor_253,255)
   Sensor_252_253 = shift( Sensor_252, -8) + Sensor_253

!* Sensor # 7
   Sensor_254 = -128                             ! Byte FE-FF ! Address 127
   Sensor_255 = -128
   Sensor_254 = binand (Sensor_254,255)
   Sensor_255 = binand (Sensor_255,255)
   Sensor_254_255 = shift( Sensor_254, -8) + Sensor_255

!* Sensor # 8
   Sensor_256 = -128                            ! Byte 100-101!Address 128
   Sensor_257 = -128
   Sensor_256 = binand (Sensor_256,255)
   Sensor_257 = binand (Sensor_257,255)
   Sensor_256_257 = shift( Sensor_256, -8) + Sensor_257

!!=====================================
!* Max Connector Power
!!======================================
   Max_Connector_Pwr_258_259 = 8300              ! Byte 102-103!Address 129

!!=====================================
!* Cooling Requirements
!!=====================================
   Cooling_Requirements_260_261 = 75             ! Byte 104-105!Address 130

!!=====================================
!* Ambient Temperature
!!=====================================
   Ambient_Temperature_262 = 55                  ! Byte 106-107!Address 131

!################################################################### #####!
!** SPROM Sensor Block                                                   !
!** BLOCK 3  in WORD = (16 bits)                                         !
!################################################################### #####!
   Block_Sig_263 = hti("60")  ! Hex
   Block_Sig_264 = hti("08")  ! Hex

!!====================================================== ======
!! Block Version Length
!!====================================================== ======
   Block_ver_265 = 1
   Block_len_266 = 71

!!====================================================== ======
!! Block Check Sum
!!====================================================== ======
   Check_sum_267 = 0
   Check_sum_268 = 0

!!====================================================== ======
!! Number of Sensors
!!====================================================== ======
   Number_of_Sensors_269 = 0

   Block_262_263 = shift(Ambient_Temperature_262,-8) + Block_Sig_263
   Block_264_265 = shift(Block_Sig_264,-8) + Block_ver_265
   Block_266_267 = shift(Block_len_266,-8) + Check_sum_267
   Block_268_269 = shift(Check_sum_268,-8) + Number_of_Sensors_269

!!====================================================== ======
!! Sensor Major/ Minor
!!====================================================== ======
!* Sensor # 1
   Sensor_270 = -128
   Sensor_271 = -128
   Sensor_270 = binand (Sensor_270,255)
   Sensor_271 = binand (Sensor_271,255)
   Sensor_270_271 = shift( Sensor_270, -8) + Sensor_271

!* Sensor # 2
   Sensor_272 = -128
   Sensor_273 = -128
   Sensor_272 = binand (Sensor_272,255)
   Sensor_273 = binand (Sensor_273,255)
   Sensor_272_273 = shift( Sensor_272, -8) + Sensor_273

!* Sensor # 3
   Sensor_274 = -128
   Sensor_275 = -128
   Sensor_274 = binand (Sensor_274,255)
   Sensor_275 = binand (Sensor_275,255)
   Sensor_274_275 = shift( Sensor_274, -8) + Sensor_275

!* Sensor # 4
   Sensor_276 = -128
   Sensor_277 = -128
   Sensor_276 = binand (Sensor_276,255)
   Sensor_277 = binand (Sensor_277,255)
   Sensor_276_277 = shift( Sensor_276, -8) + Sensor_277

!* Sensor # 5
   Sensor_278 = -128
   Sensor_279 = -128
   Sensor_278 = binand (Sensor_278,255)
   Sensor_279 = binand (Sensor_279,255)
   Sensor_278_279 = shift( Sensor_278, -8) + Sensor_279

!* Sensor # 6
   Sensor_280 = -128
   Sensor_281 = -128
   Sensor_280 = binand (Sensor_280,255)
   Sensor_281 = binand (Sensor_281,255)
   Sensor_280_281 = shift( Sensor_280, -8) + Sensor_281

!* Sensor # 7
   Sensor_282 = -128
   Sensor_283 = -128
   Sensor_282 = binand (Sensor_282,255)
   Sensor_283 = binand (Sensor_283,255)
   Sensor_282_283 = shift( Sensor_282, -8) + Sensor_283

!* Sensor # 8
   Sensor_284 = -128
   Sensor_285 = -128
   Sensor_284 = binand (Sensor_284,255)
   Sensor_285 = binand (Sensor_285,255)
   Sensor_284_285 = shift( Sensor_284, -8) + Sensor_285

!* Sensor # 9
   Sensor_286 = -128
   Sensor_287 = -128
   Sensor_286 = binand (Sensor_286,255)
   Sensor_287 = binand (Sensor_287,255)
   Sensor_286_287 = shift( Sensor_286, -8) + Sensor_287

!* Sensor # 10
   Sensor_288 = -128
   Sensor_289 = -128
   Sensor_288 = binand (Sensor_288,255)
   Sensor_289 = binand (Sensor_289,255)
   Sensor_288_289 = shift( Sensor_288, -8) + Sensor_289

!* Sensor # 11
   Sensor_290 = -128
   Sensor_291 = -128
   Sensor_290 = binand (Sensor_290,255)
   Sensor_291 = binand (Sensor_291,255)
   Sensor_290_291 = shift( Sensor_290, -8) + Sensor_291

!* Sensor # 12
   Sensor_292 = -128
   Sensor_293 = -128
   Sensor_292 = binand (Sensor_292,255)
   Sensor_293 = binand (Sensor_293,255)
   Sensor_292_293 = shift( Sensor_292, -8) + Sensor_293

!* Sensor # 13
   Sensor_294 = -128
   Sensor_295 = -128
   Sensor_294 = binand (Sensor_294,255)
   Sensor_295 = binand (Sensor_295,255)
   Sensor_294_295 = shift( Sensor_294, -8) + Sensor_295

!* Sensor # 14
   Sensor_296 = -128
   Sensor_297 = -128
   Sensor_296 = binand (Sensor_296,255)
   Sensor_297 = binand (Sensor_297,255)
   Sensor_296_297 = shift( Sensor_296, -8) + Sensor_297

!* Sensor # 15
   Sensor_298 = -128
   Sensor_299 = -128
   Sensor_298 = binand (Sensor_298,255)
   Sensor_299 = binand (Sensor_299,255)
   Sensor_298_299 = shift( Sensor_298, -8) + Sensor_299

!* Sensor # 16
   Sensor_300 = -128
   Sensor_301 = -128
   Sensor_300 = binand (Sensor_300,255)
   Sensor_301 = binand (Sensor_301,255)
   Sensor_300_301 = shift( Sensor_300, -8) + Sensor_301

!* Sensor # 17
   Sensor_302 = -128
   Sensor_303 = -128
   Sensor_302 = binand (Sensor_302,255)
   Sensor_303 = binand (Sensor_303,255)
   Sensor_302_303 = shift( Sensor_302, -8) + Sensor_303

!* Sensor # 18
   Sensor_304 = -128
   Sensor_305 = -128
   Sensor_304 = binand (Sensor_304,255)
   Sensor_305 = binand (Sensor_305,255)
   Sensor_304_305 = shift( Sensor_304, -8) + Sensor_305

!* Sensor # 19
   Sensor_306 = -128
   Sensor_307 = -128
   Sensor_306 = binand (Sensor_306,255)
   Sensor_307 = binand (Sensor_307,255)
   Sensor_306_307 = shift( Sensor_306, -8) + Sensor_307

!* Sensor # 20
   Sensor_308 = -128
   Sensor_309 = -128
   Sensor_308 = binand (Sensor_308,255)
   Sensor_309 = binand (Sensor_309,255)
   Sensor_308_309 = shift( Sensor_308, -8) + Sensor_309

!* Sensor # 21
   Sensor_310 = -128
   Sensor_311 = -128
   Sensor_310 = binand (Sensor_310,255)
   Sensor_311 = binand (Sensor_311,255)
   Sensor_310_311 = shift( Sensor_310, -8) + Sensor_311

!* Sensor # 22
   Sensor_312 = -128
   Sensor_313 = -128
   Sensor_312 = binand (Sensor_312,255)
   Sensor_313 = binand (Sensor_313,255)
   Sensor_312_313 = shift( Sensor_312, -8) + Sensor_313

!* Sensor # 23
   Sensor_314 = -128
   Sensor_315 = -128
   Sensor_314 = binand (Sensor_314,255)
   Sensor_315 = binand (Sensor_315,255)
   Sensor_314_315 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 24
   Sensor_316 = -128
   Sensor_317 = -128
   Sensor_316 = binand (Sensor_316,255)
   Sensor_317 = binand (Sensor_317,255)
   Sensor_316_317 = shift( Sensor_316, -8) + Sensor_317

!* Sensor # 25
   Sensor_318 = -128
   Sensor_319 = -128
   Sensor_318 = binand (Sensor_318,255)
   Sensor_319 = binand (Sensor_319,255)
   Sensor_318_319 = shift( Sensor_318, -8) + Sensor_319

!* Sensor # 26
   Sensor_320 = -128
   Sensor_321 = -128
   Sensor_320 = binand (Sensor_320,255)
   Sensor_321 = binand (Sensor_321,255)
   Sensor_320_321 = shift( Sensor_320, -8) + Sensor_321

!* Sensor # 27
   Sensor_322 = -128
   Sensor_323 = -128
   Sensor_322 = binand (Sensor_322,255)
   Sensor_323 = binand (Sensor_323,255)
   Sensor_322_323 = shift( Sensor_322, -8) + Sensor_323

!* Sensor # 28
   Sensor_324 = -128
   Sensor_325 = -128
   Sensor_324 = binand (Sensor_324,255)
   Sensor_325 = binand (Sensor_325,255)
   Sensor_324_325 = shift( Sensor_324, -8) + Sensor_325

!* Sensor # 29
   Sensor_326 = -128
   Sensor_327 = -128
   Sensor_326 = binand (Sensor_326,255)
   Sensor_327 = binand (Sensor_327,255)
   Sensor_326_327 = shift( Sensor_326, -8) + Sensor_327

!* Sensor # 30
   Sensor_328 = -128
   Sensor_329 = -128
   Sensor_328 = binand (Sensor_328,255)
   Sensor_329 = binand (Sensor_329,255)
   Sensor_328_329 = shift( Sensor_328, -8) + Sensor_329

!* Sensor # 31
   Sensor_330 = -128
   Sensor_331 = -128
   Sensor_330 = binand (Sensor_330,255)
   Sensor_331 = binand (Sensor_331,255)
   Sensor_330_331 = shift( Sensor_330, -8) + Sensor_331

!* Sensor # 32
   Sensor_332 = -128
   Sensor_333 = -128
   Sensor_332 = binand (Sensor_332,255)
   Sensor_333 = binand (Sensor_333,255)
   Sensor_332_333 = shift( Sensor_332, -8) + Sensor_333

!EEPROM PROGRAMMING ENDS - TTP
!BELOW DATA ARE NOT PROGRAMMED
!DO NOT ALTER

   Empty_334_335 = 65535
   Empty_336_337 = 65535
   Empty_338_339 = 65535
   Empty_340_341 = 65535
   Empty_342_343 = 65535
   Empty_344_345 = 65535
   Empty_346_346 = 65535
   Empty_348_349 = 65535
   Empty_350_351 = 65535
   Empty_352_353 = 65535
   Empty_354_355 = 65535
   Empty_356_357 = 65535
   Empty_358_359 = 65535
   Empty_360_361 = 65535
   Empty_362_363 = 65535
   Empty_364_365 = 65535
   Empty_366_367 = 65535
   Empty_368_369 = 65535
   Empty_370_371 = 65535
   Empty_372_373 = 65535
   Empty_374_375 = 65535
   Empty_376_377 = 65535
   Empty_378_379 = 65535
   Empty_380_381 = 65535


!!====================================================== ======
!! Padding
!! Routine below to handle data generation for this field
!!====================================================== ======
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!*************  END OF PCAMAP TABLE ***********************!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!! WARNINGS !! WARNINGS !! WARNINGS !! WARNINGS !! !!!!!!!
!!!!!! WARNINGS !! WARNINGS !! WARNINGS !! WARNINGS !! !!!!!!!
!!!!!! WARNINGS !! WARNINGS !! WARNINGS !! WARNINGS !! !!!!!!!
!!!!!!         DO NOT MODIFY FROM THIS LINE ON         !!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!$$$$$$ GENERATE MEMORY TABLE  $$$$$$$$$$$$$$$$$$$$$$$$$$$$!!
!!====================================================== ====!!
   Mem_Table(0) = Block_sig_0_1
   Mem_Table(1) = Block_ver_len_2_3
   Mem_Table(2) = Check_sum_4_5      !! Xsum1 / BLK 1
   Mem_Table(3) = Eprom_size_6_7
   Mem_Table(4) = Block_count_8_9
   Mem_Table(5) = Fru_maj_10_11
   Mem_Table(6) = Fru_min_12_13
!!
!!
  for V1 = 1 to 20 ! Character Byte
      Temp = num(OEM_Str$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
        else
           Test(V1) = num(OEM_Str$[V1;1])
      end if
  next V1


  for L1 = 0 to 9  ! Word  - For Mem_Table(7-16) Locations
     Mem_Table(7+L1) = shift( Test(2*L1+1), -8 ) + Test(2*L1+2) ! "Cisco..."
  next L1
!!

  for V = 1 to 20 ! Character Byte
      Temp = num(Prod_Num$[V;1])
      if Temp = 92 then
         Test(V) = 0  ! "\" = 92
        else
           Test(V) = num(Prod_Num$[V;1])
      end if
  next V

  for L = 0 to 9  ! Word  - For Mem_Table(17-26) Locations
     Mem_Table(17+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2) ! "WS....."
  next L

!!====================================================== ======
!! Board Part Number ! Reset = 0 ! Ex.73-15576-03 => 73/15287/04
!!====================================================== ======

  for V1 = 1 to 16 ! Character Byte
      Temp = num(Part_N_74_89$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
          else
           Test(V1) = num(Part_N_74_89$[V1;1])
      end if
  next V1

  for L = 0 to 7  ! Word  - For Mem_Table(37-44) Locations
     Mem_Table(37+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2)
  next L

!!====================================================== =========
!! Mem_Table(45-46)
  for V = 1 to 4 ! Character Byte
      Temp = num(Part_R_90_93$[V;1])
      if Temp = 92 then
         Test(V) = 0  ! "\" = 92
        else
           Test(V) = num(Part_R_90_93$[V;1])
      end if
  next V

  for L = 0 to 1  ! Word  - For Mem_Table(45-46) Locations
     Mem_Table(45+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2)
  next L
!!====================================================== =========
!! Mem_Table(47-56)
  for V = 1 to 20 ! Character Byte
      Temp = num(Mfg_Dev_94_113$[V;1])
      if Temp = 92 then
         Test(V) = 0  ! "\" = 92
        else
           Test(V) = num(Mfg_Dev_94_113$[V;1])
      end if
  next V

  for L = 0 to 9  ! Word  - For Mem_Table(47-56) Locations
     Mem_Table(47+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2)
  next L
!!====================================================== =========
   Mem_Table(57) = Hw_Rev_maj_114_115
   Mem_Table(58) = Hw_Rev_min_116_117
   Mem_Table(59) = Mfg_bits_118_119
   Mem_Table(60) = Eng_bits_120_121
   Mem_Table(61) = SOID_122_123
   Mem_Table(62) = SOID_124_125
   Mem_Table(63) = SOID_126_127
   Mem_Table(64) = SOID_128_129
   Mem_Table(65) = SOID_130_131
   Mem_Table(66) = SOID_132_133
   Mem_Table(67) = SOID_134_135
   Mem_Table(68) = SOID_136_137
   Mem_Table(69) = PWR_Com_138_139
   Mem_Table(70) = RMA_Fco_140_141
   Mem_Table(71) = RMA_Fco_142_143

  for V1 = 1 to 12 ! Character Byte
      Temp = num(CLEI_Code_144_155$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
        else
           Test(V1) = num(CLEI_Code_144_155$[V1;1])
      end if
  next V1

  for L1 = 0 to 5  ! Word  - For Mem_Table(7-16) Locations
     Mem_Table(72+L1) = shift( Test(2*L1+1), -8 ) + Test(2*L1+2) ! "Cisco..."
  next L1

!!====================================================== =========

   for V1 = 1 to 4  ! Character Byte
      Temp = num(VID_156_159$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
        else
           Test(V1) = num(VID_156_159$[V1;1])
      end if
   next V1

   for L1 = 0 to 1  ! Word
     Mem_Table(78+L1) = shift( Test(2*L1+1), -8 ) + Test(2*L1+2)
   next L1


!!====================================================== ======
!** BLOCK 2  in WORD = (16 bits)
!!====================================================== ======
   Mem_Table(80) =  Block_Sig_160_161
   Mem_Table(81) =  Block_ver_len_162_163
   Mem_Table(82) =  Check_sum_164_165    !! Xsum2 / BLK 2
   Mem_Table(83) =  Feature_b_166_167
   Mem_Table(84) =  Feature_b_168_169
   Mem_Table(85) =  Feature_b_170_171
   Mem_Table(86) =  Feature_b_172_173
   Mem_Table(87) =  HChange_b_174_175
   Mem_Table(88) =  HChange_b_176_177
   Mem_Table(89) =  HChange_b_178_179
   Mem_Table(90) =  HChange_b_180_181
   Mem_Table(91) =  Card_Indx_182_183
   Mem_Table(92) =  Mac_base_184_185
   Mem_Table(93) =  Mac_base_186_187
   Mem_Table(94) =  Mac_base_188_189
   Mem_Table(95) =  Mac_len_190_191
   Mem_Table(96) =  Cpu_Epld_192_193
   Mem_Table(97) =  Epld_A_194_195
   Mem_Table(98) =  Epld_B_196_197
   Mem_Table(99) =  Epld_C_198_199
   Mem_Table(100) = Epld_D_200_201
   Mem_Table(101) = Epld_E_202_203
   Mem_Table(102) = Epld_F_204_205
   Mem_Table(103) = Epld_G_206_207
   Mem_Table(104) = Epld_H_208_209
   Mem_Table(105) = Epld_I_210_211
   Mem_Table(106) = Epld_J_212_213
   Mem_Table(107) = Epld_K_214_215
   Mem_Table(108) = Epld_L_216_217
   Mem_Table(109) = Epld_M_218_219
   Mem_Table(110) = Epld_N_220_221
   Mem_Table(111) = Epld_O_222_223
   Mem_Table(112) = Port_Num_224_225
   Mem_Table(113) = Port_Num_226_227
   Mem_Table(114) = Port_Num_228_229
   Mem_Table(115) = Port_Num_230_231
   Mem_Table(116) = Port_Num_232_233
   Mem_Table(117) = Port_Num_234_235
   Mem_Table(118) = Port_Num_236_237
   Mem_Table(119) = Port_Num_238_239
   Mem_Table(120) = Sram_Size_240_241
   Mem_Table(121) = Sensor_242_243
   Mem_Table(122) = Sensor_244_245
   Mem_Table(123) = Sensor_246_247
   Mem_Table(124) = Sensor_248_249
   Mem_Table(125) = Sensor_250_251
   Mem_Table(126) = Sensor_252_253
   Mem_Table(127) = Sensor_254_255
   Mem_Table(128) = Sensor_256_257
   Mem_Table(129) = Max_Connector_Pwr_258_259
   Mem_Table(130) = Cooling_Requirements_260_261

!!====================================================== ======
!** BLOCK 3  in WORD = (16 bits)
!!====================================================== ======
   Mem_Table(131) = Block_262_263
   Mem_Table(132) = Block_264_265
   Mem_Table(133) = Block_266_267
   Mem_Table(134) = Block_268_269
   Mem_Table(135) = Sensor_270_271
   Mem_Table(136) = Sensor_272_273
   Mem_Table(137) = Sensor_274_275
   Mem_Table(138) = Sensor_276_277
   Mem_Table(139) = Sensor_278_279
   Mem_Table(140) = Sensor_280_281
   Mem_Table(141) = Sensor_282_283
   Mem_Table(142) = Sensor_284_285
   Mem_Table(143) = Sensor_286_287
   Mem_Table(144) = Sensor_288_289
   Mem_Table(145) = Sensor_290_291
   Mem_Table(146) = Sensor_292_293
   Mem_Table(147) = Sensor_294_295
   Mem_Table(148) = Sensor_296_297
   Mem_Table(149) = Sensor_298_299
   Mem_Table(150) = Sensor_300_301
   Mem_Table(151) = Sensor_302_303
   Mem_Table(152) = Sensor_304_305
   Mem_Table(153) = Sensor_306_307
   Mem_Table(154) = Sensor_308_309
   Mem_Table(155) = Sensor_310_311
   Mem_Table(156) = Sensor_312_313
   Mem_Table(157) = Sensor_314_315
   Mem_Table(158) = Sensor_316_317
   Mem_Table(159) = Sensor_318_319
   Mem_Table(160) = Sensor_320_321
   Mem_Table(161) = Sensor_322_323
   Mem_Table(162) = Sensor_324_325
   Mem_Table(163) = Sensor_326_327
   Mem_Table(164) = Sensor_328_329
   Mem_Table(165) = Sensor_330_331
   Mem_Table(166) = Sensor_332_333

   !FOR MT.KATO
   Mem_Table(167) = Empty_334_335
   Mem_Table(168) = Empty_334_335
   Mem_Table(169) = Empty_336_337
   Mem_Table(170) = Empty_338_339
   Mem_Table(171) = Empty_340_341
   Mem_Table(172) = Empty_342_343
   Mem_Table(173) = Empty_344_345
   Mem_Table(174) = Empty_346_346
   Mem_Table(175) = Empty_348_349
   Mem_Table(176) = Empty_350_351
   Mem_Table(177) = Empty_352_353
   Mem_Table(178) = Empty_354_355
   Mem_Table(179) = Empty_356_357
   Mem_Table(180) = Empty_358_359
   Mem_Table(181) = Empty_360_361
   Mem_Table(182) = Empty_362_363
   Mem_Table(183) = Empty_364_365
   Mem_Table(184) = Empty_366_367
   Mem_Table(185) = Empty_368_369
   Mem_Table(186) = Empty_370_371
   Mem_Table(187) = Empty_372_373
   Mem_Table(188) = Empty_374_375
   Mem_Table(189) = Empty_376_377
   Mem_Table(190) = Empty_378_379
   Mem_Table(191) = Empty_380_381
   !MT.KATO END

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! Checksum Calculations
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BLOCK 1
  XsumB1 = 0
  for Word =  0 to 79
    if Word = 2 then goto Skip1
     Crc_LB0 = binand (Mem_Table(Word),255)
     Crc_SR8 = binand (shift(Mem_Table(Word), 8),255)
     XsumB1 = XsumB1 + Crc_LB0 + Crc_SR8
     if XsumB1 > 65535 then XsumB1 = binand(XsumB1,65535)
   Skip1:
  next Word

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BLOCK 2
  XsumB2 = 0
  for Word = 80 to 131
    if Word = 82 then goto Skip2
     Crc_LB0 = binand (Mem_Table(Word),255)
     Crc_SR8 = binand (shift(Mem_Table(Word), 8),255)
     if Word = 131 then
       XsumB2 = XsumB2 + Crc_SR8
     else
       XsumB2 = XsumB2 + Crc_LB0 + Crc_SR8
     end if
     if XsumB2 > 65535 then XsumB2 = binand(XsumB2,65535)
   Skip2:
  next Word

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BLOCK 3
  XsumB3 = 0

  for Word = 131 to 166
     Crc_LB0 = binand (Mem_Table(Word),255)
     Crc_SR8 = binand (shift(Mem_Table(Word), 8),255)
     if Word = 131 then
       XsumB3 = XsumB3 + Crc_LB0
     else
       XsumB3 = XsumB3 + Crc_LB0 + Crc_SR8
     end if

     if XsumB3 > 65535 then XsumB3 = binand(XsumB3,65535)
  next Word

  Checksum_3_Hex$ = ith$(XsumB3)
  if len(Checksum_3_Hex$)=1 then Checksum_3_Hex$ = "000" & Checksum_3_Hex$
  if len(Checksum_3_Hex$)=2 then Checksum_3_Hex$ = "00" & Checksum_3_Hex$
  if len(Checksum_3_Hex$)=3 then Checksum_3_Hex$ = "0" & Checksum_3_Hex$

  Checksum_3_High$ = Checksum_3_Hex$[1;2]
  Checksum_3_Low$  = Checksum_3_Hex$[3;2]

  Check_sum_267 = hti(Checksum_3_High$)
  Check_sum_268 = hti(Checksum_3_Low$)

  Block_266_267 = shift(Block_len_266,-8) + Check_sum_267
  Block_268_269 = shift(Check_sum_268,-8) + Number_of_Sensors_269

! Store new check sum values

  Mem_Table(2)    =  XsumB1           !block 1
  Mem_Table(82)   =  XsumB2           !blocK 2
  Mem_Table(133)  =  Block_266_267    !block 3
  Mem_Table(134)  =  Block_268_269    !block 3

!! testonly
 print "Check Sum Blk #1 = ", Mem_Table(2)
 print "Check Sum Blk #2 = ", Mem_Table(82)
 print "Check Sum Blk #3 = ", Mem_Table(XX)

for Cnt1 = 0 to 63 !!
   EE_D1(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1), 8),1)
   EE_D1(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1), 9),1)
   EE_D1(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1),10),1)
   EE_D1(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1),11),1)
   EE_D1(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1),12),1)
   EE_D1(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1),13),1)
   EE_D1(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1),14),1)
   EE_D1(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1),15),1)
   EE_D1(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1), 0),1)
   EE_D1(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1), 1),1)
   EE_D1(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1), 2),1)
   EE_D1(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1), 3),1)
   EE_D1(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1), 4),1)
   EE_D1(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1), 5),1)
   EE_D1(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1), 6),1)
   EE_D1(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1), 7),1)
next Cnt1

  for I = 0 to 1023
   EE_R1(I) = EE_D1(I)
  next I

for Cnt1 = 0 to 63 !!
   EE_D2(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1+64), 8),1)
   EE_D2(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1+64), 9),1)
   EE_D2(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1+64),10),1)
   EE_D2(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1+64),11),1)
   EE_D2(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1+64),12),1)
   EE_D2(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1+64),13),1)
   EE_D2(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1+64),14),1)
   EE_D2(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1+64),15),1)
   EE_D2(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1+64), 0),1)
   EE_D2(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1+64), 1),1)
   EE_D2(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1+64), 2),1)
   EE_D2(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1+64), 3),1)
   EE_D2(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1+64), 4),1)
   EE_D2(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1+64), 5),1)
   EE_D2(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1+64), 6),1)
   EE_D2(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1+64), 7),1)
next Cnt1

  for I = 0 to 1023
   EE_R2(I) = EE_D2(I)
  next I

for Cnt1 = 0 to 63 !!
   EE_D3(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1+128), 8),1)
   EE_D3(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1+128), 9),1)
   EE_D3(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1+128),10),1)
   EE_D3(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1+128),11),1)
   EE_D3(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1+128),12),1)
   EE_D3(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1+128),13),1)
   EE_D3(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1+128),14),1)
   EE_D3(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1+128),15),1)
   EE_D3(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1+128), 0),1)
   EE_D3(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1+128), 1),1)
   EE_D3(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1+128), 2),1)
   EE_D3(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1+128), 3),1)
   EE_D3(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1+128), 4),1)
   EE_D3(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1+128), 5),1)
   EE_D3(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1+128), 6),1)
   EE_D3(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1+128), 7),1)
next Cnt1

  for I = 0 to 1023
   EE_R3(I) = EE_D3(I)
  next I

for Cnt1 = 0 to 63 !!
   EE_D4(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1+192), 8),1)
   EE_D4(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1+192), 9),1)
   EE_D4(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1+192),10),1)
   EE_D4(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1+192),11),1)
   EE_D4(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1+192),12),1)
   EE_D4(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1+192),13),1)
   EE_D4(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1+192),14),1)
   EE_D4(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1+192),15),1)
   EE_D4(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1+192), 0),1)
   EE_D4(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1+192), 1),1)
   EE_D4(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1+192), 2),1)
   EE_D4(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1+192), 3),1)
   EE_D4(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1+192), 4),1)
   EE_D4(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1+192), 5),1)
   EE_D4(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1+192), 6),1)
   EE_D4(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1+192), 7),1)
next Cnt1

! **********************************************************************
  ! Data For Write Command and Header for page 1.

                                     ! Header for 1st 128 bytes
  for I = 0 to 15                    ! Initialize to $00
    Header1(I) = hti("00")
  next I

  Header1(0)   = hti("25")           ! Write Cookie Command = $25, $00
  Header1(1)   = hti("00")
  Header1(2)   = hti("83")           ! Length of the total message -
                                     !    excluding the command bytes
  Header1(3)   = hti("10")           ! Starting Address high byte
  Header1(4)   = hti("00")           ! Starting Address low byte
  Header1(5)   = hti("80")           ! Number bytes of Cookie,128 bytes

! **********************************************************************

  for I = 0 to 7                                      ! Header
   HDR1(I*16+0)  = binand(shift(Header1(I*2),0),1)
   HDR1(I*16+1)  = binand(shift(Header1(I*2),1),1)
   HDR1(I*16+2)  = binand(shift(Header1(I*2),2),1)
   HDR1(I*16+3)  = binand(shift(Header1(I*2),3),1)
   HDR1(I*16+4)  = binand(shift(Header1(I*2),4),1)
   HDR1(I*16+5)  = binand(shift(Header1(I*2),5),1)
   HDR1(I*16+6)  = binand(shift(Header1(I*2),6),1)
   HDR1(I*16+7)  = binand(shift(Header1(I*2),7),1)
   HDR1(I*16+8)  = binand(shift(Header1(I*2+1),0),1)
   HDR1(I*16+9)  = binand(shift(Header1(I*2+1),1),1)
   HDR1(I*16+10) = binand(shift(Header1(I*2+1),2),1)
   HDR1(I*16+11) = binand(shift(Header1(I*2+1),3),1)
   HDR1(I*16+12) = binand(shift(Header1(I*2+1),4),1)
   HDR1(I*16+13) = binand(shift(Header1(I*2+1),5),1)
   HDR1(I*16+14) = binand(shift(Header1(I*2+1),6),1)
   HDR1(I*16+15) = binand(shift(Header1(I*2+1),7),1)
  next I

! **********************************************************************
! ************************ CheckSum Calculation ************************
! **********************************************************************

   ! For 1st 128 bytes

   Chksum1 = 0                                  ! initialize to 0
   EE_Data1 = 0

   for I =  0 to 15                             ! Header
     Chksum1 = Chksum1 + binand(Header1(I),255)
   next I

   for I =  0 to 127                           ! Cookie data

      EE_DD1$ =""
      for G = 0 to 7
         B = (I * 8) + 7 - G
!        B = (I * 8) + G
         EE_DD1$ = EE_DD1$ & val$(EE_D1(B))
      next G
      EE_Data1 = bti(EE_DD1$)

   Chksum1 = Chksum1 + binand(EE_Data1,255)

   next I

   if Chksum1 > 65535 then Chksum1 = binand(Chksum1,65535)

   Chksum1   = bineor(Chksum1,255)  ! XOR with $FF, inverting data
   Chksum1   = binand(Chksum1,255)  ! Lower 8 bits only

   XSUM1(0)  = binand(shift(Chksum1,0),1)             ! Checksum
   XSUM1(1)  = binand(shift(Chksum1,1),1)
   XSUM1(2)  = binand(shift(Chksum1,2),1)
   XSUM1(3)  = binand(shift(Chksum1,3),1)
   XSUM1(4)  = binand(shift(Chksum1,4),1)
   XSUM1(5)  = binand(shift(Chksum1,5),1)
   XSUM1(6)  = binand(shift(Chksum1,6),1)
   XSUM1(7)  = binand(shift(Chksum1,7),1)

! **********************************************************************
  ! Data For Write Command and Header for page 2.

                                     ! Header for 2nd 128 bytes
  for I = 0 to 15                    ! Initialize to $00
    Header2(I) = hti("00")
  next I

  Header2(0)   = hti("25")           ! Write Cookie Command = $25, $00
  Header2(1)   = hti("00")
  Header2(2)   = hti("83")           ! Length of the total message -
                                     !    excluding the command bytes
  Header2(3)   = hti("10")           ! Starting Address high byte
  Header2(4)   = hti("80")           ! Starting Address low byte
  Header2(5)   = hti("80")           ! Number bytes of Cookie,128 bytes

! **********************************************************************

  for I = 0 to 7                                      ! Header
   HDR2(I*16+0)  = binand(shift(Header2(I*2),0),1)
   HDR2(I*16+1)  = binand(shift(Header2(I*2),1),1)
   HDR2(I*16+2)  = binand(shift(Header2(I*2),2),1)
   HDR2(I*16+3)  = binand(shift(Header2(I*2),3),1)
   HDR2(I*16+4)  = binand(shift(Header2(I*2),4),1)
   HDR2(I*16+5)  = binand(shift(Header2(I*2),5),1)
   HDR2(I*16+6)  = binand(shift(Header2(I*2),6),1)
   HDR2(I*16+7)  = binand(shift(Header2(I*2),7),1)
   HDR2(I*16+8)  = binand(shift(Header2(I*2+1),0),1)
   HDR2(I*16+9)  = binand(shift(Header2(I*2+1),1),1)
   HDR2(I*16+10) = binand(shift(Header2(I*2+1),2),1)
   HDR2(I*16+11) = binand(shift(Header2(I*2+1),3),1)
   HDR2(I*16+12) = binand(shift(Header2(I*2+1),4),1)
   HDR2(I*16+13) = binand(shift(Header2(I*2+1),5),1)
   HDR2(I*16+14) = binand(shift(Header2(I*2+1),6),1)
   HDR2(I*16+15) = binand(shift(Header2(I*2+1),7),1)
  next I

! **********************************************************************
! ************************ CheckSum Calculation ************************
! **********************************************************************
   ! For 2nd 128 bytes

   Chksum2 = 0                                  ! initialize to 0
   EE_Data2 = 0

   for I =  0 to 15                             ! Header
     Chksum2 = Chksum2 + binand(Header2(I),255)
   next I

   for I = 0 to 127                           ! Cookie data

      EE_DD2$ =""
      for G = 0 to 7
         B = (I * 8) + 7 - G
!        B = (I * 8) + G
         EE_DD2$ = EE_DD2$ & val$(EE_D2(B))
      next G

      EE_Data2 = bti(EE_DD2$)

   Chksum2 = Chksum2 + binand(EE_Data2,255)

   next I

   if Chksum2 > 65535 then Chksum2 = binand(Chksum2,65535)

   Chksum2   = bineor(Chksum2,255)  ! XOR with $FF, inverting data
   Chksum2   = binand(Chksum2,255)  ! Lower 8 bits only

   XSUM2(0)  = binand(shift(Chksum2,0),1)             ! Checksum
   XSUM2(1)  = binand(shift(Chksum2,1),1)
   XSUM2(2)  = binand(shift(Chksum2,2),1)
   XSUM2(3)  = binand(shift(Chksum2,3),1)
   XSUM2(4)  = binand(shift(Chksum2,4),1)
   XSUM2(5)  = binand(shift(Chksum2,5),1)
   XSUM2(6)  = binand(shift(Chksum2,6),1)
   XSUM2(7)  = binand(shift(Chksum2,7),1)


! **********************************************************************
  ! Data For Write Command and Header for page 3.

                                     ! Header for 3rd 128 bytes
  for I = 0 to 15                    ! Initialize to $00
    Header3(I) = hti("00")
  next I

  Header3(0)   = hti("25")           ! Write Cookie Command = $25, $00
  Header3(1)   = hti("00")
  Header3(2)   = hti("83")           ! Length of the total message -
                                     !    excluding the command bytes
  Header3(3)   = hti("11")           ! Starting Address high byte
  Header3(4)   = hti("00")           ! Starting Address low byte
  Header3(5)   = hti("80")           ! Number bytes of Cookie,128 bytes

! **********************************************************************

  for I = 0 to 7                                      ! Header
   HDR3(I*16+0)  = binand(shift(Header3(I*2),0),1)
   HDR3(I*16+1)  = binand(shift(Header3(I*2),1),1)
   HDR3(I*16+2)  = binand(shift(Header3(I*2),2),1)
   HDR3(I*16+3)  = binand(shift(Header3(I*2),3),1)
   HDR3(I*16+4)  = binand(shift(Header3(I*2),4),1)
   HDR3(I*16+5)  = binand(shift(Header3(I*2),5),1)
   HDR3(I*16+6)  = binand(shift(Header3(I*2),6),1)
   HDR3(I*16+7)  = binand(shift(Header3(I*2),7),1)
   HDR3(I*16+8)  = binand(shift(Header3(I*2+1),0),1)
   HDR3(I*16+9)  = binand(shift(Header3(I*2+1),1),1)
   HDR3(I*16+10) = binand(shift(Header3(I*2+1),2),1)
   HDR3(I*16+11) = binand(shift(Header3(I*2+1),3),1)
   HDR3(I*16+12) = binand(shift(Header3(I*2+1),4),1)
   HDR3(I*16+13) = binand(shift(Header3(I*2+1),5),1)
   HDR3(I*16+14) = binand(shift(Header3(I*2+1),6),1)
   HDR3(I*16+15) = binand(shift(Header3(I*2+1),7),1)
  next I

! **********************************************************************
! ************************ CheckSum Calculation ************************
! **********************************************************************

   ! For 3rd 128 bytes

   Chksum3 = 0                                  ! initialize to 0
   EE_Data3 = 0
   for I =  0 to 15                             ! Header
     Chksum3 = Chksum3 + binand(Header3(I),255)
   next I

   for I = 0 to 127                             ! Cookie data

      EE_DD3$ =""
      for G = 0 to 7
         B = (I * 8) + 7 - G
!        B = (I * 8) + G
         EE_DD3$ = EE_DD3$ & val$(EE_D3(B))
      next G

      EE_Data3 = bti(EE_DD3$)

   Chksum3 = Chksum3 + binand(EE_Data3,255)

   next I

   if Chksum3 > 65535 then Chksum3 = binand(Chksum3,65535)

   Chksum3   = bineor(Chksum3,255)  ! XOR with $FF, inverting data
   Chksum3   = binand(Chksum3,255)  ! Lower 8 bits only

   XSUM3(0)  = binand(shift(Chksum3,0),1)             ! Checksum
   XSUM3(1)  = binand(shift(Chksum3,1),1)
   XSUM3(2)  = binand(shift(Chksum3,2),1)
   XSUM3(3)  = binand(shift(Chksum3,3),1)
   XSUM3(4)  = binand(shift(Chksum3,4),1)
   XSUM3(5)  = binand(shift(Chksum3,5),1)
   XSUM3(6)  = binand(shift(Chksum3,6),1)
   XSUM3(7)  = binand(shift(Chksum3,7),1)

! **********************************************************************
! ***************** Print Out Entry Data For EEPROM ********************
! ************************** For Debug Only ****************************
! **********************************************************************

Eprom_Debug = False
!if Eprom_Debug then   ! Change to 'if not.....' to print

    assign @EE_data1_Sprom to "EE_Data1_Hex_Sprom";write
    assign @EE_data2_Sprom to "EE_Data1_Chr_Sprom";write

    for K = 0 to 127  !First 1k
      Char_Data$=""
      for G = 0 to 7
!        B = (K * 8) + G
         B = (K * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D1(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    for K = 128 to 255  !second 1k
      Char_Data$=""
      for G = 0 to 7
!        B = ((K-128) * 8) + G
         B = ((K-128) * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D2(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    for K = 256 to 383  !Third 1k
      Char_Data$=""
      for G = 0 to 7
!        B = ((K-256) * 8) + G
         B = ((K-256) * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D3(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    for K = 384 to 511  !Fourth 1k
      Char_Data$=""
      for G = 0 to 7
!        B = ((K-384) * 8) + G
         B = ((K-384) * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D4(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    assign @EE_data1_Sprom to *
    assign @EE_data2_Sprom to *

!end if
subend

sub Chklength_S(Temp2$,Length) !! For PN Only
  global Option
  ChkLen_S:
    if len(Temp2$) < Length then !this pads 0's to back of hex word
       Temp2$= Temp2$&"\"   !these are the 8 bit hex equiv of Ascii chars
       goto ChkLen_S
    end if
subend

sub Convert_Serial_Number(Serial$)
global Option, Mem_Table(*)
dim Test(1:20)

! Store Serial # to Memory Table
! Check for NULL Character

!Serial$ = "SAD12345678\\\\\\\\\" !!For debug
 Serial$ = Serial$ &"\\\\\\\\\"
 print Serial$
 for Z = 1 to 10
     if num(Serial$[(2*Z-1);1]) = 92 then
          Test(2*Z-1) = 0  ! Odd order 1,3,5,7,..19
       else
          Test(2*Z-1) = shift(num(Serial$[(2*Z-1);1]), -8)
     end if
     if num(Serial$[2*Z;1]) = 92 then    ! reset "\" to "0" null
          Test(2*Z) = 0  ! Even order 2,4,6,8,..20
       else
          Test(2*Z) = num(Serial$[2*Z;1])
     end if
 next Z

 for J = 1 to 10
      Mem_Table(26+J) = Test(2*J-1) + Test(2*J) ! Mem_Table(27-36)
 next J
subend

sub Read_EEprom_u105
   global AssyNum$
   global Serial$
   dim Read_Data(0:4095)
   !! Start read out board 1 EEprom data
   print "Dumping data to Hex file-->" &"EE_Data1_Hex_"&Serial$[1;11]
   print "Dumping data to Charfile-->" &"EE_Data1_Chr_"&Serial$[1;11]
   assign @EE_data1 to "eeprom_data/EE_Data_Hex_u105_"&Serial$[1;11];write
   assign @EE_data2 to "eeprom_data/EE_Data_Chr_u105_"&Serial$[1;11];write

      safeguard cool
     print tab(1);chr$(27)&"&v3S Read programming Data from u105"
     test "digital/u105%dump";Read_Data(*)|print dutfailed
     if dutfailed then
       clear failures|report clear
       pass device
       print tab(1);chr$(27)&"&v3S Read programming Data_new from u105"
       test "digital/u105%dump_new";Read_Data(*)|print dutfailed
     else
       print tab(1);chr$(27)&"&v2S Read programming Data from u105 passed"
     end if
      !Convert Data Array to Data String
       for K = 0 to 511
        Char_Data$=""
        for G = 0 to 7
!          B = (K * 8) + 7 - G
           B = (K * 8) + G
           Char_Data$=Char_Data$ & val$(Read_Data(B))
        next G
        Int_Data  = bti ( Char_Data$)
        Hex_Data$ = ith$(Int_Data)
        if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$
        ! Output to file
        ! EE_data1 addr and data in hex
        output @EE_data1;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
        ! EE_data2 addr and data in integers and chracters
        if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
         output @EE_data2;"   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
        else
         output @EE_data2;"   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
        end if
      next K
      assign @EE_data1 to *
      assign @EE_data2 to *
subend

sub Read_EEprom_act2_c
   global Serial$
   dim Read_Data(0:4095)
   !! Start read out board 1 EEprom data
   print "Dumping data to Hex file-->" &"EE_Data1_Hex_"&Serial$[1;11]
   print "Dumping data to Charfile-->" &"EE_Data1_Chr_"&Serial$[1;11]
   assign @EE_data1 to "eeprom_data/EE_Data_Hex_ACT2_C_"&Serial$[1;11];write
   assign @EE_data2 to "eeprom_data/EE_Data_Chr_ACT2_C_"&Serial$[1;11];write

      safeguard cool
      test "eeprom/act2_c%dump";Read_Data(*)
      !Convert Data Array to Data String
       for K = 0 to 511
        Char_Data$=""
        for G = 0 to 7
!          B = (K * 8) + 7 - G
           B = (K * 8) + G
           Char_Data$=Char_Data$ & val$(Read_Data(B))
        next G
        Int_Data  = bti ( Char_Data$)
        Hex_Data$ = ith$(Int_Data)
        if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$
        ! Output to file
        ! EE_data1 addr and data in hex
        output @EE_data1;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
        ! EE_data2 addr and data in integers and chracters
        if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
         output @EE_data2;"   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
        else
         output @EE_data2;"   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
        end if
      next K
      assign @EE_data1 to *
      assign @EE_data2 to *
subend

sub Verify_Fixture_Penang
global Fixture_cs$,Fixture$
global Delim1$,Delim2$
global Using_PRPlus

Fixtbarcodemsg$ = "** Please scan fixture bar code **"
  Wrongfixturemsg$ = "** This is the wrong fixture for this program **"

    print using "@"
  loop
    print Fixtbarcodemsg$
    Fixture_cs$=""
    input "",Fixture_cs$
!P5 exit if Fixture_cs$[1;8] = "00155498"
!   exit if Fixture_cs$[1;8] = "00209946"
    exit if Fixture_cs$[1;7] = "0107D25"
    print using "@"
    print Wrongfixturemsg$
    print ""
  end loop

Fixture$ = Fixture_cs$[1;7]

  Delim1$ = fn Index$(Fixture_cs$,"-")
  Delim2$ = fn Index$(Fixture_cs$,"/")
  Del1 = val(Delim1$)
  Del2 = val(Delim2$)
  Strl = len(Fixture_cs$)

  Y_due = val(Fixture_cs$[Del2+1;4])
  M_due = val(Fixture_cs$[Del2+5;2])
  D_due = val(Fixture_cs$[Del2+7;2])

  Y_today = val(datetime$[1;2])
  if Y_today = 99 then
    Y_today = 1999
  else
    Y_today = Y_today + 2000
  end if
  M_today = val(datetime$[3;2])
  D_today = val(datetime$[5;2])

  Deltapm = 365.2425*(Y_due-Y_today+(M_due-M_today)/12)+D_due-D_today

  print using "@"
  if Deltapm < 7 then
    beep
    beep
    print chr$(27)&"&v3SThis fixture is due for PM in";Deltapm;" days."
    print chr$(27)&"&v3SPlease Contact Engineering Immediately"
    beep
    beep
  end if

if Deltapm < 0 then
print chr$(27)&"&v1STHIS FIXTURE IS OVERDUE FOR PM"
print chr$(27)&"&v1SPLEASE CONTACT ENGINEERING IMMEDIATELY.!!!"
stop
end if

subend


sub ReadEEprom

   dim Read_Data(7168)

   !! Start read out board 1 EEprom data
   assign @EE_data1 to "EE_Data1_Hex_u220_00";write
   assign @EE_data2 to "EE_Data1_Chr_u220_00";write

    safeguard cool
    test "digital/u220_02_rd";Read_Data(*)

    !Convert Data Array to Data String
    for K = 0 to 895     ! 4096
      Char_Data$=""
      for G = 0 to 7
         B = (K * 8) + G
         Char_Data$= Char_Data$ & val$(Read_Data(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
       output @EE_data2;"   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      else
       output @EE_data2;"   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      end if

    next K

    assign @EE_data1 to *
    assign @EE_data2 to *
subend


sub Check_Fixture_Stage (Status_Code, Message$)
global AUX_NUM, DUAL_STAGE

   if Message$ <> "" then  print tab(5);Message$
!  Status = Status_Code

       faon1.5|auxconnect 5 |faoff 2
!      auxconnect 5 |faoff2

subend
sub Commented  !TTR!

!   test "analog/c1"                                     ! Nostuff !Pre_Shorts
!   test "analog/c2"                                     ! Nostuff !Pre_Shorts
!   test "analog/c3"                                     ! Nostuff !Pre_Shorts
!   test "analog/c4"                                     ! Nostuff !Pre_Shorts
!   test "analog/c6"                                     ! Nostuff !Pre_Shorts
!   test "analog/c9"                                     ! Nostuff !Pre_Shorts
!   test "analog/c27"                                    ! Nostuff !Pre_Shorts
!   test "analog/c108"                                   ! Nostuff !Pre_Shorts
!   test "analog/c239"                                   ! Nostuff !Pre_Shorts
!   test "analog/c279"                                   ! Nostuff !Pre_Shorts
!   test "analog/c654"                                   ! Nostuff !Pre_Shorts
!   test "analog/c666"                                   ! Nostuff !Pre_Shorts
!   test "analog/c717"                                   ! Nostuff !Pre_Shorts
!   test "analog/c1335"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1398"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1440"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1699"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1958"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1961"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1962"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1975"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1976"                                  ! Nostuff !Pre_Shorts
!   test "analog/c2029"                                  ! Nostuff !Pre_Shorts
!   test "analog/c2201"                                  ! Nostuff !Pre_Shorts
!   test "analog/c2202"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3681"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3701"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3822"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3823"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3826"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3827"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3862"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3868"                                  ! Nostuff !Pre_Shorts
!   test "analog/c3870"                                  ! Nostuff !Pre_Shorts
!   test "analog/c4561"                                  ! Nostuff !Pre_Shorts
!   test "analog/c6569"                                  ! Nostuff !Pre_Shorts
!   test "analog/fmgr14"                                 ! Nostuff !Pre_Shorts
!   test "analog/fmkr7"                                  ! Nostuff !Pre_Shorts
!   test "analog/fmkr21"                                 ! Nostuff !Pre_Shorts
!   test "analog/fmkr28"                                 ! Nostuff !Pre_Shorts
!   test "analog/fmkr31"                                 ! Nostuff !Pre_Shorts
!   test "analog/fmsr2"                                  ! Nostuff !Pre_Shorts
!   test "analog/fmsr4"                                  ! Nostuff !Pre_Shorts
!   test "analog/fmtr10"                                 ! Nostuff !Pre_Shorts
!   test "analog/imbr36"                                 ! Nostuff !Pre_Shorts
!   test "analog/l114"                                   ! Nostuff !Pre_Shorts
!   test "analog/l487"                                   ! Nostuff !Pre_Shorts
!   test "analog/r70"                                    ! Nostuff !Pre_Shorts
!   test "analog/r90"                                    ! Nostuff !Pre_Shorts
!   test "analog/r93"                                    ! Nostuff !Pre_Shorts
!   test "analog/r102"                                   ! Nostuff !Pre_Shorts
!   test "analog/r160"                                   ! Nostuff !Pre_Shorts
!   test "analog/r168"                                   ! Nostuff !Pre_Shorts
!   test "analog/r176"                                   ! Nostuff !Pre_Shorts
!   test "analog/r190"                                   ! Nostuff !Pre_Shorts
!   test "analog/r191"                                   ! Nostuff !Pre_Shorts
!   test "analog/r213"                                   ! Nostuff !Pre_Shorts
!   test "analog/r268"                                   ! Nostuff !Pre_Shorts
!   test "analog/r285"                                   ! Nostuff !Pre_Shorts
!   test "analog/r300"                                   ! Nostuff !Pre_Shorts
!   test "analog/r319"                                   ! Nostuff !Pre_Shorts
!   test "analog/r327"                                   ! Nostuff !Pre_Shorts
!   test "analog/r328"                                   ! Nostuff !Pre_Shorts
!   test "analog/r330"                                   ! Nostuff !Pre_Shorts
!   test "analog/r383"                                   ! Nostuff !Pre_Shorts
!   test "analog/r384"                                   ! Nostuff !Pre_Shorts
!   test "analog/r385"                                   ! Nostuff !Pre_Shorts
!   test "analog/r389"                                   ! Nostuff !Pre_Shorts
!   test "analog/r483"                                   ! Nostuff !Pre_Shorts
!   test "analog/r486"                                   ! Nostuff !Pre_Shorts
!   test "analog/r511"                                   ! Nostuff !Pre_Shorts
!   test "analog/r521"                                   ! Nostuff !Pre_Shorts
!   test "analog/r524"                                   ! Nostuff !Pre_Shorts
!   test "analog/r540"                                   ! Nostuff !Pre_Shorts
!   test "analog/r548"                                   ! Nostuff !Pre_Shorts
!   test "analog/r549"                                   ! Nostuff !Pre_Shorts
!   test "analog/r556"                                   ! Nostuff !Pre_Shorts
!   test "analog/r577"                                   ! Nostuff !Pre_Shorts
!   test "analog/r636"                                   ! Nostuff !Pre_Shorts
!   test "analog/r641"                                   ! Nostuff !Pre_Shorts
!   test "analog/r646"                                   ! Nostuff !Pre_Shorts
!   test "analog/r650"                                   ! Nostuff !Pre_Shorts
!   test "analog/r651"                                   ! Nostuff !Pre_Shorts
!   test "analog/r654"                                   ! Nostuff !Pre_Shorts
!   test "analog/r675"                                   ! Nostuff !Pre_Shorts
!   test "analog/r678"                                   ! Nostuff !Pre_Shorts
!   test "analog/r710"                                   ! Nostuff !Pre_Shorts
!   test "analog/r715"                                   ! Nostuff !Pre_Shorts
!   test "analog/r753"                                   ! Nostuff !Pre_Shorts
!   test "analog/r756"                                   ! Nostuff !Pre_Shorts
!   test "analog/r757"                                   ! Nostuff !Pre_Shorts
!   test "analog/r758"                                   ! Nostuff !Pre_Shorts
!   test "analog/r775"                                   ! Nostuff !Pre_Shorts
!   test "analog/r776"                                   ! Nostuff !Pre_Shorts
!   test "analog/r795"                                   ! Nostuff !Pre_Shorts
!   test "analog/r796"                                   ! Nostuff !Pre_Shorts
!   test "analog/r801"                                   ! Nostuff !Pre_Shorts
!   test "analog/r802"                                   ! Nostuff !Pre_Shorts
!   test "analog/r804"                                   ! Nostuff !Pre_Shorts
!   test "analog/r805"                                   ! Nostuff !Pre_Shorts
!   test "analog/r843"                                   ! Nostuff !Pre_Shorts
!   test "analog/r844"                                   ! Nostuff !Pre_Shorts
!   test "analog/r973"                                   ! Nostuff !Pre_Shorts
!   test "analog/r975"                                   ! Nostuff !Pre_Shorts
!   test "analog/r976"                                   ! Nostuff !Pre_Shorts
!   test "analog/r978"                                   ! Nostuff !Pre_Shorts
!   test "analog/r980"                                   ! Nostuff !Pre_Shorts
!   test "analog/r983"                                   ! Nostuff !Pre_Shorts
!   test "analog/r1009"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1031"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1052"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1060"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1070"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1093"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1104"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1166"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1177"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1178"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1200"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1201"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1202"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1203"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1204"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1218"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1229"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1244"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1246"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1249"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1257"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1260"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1266"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1271"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1273"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1276"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1301"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1304"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1326"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1329"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1396"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1397"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1398"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1399"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1405"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1409"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1412"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1413"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1442"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1455"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1560"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1886"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1898"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1908"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1909"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1912"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1913"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1915"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1925"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1926"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1928"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1935"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1936"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1937"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1940"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1941"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1942"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1943"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1944"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1945"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1946"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1947"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1948"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1964"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1967"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1982"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1986"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1987"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1988"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1989"                                  ! Nostuff !Pre_Shorts
!   test "analog/r2058"                                  ! Nostuff !Pre_Shorts
!   test "analog/r2059"                                  ! Nostuff !Pre_Shorts
!   test "analog/r2869"                                  ! Nostuff !Pre_Shorts
!   test "analog/r2870"                                  ! Nostuff !Pre_Shorts
!   test "analog/r2950"                                  ! Nostuff !Pre_Shorts
subend
def fnSendMsg
global Nnum,ALL_Serial$(*),Serial$
ALL_Serial$(Nnum)=Serial$
Nnum=Nnum+1
One=0
for I=0 to Nnum-1
if ALL_Serial$(I)=Serial$ then
One=One+1
if One >=3 then
goto E
end if
end if
next I
return 0
E:
return 1
fnend
!#####################add for beacon###############
sub Get_becon_log
 global Status
 global Serial$
 global Board$
 global Board_Rev$
 global Oper$
 global System$
 global Start_time_beacon,Starttime$
 global Test_time
 global Fixture_id$
 global Count_number
 global Fab$
  dim Line$[100]

 assign @MYMAC to "C:/error/message/mac.txt" ;read
 enter @MYMAC ; Macdata$
 assign @MYMAC to *
 create ascii "C:/log" ,  ,Failed
 printer is "C:/log"

 print "Board:",Board$&" "&Board_Rev$
 print "Serial_Number:" , Serial$


 if pos(upc$(trim$(Oper$)),"M")=1 then
   print  "ICT_STATION:","PICT"
 else
   print  "ICT_STATION:","ICT"
 end if
!# if (bni = 0) then
    print  "Cell_No:","1"
!# end if
 if boardfailed then
     print "Status:" , "FAIL"
 else
     print "Status:" , "PASS"
 end if

if Status = 2 then
   print "Fail_code:","Failed_Pin_Test"
else
   if Status = 3 then
      print "Fail_code:","Failed_In_Learn"
   else
      if Status = 4 then
         print "Fail_code:","Failed_In_Shorts"
      else
         if Status = 6 then
           print "Fail_code:","Failed_In_Analog"
         else
           if Status = 7 then
              print "Fail_code:","Failed_In_Power_Supplies"
           else
             if Status = 8 then
                print "Fail_code:","Failed_In_Digital"
             else
                if Status = 9 then
                   print "Fail_code:","Failed_In_Functional"
                else
                  if Status = 10 then
                    print "Fail_code:","Failed_In_Preshorts"
                  else
                     if Status = 14 then
                        print "Fail_code:","Failed_In_VectorlessTest"
                     else
                       if Status = 15 then
                          print "Fail_code:","Failed_In_Polarity_Check"
                       else
                         if Status = 16 then
                            print "Fail_code:","Failed_In_ConnectCheck"
                         else
                           if Status = 17 then
                              print "Fail_code:","Failed_In_Analog_Cluster"
                           else
                             if Status = 18 then
                                print "Fail_code:","Failed_In_Flash"
                             else
                               if Status = 19 then
                                 print "Fail_code:","Failed_In_BScan_SiNails"
                               else
                                 if Status = 20 then
                                    print "Fail_code:","Failed_In_SW_Programming"
                                 else
                                    if Status = 21 then
                                       print "Fail_code:","Failed_In_SW_Flash"
                                    else
                                       if Status = 80 then
                                          print "Fail_code:","Error_Code"
                                       else
                                          if Status = 82 then
                                             print "Fail_code:","Break_Code"
                                          else
                                              print "Fail_code:","PASS"
                                          end if
                                       end if
                                    end if
                                 end if
                               end if
                             end if
                           end if
                         end if
                       end if
                     end if
                  end if
                end if
             end if
           end if
         end if
       end if
    end if
end if
 enter "date +""%Y-%m-%d %H:%M:%S""|";End_time$
 print  "Start_time:",Starttime$
 print  "End_time:",End_time$
 Test_time = (msec - Start_time_beacon)/1000
 print  "Test_time:" , Test_time

 print  "Operator:" , Oper$

 print "Machine:" , System$
 Getipcommand$= "ipconfig|awk -F: '{if($2 ~/192/){print $2}}'"
 enter  Getipcommand$ & "|"; Line1$
 print "IP_ADDRESS:",  trim$(Line1$)
 print "Mac_Address:",Macdata$

 print "Fixture_ID:",Fixture_id$
 Getbasename$="basename `pwd`"
 enter Getbasename$ & "|";Programname$
 print "Program_ID:",Programname$
 print "PCB_P/N:",Fab$

 print  "Retest:" , Count_number -1
 print  "Fixture_counter:" , 00000000

 print  "loopback_times:","00000000"
 print "Software_version:",revision$
 print "Average_vacuum:  "&"000000"
 print "MIN_vacuum:  "&"000000"
 print "MAX_vacuum:  "&"000000"
 print "Tester_TEMP:","000000"
 print "ESD_IMPEDANCE:","00000"
 print "ESD_VOLTAGE:","00000"

 print  "Deviation1:","00000000"
 print  "Deviation2:","00000000"
 print  "Deviation3:","00000000"
 print  "Deviation4:","00000000"
 print  "Deviation5:","00000000"
 print  "STRAIN_GAUGE1:","0000"
 print  "STRAIN_GAUGE2:","0000"
 print  "STRAIN_GAUGE3:","0000"
 print  "STRAIN_GAUGE4:","0000"
 print  "STRAIN_GAUGE5:","0000"
 print  "STRAIN_GAUGE6:","0000"
 print  "STRAIN_GAUGE7:","0000"
 print  "STRAIN_GAUGE8:","0000"
 print  "STRAIN_GAUGE9:","0000"
 print  "STRAIN_GAUGE10:","0000"

 print  ""
 print  "============================================"
 printer is *
 assign @MYLOG,MYERR to "C:/log";append

 assign @MYIYET,ERROR to "mylog.txt" ;read
 if ERROR then
      goto  REPORTOUT
 end if

 output @MYLOG ; "IYET retest detail data....."
 loop
   enter @MYIYET,,Error;Line$
   exit if Error = 101007
   output @MYLOG ; Line$
 end loop
 output @MYLOG ; "............................"
 assign @MYIYET to *
 assign @MYLOG to *

 REPORTOUT:
 report out "C:/log" ; append

 create dir "C:/error/log/",ERR
 if(ERR<>100312) and (ERR<>0) then
   print "Error with directory: C:/error/log"
   print errmlong$(ERR)
   beep
 end if
!@copy "C:/log" over "C:/error/log/"&Board$ & "-" & datetime$&"-"&Serial$
 append "C:\Program Files\Cisco\meter\Autotest_mdas_log" to "C:/log"
copy "C:/log" over "D:/log/"&Board$ & "-" & datetime$&"-"&Serial$
wait 100m
 unlink  "C:/log"

subend
!*************************for beacon**************
sub Register_ID_GUI
!    global EID$
!    global CID$
!    global ID_f$
!    global Login$
    White$                   = chr$(27)&"&v0S"
    Red$                     = chr$(27)&"&v1S"
    Green$                   = chr$(27)&"&v2S"
    Yellow$                  = chr$(27)&"&v3S"
    Blue$                    = chr$(27)&"&v4S"
    Magenta$                 = chr$(27)&"&v5S"
    Cyan$                    = chr$(27)&"&v6S"
    InvYellow$               = chr$(27)&"&v7S"&chr$(7) ! chr$(7) rings bell
    Uline$                   = chr$(27)&"&dE"

    EID$="E:/ID/EID.txt"       !User Name database !Can change path and/or name.
    CID$="C:/error/Reviser.log"   !Reviser Name Log   !Can change path and/or name.
    ID_f$                    = "id_result.txt"
    Login$                   = "C:/error/message/login_32.exe"

    Re_Enter:
    IDR=1
    unlink ID_f$,Err
    print ""
    print  Uline$&"Please input your ID and Password in PopUp Window"
    wait 2
    execute Login$
    Re_Access:
    assign @R ,Err to ID_f$;read
      if Err then
         wait 1
         IDR=IDR+1
         if IDR < 3 then
           goto Re_Access
         else
           print tab(5); InvYellow$&"Error to read Register ID file!"
           goto  Re_Enter
         end if
      else
        enter @R;ID$
        enter @R;PW$
        ID$=trim$(ID$)
        PW$=trim$(PW$)
        if not len(ID$) or not len(PW$) then
           print tab(5); InvYellow$&"User ID or Password  is NOT correct!"
           goto  Re_Enter
        end if
      end if
    assign @R to *
    unlink ID_f$,Err

    EA$=""|EP$=""
    for I =1 to len(ID$)
      EA$=EA$& ith$(num(ID$[I;1]))
    next I
    for I =1 to len(PW$)
      EP$=EP$& ith$(num(PW$[I;1]))
    next I
    Code$=EA$&ith$(num(" "))&EP$
    assign @R,Er to EID$;read
!!    print Er;EID$
    if Er =100009 then
      print ""
      print tab(5); Red$&"CAN NOT Found EID file!"
      print tab(5); Red$&"Please make sure EID file exsit and have correct file name!"
      !stop
      goto Re_Enter
    end if
    Found=0
    loop
      enter @R,,Err;Line$
      exit if Err
      if trim$(Code$)=trim$(Line$) then
        Found=1
      end if
      exit if Found
    end loop
    assign @R ,Er to *
    if Found then
       print tab(5); Green$&"Approved User and Correct Password!"
    else
       print ""
       print tab(5); InvYellow$&"User ID or Password  is NOT correct!"
       print tab(5); InvYellow$&"Please re-enter User ID and Password!"
!      pause
       goto Re_Enter
    end if
    assign @W to CID$;write!append
      output @W; ID$!datetime$
    assign @W to *
subend
